<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hibernate（三）——对象的生命周期</title>
      <link href="/2019/03/05/Hibernate%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2019/03/05/Hibernate%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Hibernate对象状态"><a href="#一、Hibernate对象状态" class="headerlink" title="一、Hibernate对象状态"></a>一、Hibernate对象状态</h2><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1g0s80x6uvcj30k90a5q4k.jpg" alt=""></p><p>如上图所示，使用new关键字构件对象，该对象的状态是瞬时状态。</p><p><strong>1. 瞬时状态转为持久化状态</strong></p><p>使用Session对象的save()或saveOrUpdate()方法保存对象后，该对象的状态由瞬时状态转换为持久化状态。使用Session对象的get()或load()方法获取对象，该对象的状态也是持久化状态。</p><p><strong>2. 持久化状态转为移除状态</strong></p><p>执行Session对象的delete()方法后，对象由原来的持久状态变为移除状态，但仍然由持久化上下文托管，直到工作单元完成。换句话说，移除状态的对象不应该被重用。移除状态的对象具有OID，Session中有或者无，数据库记录无。</p><p><strong>3. 持久化状态转为游离状态</strong></p><p>执行了Session对象的evict()、clear()或close()方法，对象由原来的持久化状态转为游离状态。</p><p><strong>4. 游离状态转为持久化状态</strong></p><p>重新获取Session对象，执行Session对象的update()或saveOrUpdate()方法，对象由游离状态转为持久化状态，该对象再次与Session对象相关联。</p><p><strong>5. 游离状态转为移除状态</strong></p><p>执行Session对象的delete()方法，对象由游离状态转为移除状态。处于瞬时状态、游离状态和移除状态的对象不再被其他对象引用时，会被Java垃圾回收机制处理。</p><h2 id="二、HibernateUtil实用工具类"><a href="#二、HibernateUtil实用工具类" class="headerlink" title="二、HibernateUtil实用工具类"></a>二、HibernateUtil实用工具类</h2><pre><code>package com.carleviets.utils;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.boot.MetadataSources;import org.hibernate.boot.registry.StandardServiceRegistry;import org.hibernate.boot.registry.StandardServiceRegistryBuilder;public class HibernateUtil {    //将开启的session绑定到线程本地对象中(类似于getCurrentSession())    private static final ThreadLocal&lt;Session&gt; THREAD_LOCAL =new ThreadLocal&lt;&gt;();    private static StandardServiceRegistry serviceRegistry=null;    private static SessionFactory sessionFactory=null;    private static Session session=null;    /**     * 在静态初始化块中初始化SessionFactory     */    static {        try {            serviceRegistry=new StandardServiceRegistryBuilder()                    .configure().build();            sessionFactory=new MetadataSources(serviceRegistry)                    .buildMetadata().buildSessionFactory();        } catch (Exception e) {            e.printStackTrace();        }    }    /**     * 获取Session的静态方法     * @return     */    public static Session getSession(){        session=THREAD_LOCAL.get();        if(session==null){            if(sessionFactory==null){                rebuildSessionFactory();            }            session=(sessionFactory!=null)?sessionFactory.openSession():null;            THREAD_LOCAL.set(session);        }        return session;    }    private static void rebuildSessionFactory() {        try {            serviceRegistry=new StandardServiceRegistryBuilder()                    .configure().build();            sessionFactory=new MetadataSources(serviceRegistry)                    .buildMetadata().buildSessionFactory();        } catch (Exception e) {            e.printStackTrace();        }    }    /**     * 关闭session     */    public static void closeSession(){        session=THREAD_LOCAL.get();        THREAD_LOCAL.set(null);        if(session!=null &amp;&amp; session.isOpen()){            session.close();        }    }}</code></pre><h2 id="三、Hibernate对象状态的转化"><a href="#三、Hibernate对象状态的转化" class="headerlink" title="三、Hibernate对象状态的转化"></a>三、Hibernate对象状态的转化</h2><p><strong>3.1、 new -&gt; save -&gt; close -&gt; update</strong></p><pre><code>@Testpublic void testSave() {    Session session = null;    Transaction tx = null;    User user = null;    try {        session = HibernateUtil.getSession();        tx = session.beginTransaction();        // 构造对象 -&gt; 瞬时状态        user = new User();        user.setUsername(&quot;刘德华&quot;);        user.setPassword(&quot;123&quot;);        // 调用save() -&gt; 持久化状态        session.save(user);        /*         * 在持久状态下,脏数据检查:当提交事务时或清理缓存时,发现session中的数据和         * 数据库中的数据不一致时,将会把session中的数据更新到数据库中         */        user.setUsername(&quot;张学友&quot;);        // 在保存以后再修改对象将会产生多条sql语句,效率较低,建议在save前修改        session.flush();        tx.commit();    } catch (Exception e) {        e.printStackTrace();        tx.rollback();    } finally {        HibernateUtil.closeSession();    }     // session被关闭 -&gt; 游离状态    System.out.println(&quot;姓名:&quot; + user.getUsername());    user.setUsername(&quot;梁朝伟&quot;);    try {        session = HibernateUtil.getSession();        tx = session.beginTransaction();        // 调用update() -&gt; 持久状态，user被session管理        // 如果此时先get()|load()获取到user -&gt; 持久状态        // 再调用delete() -&gt; 移除状态        session.update(user);        tx.commit();    } catch (Exception e) {        e.printStackTrace();        tx.rollback();    } finally {        HibernateUtil.closeSession();    }     // 游离状态}</code></pre><p><strong>3.2、 get/load -&gt; clear/evict</strong></p><pre><code>@Testpublic void testGet() {    Session session = null;    Transaction tx = null;    User user = null;    try {        session = HibernateUtil.getSession();        tx = session.beginTransaction();        // get() -&gt; 持久状态，user被session管理        // get()会立即查询该对象：范围从session，SessionFactory，数据库        // get()如果找不到对象不会抛异常，返回null        user = (User) session.get(User.class, 1);        System.out.println(&quot;姓名:&quot; + user.getUsername());        tx.commit();        // clear()清除session缓存中所有对象，evict()清除指定对象        session.clear();        // session.evict(user);        // clear()|evict() -&gt; 游离状态        user.setUsername(&quot;张国荣&quot;);        System.out.println(user.getUsername());    } catch (Exception e) {        e.printStackTrace();        tx.rollback();    } finally {        HibernateUtil.closeSession();    }}</code></pre><p><strong>get/load的区别</strong>：get会立即去查询对象，load在使用才去查询（懒加载），get找不到对象时返回null，load找不到对象时抛出ObjectNotFoundException异常。</p><p><strong>3.3、 update</strong></p><pre><code>@Testpublic void testUpdate() {    Session session = null;    Transaction tx = null;    User user = null;    try {        session = HibernateUtil.getSession();        tx = session.beginTransaction();        // 手动构造的瞬时状态对象也可以修改，但是需要指定所有属性，不建议使用        //user = new User();        //user.setId(3);        //user.setUsername(&quot;李四&quot;);        // get() -&gt; 持久化状态        user = (User) session.get(User.class, 2);        // 通过从数据库中加载该对象然后再修改可以进行判断进而避免异常，提高程序的健壮性        if (null != user) {            user.setUsername(&quot;老王&quot;);            // update() -&gt; 持久状态，user再次被session管理            session.update(user);        }         tx.commit();    } catch (Exception e) {        e.printStackTrace();        tx.rollback();    } finally {        HibernateUtil.closeSession();    }}</code></pre><p><strong>注意</strong>：先获取对象进行判断再更新，可以避免异常，提高程序的健壮性。</p><p><strong>3.4、 delete</strong></p><pre><code>@Testpublic void testDelete() {    Session session = null;    Transaction tx = null;    User user = null;    try {        session = HibernateUtil.getSession();        tx = session.beginTransaction();        // 手动构造的瞬时状态对象，指定主键也是可以删除该对象的，但是不建议这么用        //user = new User();        //user.setId(5);        // get() -&gt; 持久化状态，user被session管理        user = (User) session.get(User.class, 10);        // 通过从数据库中加载该对象然后删除可以进行判断进而避免异常,提高程序的健壮性        if (null != user) {            // delete() -&gt; 移除状态            session.delete(user);        }         tx.commit();    } catch (Exception e) {        e.printStackTrace();        tx.rollback();    } finally {        HibernateUtil.closeSession();    }}</code></pre><p><strong>注意</strong>：先获取对象进行判断再删除，可以避免异常，提高程序的健壮性。</p>]]></content>
      
      
      <categories>
          
          <category> Hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hibernate（二）——日志配置详解和SchemaExport的使用</title>
      <link href="/2019/03/05/Hibernate%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/03/05/Hibernate%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Hibernate日志配置"><a href="#一、Hibernate日志配置" class="headerlink" title="一、Hibernate日志配置"></a>一、Hibernate日志配置</h2><h4 id="1-1、-日志管理坐标引入"><a href="#1-1、-日志管理坐标引入" class="headerlink" title="1.1、 日志管理坐标引入"></a>1.1、 日志管理坐标引入</h4><pre><code>&lt;!-- 添加slf4j依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;    &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 添加slf4j-log4j转换包 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;    &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 添加log4j依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j&lt;/artifactId&gt;    &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="1-2、配置文件log4j-properties详解"><a href="#1-2、配置文件log4j-properties详解" class="headerlink" title="1.2、配置文件log4j.properties详解"></a>1.2、配置文件log4j.properties详解</h4><p>从官方下载的资源包etc路径下复制log4j.properties至项目resources路径下。</p><pre><code>## Hibernate, Relational Persistence for Idiomatic Java## License: GNU Lesser General Public License (LGPL), version 2.1 or later.# See the lgpl.txt file in the root directory or &lt;http://www.gnu.org/licenses/lgpl-2.1.html&gt;.#### direct log messages to stdout #### 设置stdout的日志输出控制台# org.apache.log4j.ConsoleAppender（控制台）# org.apache.log4j.FileAppender（文件）# org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）# org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）# org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）log4j.appender.stdout=org.apache.log4j.ConsoleAppender# 输出日志到控制台的方式log4j.appender.stdout.Target=System.out# 设置使用日志布局样式，包含日志信息的级别和信息字符串# org.apache.log4j.HTMLLayout（以HTML表格形式布局）# org.apache.log4j.PatternLayout（可以灵活地指定布局模式）# org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串）# org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）log4j.appender.stdout.layout=org.apache.log4j.PatternLayout# 灵活定义输出格式# Log4J采用类似C语言中的printf函数的打印格式格式化日志信息# %d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，# 比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2020年10月18日 22:10:28,921# %p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL# %c 输出所属的类目，通常就是所在类的全名# %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。# 举例：Testlog4j.main(TestLog4j.java:10)# %m 输出代码中指定的消息# %n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”# %r 输出自应用启动到输出该log信息耗费的毫秒数# %t 输出产生该日志事件的线程名log4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n### direct messages to file hibernate.log ####log4j.appender.file=org.apache.log4j.FileAppender#log4j.appender.file.File=hibernate.log#log4j.appender.file.layout=org.apache.log4j.PatternLayout#log4j.appender.file.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n### set log levels - for more verbose logging change &#39;info&#39; to &#39;debug&#39; #### 其中，level是日志记录的优先级，分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者自己定义的级别。# Log4j建议只使用四个级别，优先级从高到低分别是ERROR、WARN、INFO、DEBUG。# 通过在这里定义的级别，可以控制到应用程序中相应级别的日志信息的开关。# 比如在这里定义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来。# 级别参数之后的所有参数指日志信息输出到哪个地方。可以同时指定多个输出目的地。log4j.rootLogger=warn, stdout#log4j.logger.org.hibernate=info# 打印HibernateDEBUG级别所有日志#log4j.logger.org.hibernate=debug### log HQL query parser activity# 当解析查询语句时记录HQL和SQL#log4j.logger.org.hibernate.hql.ast.AST=debug### log just the SQL# 记录Hibernate DEBUG级别的SQLlog4j.logger.org.hibernate.SQL=debug### log JDBC bind parameters #### 记录JDBC参数log4j.logger.org.hibernate.type=info#log4j.logger.org.hibernate.type=debug### log schema export/update #### 记录执行SQL的DDL语句log4j.logger.org.hibernate.tool.hbm2ddl=debug### log HQL parse trees# 记录HQL#log4j.logger.org.hibernate.hql=debug### log cache activity #### 记录在清理Session缓存时,Session缓存中所有对象的状态(最多记录20个对象)#log4j.logger.org.hibernate.cache=debug### log transaction activity# 记录与事务有关的活动#log4j.logger.org.hibernate.transaction=debug### log JDBC resource acquisition# 记录得到的JDBC资源#log4j.logger.org.hibernate.jdbc=debug### enable the following line if you want to track down connection ###### leakages when using DriverManagerConnectionProvider #### 记录Hibernate连接池ConnectionProvider信息#log4j.logger.org.hibernate.connection.DriverManagerConnectionProvider=trace</code></pre><h2 id="二、SchemaExport的使用"><a href="#二、SchemaExport的使用" class="headerlink" title="二、SchemaExport的使用"></a>二、SchemaExport的使用</h2><p>Hibernate发布的几个版本对于使用SchemaExport导出数据库，变化还是有点大的。本文使用的是最新发布版本5.3.7，Hibernate 5.1.x版本之后，SchemaExport的用法不同于以前的版本，这里我们有必要和3.x，4.x的API来做一个区分。</p><pre><code>package com.carleviets;import org.hibernate.boot.Metadata;import org.hibernate.boot.MetadataSources;import org.hibernate.boot.registry.StandardServiceRegistry;import org.hibernate.boot.registry.StandardServiceRegistryBuilder;import org.hibernate.boot.spi.MetadataImplementor;import org.hibernate.cfg.Configuration;import org.hibernate.tool.hbm2ddl.SchemaExport;import org.hibernate.tool.schema.TargetType;import org.junit.Test;import java.util.EnumSet;/** * 这种方式主要用于将项目部署到一个新的环境中的时候， * 因为不可能把所有创建表的操作全部再执行一遍 */public class TestSchemaExport {    @Test    public void testCreateDB(){        //=============== 3.x和4.x的版本 ===============        //Configuration cfg=new Configuration().configure();        //SchemaExport export=new SchemaExport(cfg);        //第一个参数表示是否生成DDL脚本，第二个参数表示是否执行到数据库        //export.create(true, true);        //=============== 5.0.x版本 ===============        //StandardServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder()        //        .configure().build();        //MetadataImplementor metadataImplementor=        //        (MetadataImplementor) new MetadataSources(serviceRegistry).buildMetadata();        //SchemaExport export=new SchemaExport(serviceRegistry, metadataImplementor);        //第一个参数表示是否生成DDL脚本，第二个参数表示是否生成到数据库        //export.create(true, true);        //=============== 5.1.x版本到目前版本 ===============        //创建服务注册对象        //.configure()方法如果不写参数，表示默认获取的是hibernate.cfg.xml        //配置文件的名字是不能改的，如果改掉之后，应该在configure()方法中传入配置文件的名字，有必要的话还要传入路径        StandardServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder()                .configure().build();        //生存Metadata构建元信息        Metadata metadata=new MetadataSources(serviceRegistry).buildMetadata();        SchemaExport export=new SchemaExport();        //生成表结构        export.create(EnumSet.of(TargetType.DATABASE), metadata);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hibernate（一）——基本使用</title>
      <link href="/2019/03/04/Hibernate(%E4%B8%80)%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/03/04/Hibernate(%E4%B8%80)%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、hibernate基本使用"><a href="#一、hibernate基本使用" class="headerlink" title="一、hibernate基本使用"></a>一、hibernate基本使用</h2><h4 id="1-1、maven依赖"><a href="#1-1、maven依赖" class="headerlink" title="1.1、maven依赖"></a>1.1、maven依赖</h4><pre><code>&lt;!-- hibernate核心依赖 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.hibernate&lt;/groupId&gt;  &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;  &lt;version&gt;5.3.7.Final&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql 驱动依赖 --&gt;&lt;dependency&gt;  &lt;groupId&gt;mysql&lt;/groupId&gt;  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  &lt;version&gt;8.0.13&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="1-2、核心配置文件hibernate-cfg-xml"><a href="#1-2、核心配置文件hibernate-cfg-xml" class="headerlink" title="1.2、核心配置文件hibernate.cfg.xml"></a>1.2、核心配置文件hibernate.cfg.xml</h4><p>在resources资源目录下，创建hibernate.cfg.xml配置文件:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC        &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;        &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt;    &lt;session-factory&gt;        &lt;!--配置数据库连接--&gt;        &lt;property name=&quot;connection.driver_class&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt;        &lt;property name=&quot;connection.url&quot;&gt;jdbc:mysql://localhost:3306/hibernate?useSSL=false&amp;amp;serverTimezone=GMT%2B8&lt;/property&gt;        &lt;property name=&quot;connection.username&quot;&gt;root&lt;/property&gt;        &lt;property name=&quot;connection.password&quot;&gt;12345&lt;/property&gt;        &lt;!--指定所使用的数据库方言--&gt;        &lt;property name=&quot;dialect&quot;&gt;org.hibernate.dialect.MySQL8Dialect&lt;/property&gt;        &lt;!--数据库更新方式--&gt;        &lt;!--            update：最常用的，执行语句前先检查数据库是否存在表，不存在时创建再执行语句，存在时直接执行语句            create、create-drop:每次执行前都重现建表再执行语句            validate：检查是否存在表，如果不存在直接抛出异常        --&gt;        &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt;        &lt;!--控制台打印sql--&gt;        &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt;        &lt;!--格式化sql--&gt;        &lt;property name=&quot;format_sql&quot;&gt;true&lt;/property&gt;        &lt;!--是否显示注释，用以指出什么操作产生的SQL语句--&gt;        &lt;property name=&quot;use_sql_comments&quot;&gt;true&lt;/property&gt;        &lt;!--引入映射文件--&gt;        &lt;mapping resource=&quot;com/carleviets/pojo/User.hbm.xml&quot;/&gt;    &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;</code></pre><h4 id="1-3、实体类"><a href="#1-3、实体类" class="headerlink" title="1.3、实体类"></a>1.3、实体类</h4><pre><code>package com.carleviets.pojo;import java.io.Serializable;import java.sql.Blob;import java.sql.Clob;public class User implements Serializable{    private static final long serialVersionUID = 490983181612038387L;    private Integer id;    private String userName;    private String password;    private Clob info;    private Blob image;      //===============getters and setters===============}</code></pre><p>在User类所在的包下，编写映射文件User.hbm.xml:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC        &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;        &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt;&lt;!--package如果不写，class必须使用类的完全限定名，这里写了package指定包名，class可以只写类名--&gt;&lt;hibernate-mapping package=&quot;com.carleviets.pojo&quot;&gt;    &lt;!--name属性对应类的名称，table属性指定数据库中的表        该类必须提供公共的无参构造方法-通过反射产生对象        属性用private修饰,并且生成对应的get/set方法        类不能用final来修饰-hibernate需要产生代理类(cglib)，否则出错        table可选，表示POJO类对应数据库中的表名；如果不写默认是类名    --&gt;    &lt;class name=&quot;User&quot; table=&quot;t_user&quot;&gt;        &lt;!--hibernate的主键生成策略--&gt;        &lt;id name=&quot;id&quot;&gt;            &lt;!--                主键生成策略                increment:用于为long,short或者int类型生成唯一标识,只有在没有其他进程往                          同一张表中插入数据时才能使用.在集群下不要使用                identity:对DB2,MySQL, MS SQL Server, Sybase                         和HypersonicSQL的内置标识字段提供支持。                         返回的标识符是long, short或者int类型的。                sequence:在支持序列的数据库中使用(oracle)，                         返回的标识符是long, short或者int类型的。                        &lt;generator class=&quot;sequence&quot;&gt;                            &lt;param name=&quot;sequence&quot;&gt;user_sequence&lt;/param&gt;                        &lt;/generator&gt;                uuid:UUID被编码为一个32位16进行数字的字符串.                native:根据底层数据库的能力选择identity,sequence 或者hilo中的一个.                assigned:自己指定主键.            --&gt;            &lt;generator class=&quot;native&quot;/&gt;        &lt;/id&gt;        &lt;!--            name:指明POJO类属性名称(区分大小写)            column:表示对应数据库表的列名，如果不写则数据库中列名和属性名相同两种写法效果一致        --&gt;        &lt;property name=&quot;userName&quot; column=&quot;username&quot; type=&quot;string&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;password&quot; type=&quot;string&quot;&gt;            &lt;column name=&quot;password&quot;&gt;&lt;/column&gt;        &lt;/property&gt;        &lt;!--大对象类型必须指定type属性--&gt;        &lt;property name=&quot;info&quot; type=&quot;java.sql.Clob&quot;/&gt;        &lt;property name=&quot;image&quot; type=&quot;java.sql.Blob&quot;/&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;</code></pre><h4 id="1-4、测试类"><a href="#1-4、测试类" class="headerlink" title="1.4、测试类"></a>1.4、测试类</h4><pre><code>package com.carleviets;import com.carleviets.pojo.User;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.boot.MetadataSources;import org.hibernate.boot.registry.StandardServiceRegistry;import org.hibernate.boot.registry.StandardServiceRegistryBuilder;import org.hibernate.cfg.Configuration;import org.hibernate.mapping.MetadataSource;import org.junit.Test;public class HibernateTest {    @Test    public void test(){        SessionFactory sessionFactory=null;        Session session=null;        Transaction tx=null;        try {            //=============== 3.x版本的声明 ===============            //创建Configuration对象,new Configuration()会加载hibernate.properties文件，            //调用configure()方法会调用hibernate.cfg.xml            //Configuration cfg=new Configuration().configure();            //创建SessionFactory对象            //sessionFactory=cfg.buildSessionFactory();            //=============== 4.x版本的声明 ===============            //创建并加载hibernate.cfg.xml配置文件            //Configuration cfg=new Configuration().configure();            //创建StandardServiceRegistry服务对象            //StandardServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder()            //       .applySettings(cfg.getProperties()).build();            //创建SessionFactory            //sessionFactory=cfg.buildSessionFactory(serviceRegistry);            //=============== 5.x版本的声明 ===============            //创建StandardServiceRegistry服务对象并加载hibernate.cfg.xml配置文件            StandardServiceRegistry serviceRegistry=new StandardServiceRegistryBuilder()                    .configure().build();            //创建SessionFactory            sessionFactory=new MetadataSources(serviceRegistry)                    .buildMetadata().buildSessionFactory();            //开启Session            session=sessionFactory.openSession();            //开启事务            tx=session.beginTransaction();            //数据操作            User user=new User();            user.setUserName(&quot;张三&quot;);            user.setPassword(&quot;12345&quot;);            //保存数据            session.save(user);            //事务提交            tx.commit();        } catch (HibernateException e) {            e.printStackTrace();            //回滚事务            tx.rollback();        }finally {            //关闭session            if(session!=null &amp;&amp; session.isOpen()){                session.close();            }        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Hibernate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx与负载均衡</title>
      <link href="/2019/01/31/Nginx%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2019/01/31/Nginx%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关于Nginx"><a href="#一、关于Nginx" class="headerlink" title="一、关于Nginx"></a>一、关于Nginx</h2><p>在<strong>海量并发</strong>的环境下，用户每一次请求服务器，都需要大量的创建线程，每一次的线程都必须分配资源（CPU、内存、带宽、磁盘IO等），当<strong>资源不足</strong>的时候就会使得服务器宕机而无法提供服务。这就需要涉及到负载均衡。所谓负载均衡，就是将请求/数据均匀的分摊到多个操作单元上进行执行。</p><p>Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器,其特点是<strong>占用内存少，并发能力强</strong>（官方测试其支持五万次并发连接）。</p><h2 id="二、Nginx和Apache的纵深比对照"><a href="#二、Nginx和Apache的纵深比对照" class="headerlink" title="二、Nginx和Apache的纵深比对照"></a>二、Nginx和Apache的纵深比对照</h2><p>1、Nginx相对于Apache的优点：</p><p>轻量级，同样起web服务，但是Nginx比apache 占用更少的内存及更高的资源并发量，nginx 处理请求是异步非阻塞（如前端ajax）的，而apache 则是阻塞型的，在高并发下nginx能保持低资源低消耗高性能高度模块化的设计，编写模块相对简单。</p><p>2、apache 相对于nginx 的优点：</p><p>Apache的Rewrite重写比nginx 的rewrite 强大模块超多，基本想到的都可以找到，Apache的bug相对较少。</p><p>3.Nginx 配置简洁, Apache 复杂</p><h2 id="三、安装Nginx"><a href="#三、安装Nginx" class="headerlink" title="三、安装Nginx"></a>三、安装Nginx</h2><ul><li><strong>安装方式一</strong></li></ul><h4 id="3-1、安装依赖"><a href="#3-1、安装依赖" class="headerlink" title="3.1、安装依赖"></a>3.1、安装依赖</h4><p>Nginx的安装依赖于:gcc openssl-devel pcre-devel zlib-devel,因此在安装Nginx之前要先安装上述插件。安装命令如下：</p><pre><code>yum -y install gcc openssl-devel pcre-devel zlib-devel</code></pre><h4 id="3-2、解压文件"><a href="#3-2、解压文件" class="headerlink" title="3.2、解压文件"></a>3.2、解压文件</h4><p>安装好上述依赖后，下载并解压Nginx依赖jar包：</p><pre><code>tar -zxvf nginx-1.8.1.tar.gz</code></pre><h4 id="3-3、-configure配置"><a href="#3-3、-configure配置" class="headerlink" title="3.3、 configure配置"></a>3.3、 configure配置</h4><p>进入解压后的源码目录，然后执行configure命令进行配置</p><pre><code>./configure </code></pre><p>这里没有指定Nginx的安装目录，则默认安装目录为：<code>/usr/local/nginx</code>。 当然，可以通过 <code>--prefix /usr/soft/nginx</code> 指定安装目录为 <code>/usr/soft/nginx</code> 目录。</p><h4 id="3、4-编译并安装"><a href="#3、4-编译并安装" class="headerlink" title="3、4 编译并安装"></a>3、4 编译并安装</h4><pre><code>make &amp;&amp; make install</code></pre><h4 id="3-5、Nginx命令"><a href="#3-5、Nginx命令" class="headerlink" title="3.5、Nginx命令"></a>3.5、Nginx命令</h4><p>启动命令：</p><pre><code>nginx_home/sbin/nginx</code></pre><p>启动后，访问虚拟机的80端口，可查看到以下界面：</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fzyt3vag6ej31300a8q3p.jpg" alt=""></p><p>Nginx默认监听80端口，当出现以上信息，说明安装启动成功。</p><p>一旦nginx启动，就可以通过调用带有-s参数的可执行文件来控制它。使用语法：nginx -s 信号<br>信号可以是下列之一：</p><pre><code>stop - 快速关机  quit - 优雅的关机reload - 重新加载配置文件  reopen - 重新打开日志文件</code></pre><h4 id="3-6、-配置Nginx为系统服务"><a href="#3-6、-配置Nginx为系统服务" class="headerlink" title="3.6、 配置Nginx为系统服务"></a>3.6、 配置Nginx为系统服务</h4><p>同样，我们可以配置Nginx为系统服务，以方便管理，具体步骤如下：</p><ol><li>在/etc/rc.d/init.d/目录中建立文本文件nginx</li></ol><ol><li><p>在文件中粘贴下面的内容：</p><pre><code> #!/bin/sh # # nginx - this script starts and stops the nginx daemon # # chkconfig:   - 85 15  # description:  Nginx is an HTTP(S) server, HTTP(S) reverse \ #               proxy and IMAP/POP3 proxy server # processname: nginx # config:      /etc/nginx/nginx.conf # config:      /etc/sysconfig/nginx # pidfile:     /var/run/nginx.pid # Source function library. . /etc/rc.d/init.d/functions # Source networking configuration. . /etc/sysconfig/network # Check that networking is up. [ &quot;$NETWORKING&quot; = &quot;no&quot; ] &amp;&amp; exit 0 nginx=&quot;/usr/local/nginx/sbin/nginx&quot; prog=$(basename $nginx) NGINX_CONF_FILE=&quot;/usr/local/nginx/conf/nginx.conf&quot; [ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginx lockfile=/var/lock/subsys/nginx make_dirs() {    # make required directories    user=`nginx -V 2&gt;&amp;1 | grep &quot;configure arguments:&quot; | sed &#39;s/[^*]*--user=\([^ ]*\).*/\1/g&#39; -`    options=`$nginx -V 2&gt;&amp;1 | grep &#39;configure arguments:&#39;`    for opt in $options; do        if [ `echo $opt | grep &#39;.*-temp-path&#39;` ]; then            value=`echo $opt | cut -d &quot;=&quot; -f 2`            if [ ! -d &quot;$value&quot; ]; then                # echo &quot;creating&quot; $value                mkdir -p $value &amp;&amp; chown -R $user $value            fi        fi    done } start() {     [ -x $nginx ] || exit 5     [ -f $NGINX_CONF_FILE ] || exit 6     make_dirs     echo -n $&quot;Starting $prog: &quot;     daemon $nginx -c $NGINX_CONF_FILE     retval=$?     echo     [ $retval -eq 0 ] &amp;&amp; touch $lockfile     return $retval } stop() {     echo -n $&quot;Stopping $prog: &quot;     killproc $prog -QUIT     retval=$?     echo     [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile     return $retval } restart() {     configtest || return $?     stop     sleep 1     start } reload() {     configtest || return $?     echo -n $&quot;Reloading $prog: &quot;     killproc $nginx -HUP     RETVAL=$?     echo } force_reload() {     restart } configtest() {   $nginx -t -c $NGINX_CONF_FILE } rh_status() {     status $prog } rh_status_q() {     rh_status &gt;/dev/null 2&gt;&amp;1 } case &quot;$1&quot; in     start)         rh_status_q &amp;&amp; exit 0         $1         ;;     stop)         rh_status_q || exit 0         $1         ;;     restart|configtest)         $1         ;;     reload)         rh_status_q || exit 7         $1         ;;     force-reload)         force_reload         ;;     status)         rh_status         ;;     condrestart|try-restart)         rh_status_q || exit 0             ;;     *)         echo $&quot;Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}&quot;         exit 2 esac</code></pre></li><li><p>修改nginx文件的执行权限</p><pre><code> chmod +x nginx</code></pre></li><li><p>添加该文件到系统服务中去</p><pre><code> chkconfig --add nginx 查看是否添加成功 chkconfig --list nginx 启动，停止，重新装载 service nginx start|stop</code></pre></li></ol><h2 id="四、Nginx配置"><a href="#四、Nginx配置" class="headerlink" title="四、Nginx配置"></a>四、Nginx配置</h2><h4 id="4-1、Nginx默认配置详解"><a href="#4-1、Nginx默认配置详解" class="headerlink" title="4.1、Nginx默认配置详解"></a>4.1、Nginx默认配置详解</h4><pre><code>#进程数，建议设置和CPU个数一样或2倍worker_processes  2;#日志级别error_log  logs/error.log  warning;(默认error级别)# nginx 启动后的pid 存放位置#pid        logs/nginx.pid;events {    #配置每个进程的连接数，总的连接数= worker_processes * worker_connections    #默认1024    worker_connections  10240;}http {    include       mime.types;    default_type  application/octet-stream;    sendfile        on;#连接超时时间，单位秒keepalive_timeout  65;    server {        listen       80;        server_name  localhost                         #默认请求          location / {                     root  html;   #定义服务器的默认网站根目录位置                     index  index.php index.html index.htm;  #定义首页索引文件的名称        }        #定义错误提示页面        error_page   500 502 503 504  /50x.html;        location = /50x.html {            root   html;        }}</code></pre><h4 id="4-2、负载均衡配置"><a href="#4-2、负载均衡配置" class="headerlink" title="4.2、负载均衡配置"></a>4.2、负载均衡配置</h4><p>nginx支持以下负载均衡机制（或方法）：</p><pre><code>a)    轮询负载均衡 - 对应用程序服务器的请求以循环方式分发，b)    加权负载均衡c)    最少连接数 - 将下一个请求分配给活动连接数最少的服务器d)    ip-hash - 哈希函数用于确定下一个请求（基于客户端的IP地址）应该选择哪个服务器。</code></pre><h5 id="4-2-1、默认负载平衡配置（轮询负载均衡）"><a href="#4-2-1、默认负载平衡配置（轮询负载均衡）" class="headerlink" title="4.2.1、默认负载平衡配置（轮询负载均衡）"></a>4.2.1、默认负载平衡配置（轮询负载均衡）</h5><p>使用nginx进行负载平衡的最简单配置可能如下所示：</p><pre><code>http {     upstream carleviets{         server node01;         server node02;         server node03;     }     server {         listen 80;         server_name  localhost;        location / {            proxy_pass http://carleviets;        }    } }</code></pre><p>如果没有专门配置负载均衡方法，则默认为轮询负载均衡。所有请求都被 代理到服务器组carleviets，并且nginx应用HTTP负载平衡来分发请求。</p><h5 id="4-2-2、加权负载平衡"><a href="#4-2-2、加权负载平衡" class="headerlink" title="4.2.2、加权负载平衡"></a>4.2.2、加权负载平衡</h5><p>通过使用服务器权重分配，可以进一步影响nginx负载均衡算法，具体实现的配置如下：</p><pre><code>upstream carleviets {        server srv1.example.com weight=3;        server srv2.example.com;        server srv3.example.com;  }</code></pre><h5 id="4-2-3、-最少连接负载平衡"><a href="#4-2-3、-最少连接负载平衡" class="headerlink" title="4.2.3、 最少连接负载平衡"></a>4.2.3、 最少连接负载平衡</h5><p>在连接负载最少的情况下，nginx会尽量避免将过多的请求分发给繁忙的应用程序服务器，而是将新请求分发给不太繁忙的服务器，避免服务器过载。具体实现的配置如下：</p><pre><code>upstream carleviets {        least_conn;        server srv1.example.com;        server srv2.example.com;        server srv3.example.com;    }</code></pre><h5 id="4-2-4、-ip-hash"><a href="#4-2-4、-ip-hash" class="headerlink" title="4.2.4、 ip-hash"></a>4.2.4、 ip-hash</h5><p>上述的循环或最少连接数的负载平衡方法，每个后续客户端的请求都可能被分发到不同的服务器。不能保证相同的客户端总是定向到相同的服务器。<br>如果需要将客户端绑定到特定的应用程序服务器——换句话说，就是始终选择相同的服务器而言，就要使客户端的会话“粘滞”或“持久” 。</p><p>ip-hash负载平衡机制就是有这种特性。使用ip-hash，客户端的IP地址将用作散列键，以确定应该为客户端的请求选择服务器组中的哪台服务器。此方法可确保来自同一客户端的请求将始终定向到同一台服务器，除非此服务器不可用。</p><pre><code>upstream shsxt{    ip_hash;    server srv1.example.com;    server srv2.example.com;    server srv3.example.com;}</code></pre><h4 id="4-3-Nginx的访问控制"><a href="#4-3-Nginx的访问控制" class="headerlink" title="4.3 Nginx的访问控制"></a>4.3 Nginx的访问控制</h4><p>Nginx还可以对IP的访问进行控制，allow代表允许，deny代表禁止.</p><pre><code>location / {    # 被禁止访问的网络地址，注意，这里要配置Nginx的代理地址，因为客户端是通过代理来访问的    deny 192.168.2.180;    # 配置ipv4能访问的网段，如下配置可以访问的网段为:192.168.78.0~192.168.78.255    allow 192.168.78.0/24;    # 如下配置key访问的网段为：10.1.0.0~10.1.255.255    allow 10.1.1.0/16;    # 配置ipv6能够访问的网段    allow 192.168.1.0/32;    # 其他的所有网段都拒绝访问    deny all;    proxy_pass http://carleviets;}</code></pre><p>从上到下的顺序，匹配到了便跳出。如上的例子先禁止了1个，接下来允许了3个网段，其中包含了一个ipv6，最后未匹配的IP全部禁止访问。</p><h3 id="五、虚拟主机"><a href="#五、虚拟主机" class="headerlink" title="五、虚拟主机"></a>五、虚拟主机</h3><h5 id="5-1、虚拟主机的概念"><a href="#5-1、虚拟主机的概念" class="headerlink" title="5.1、虚拟主机的概念"></a>5.1、虚拟主机的概念</h5><p>虚拟主机是指在网络服务器上分出一定的磁盘空间，用户可以租用此部分空间，以供用户放置站点及应用组件，提供必要的数据存放和传输功能。<br>说白了虚拟主机就是把一台物理服务器划分成多个“虚拟”的服务器，各个虚拟主机之间完全独立，在外界看来，每一台虚拟主机和一台单独的主机的表现完全相同。所以这种被虚拟化的逻辑主机被形象地称为“虚拟主机”。</p><p>由于多台虚拟主机共享一台真实主机的资源，每个虚拟主机用户承受的硬件费用、网络维护费用、通信线路的费用均大幅度降低。虚拟主机有以下类别：</p><ul><li><p>基于域名的虚拟主机，通过域名来区分虚拟主机</p></li><li><p>基于端口的虚拟主机，通过端口来区分虚拟主机</p></li><li><p>基于ip的虚拟主机，很少用</p></li></ul><h5 id="5-2、基于域名的虚拟主机"><a href="#5-2、基于域名的虚拟主机" class="headerlink" title="5.2、基于域名的虚拟主机"></a>5.2、基于域名的虚拟主机</h5><pre><code>http {     upstream shsxt{         server node01;         server node02;     }     upstream bjsxt{         server node03;      }     server {         listen 80;         //访问test01.com的时候，会把请求导到carleviets01的服务器组里        server_name  test01.com;        location / {            proxy_pass http://carleviets01;        }    }     server {         listen 80;         //访问test02.com的时候，会把请求导到carleviets02的服务器组里        server_name  test02.com;         location / {            proxy_pass http://carleviets02;        }    } }</code></pre><p>注意：基于域名的虚拟机主机 在模拟应用场景时，需要在windows系统的hosts文件里配置域名映射。</p><h5 id="5-3、基于端口的虚拟主机"><a href="#5-3、基于端口的虚拟主机" class="headerlink" title="5.3、基于端口的虚拟主机"></a>5.3、基于端口的虚拟主机</h5><pre><code>http {     upstream carleviets01 {         server node01;         server node02;     }     upstream carleviets02 {         server node03    }     server {         //当访问nginx的80端口时，将请求导给carleviets01组        listen 80;         server_name localhost;        location / {            proxy_pass http://carleviets01;        }    }     server {         //当访问nginx的8080端口时，将请求导给carleviets02组        listen 8080;         server_name localhost;        location / {            proxy_pass http://carleviets02;        }    } }</code></pre><h3 id="六、正向代理和反向代理"><a href="#六、正向代理和反向代理" class="headerlink" title="六、正向代理和反向代理"></a>六、正向代理和反向代理</h3><h5 id="6-1、-正向代理"><a href="#6-1、-正向代理" class="headerlink" title="6.1、 正向代理"></a>6.1、 正向代理</h5><p>举个例子：我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，而这个代理服务器能访问那个我不能访问的网站，于是我先连上代理服务器,告诉他我需要那个无法访问网站的内容，代理服务器去取回来,然后返回给我。像我们经常通过vpn访问国外的网站，此时就是正向代理。</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fzyt5bnuybj30fl07bwgu.jpg" alt=""></p><p>客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。</p><h5 id="6-2、反向代理"><a href="#6-2、反向代理" class="headerlink" title="6.2、反向代理"></a>6.2、反向代理</h5><p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fzyt642qz7j30bu080jth.jpg" alt=""></p><p>反向代理隐藏了真实的服务端，当我们请求 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 的时候,背后可能有成千上万台服务器为我们提供服务。Nginx 就是性能非常好的反向代理服务器，用来做负载均衡。</p><h3 id="七、-Nginx的Session一致性问题"><a href="#七、-Nginx的Session一致性问题" class="headerlink" title="七、 Nginx的Session一致性问题"></a>七、 Nginx的Session一致性问题</h3><p>HTTP协议是无状态的，即你连续访问某个网页100次和访问1次对服务器来说是没有区别对待的，因为它记不住你，Servlet规范提出了Session作为其解决方案。但是在Nginx作为反向代理服务器的集群环境下，如果不是使用ip_hash，就需要解决session会话在集群中共享的问题。</p><h5 id="7-1-Session一致性解决方案"><a href="#7-1-Session一致性解决方案" class="headerlink" title="7.1 Session一致性解决方案"></a>7.1 Session一致性解决方案</h5><p>针对Session一致性的问题，有如下两种解决方案。</p><ul><li><p>1、 session复制</p><p>  tomcat 本身带有复制session的功能。</p></li><li><p>2、共享session</p><p>  需要专门管理session的软件，memcached 缓存服务，可以和tomcat整合，帮助tomcat共享管理session。</p></li></ul><p>这里我们介绍使用memcached缓存技术作为共享session的解决方案。</p><h5 id="7-2、使用memcached"><a href="#7-2、使用memcached" class="headerlink" title="7.2、使用memcached"></a>7.2、使用memcached</h5><ol><li><p>安装memcached内存数据库</p><pre><code> yum –y install memcached</code></pre></li><li><p>web服务器连接memcached的jar包拷贝到tomcat的lib目录中</p></li><li><p>配置tomcat的conf目录下的context.xml</p><pre><code> &lt;Manager className=&quot;de.javakaffee.web.msm.MemcachedBackupSessionManager&quot;     memcachedNodes=&quot;n1:192.168.107.220:11211&quot;     sticky=&quot;true&quot;     lockingMode=&quot;auto&quot;     sessionBackupAsync=&quot;false&quot;     requestUriIgnorePattern=&quot;.*\.(ico|png|gif|jpg|css|js)$&quot;     sessionBackupTimeout=&quot;1000&quot; transcoderFactoryClass=&quot;de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory&quot; /&gt;</code></pre></li></ol><p>配置memcachedNodes属性，配置memcached数据库的ip和端口，默认11211，多个的话用逗号隔开。目的是为了让tomcat服务器从memcached缓存里面拿session或者是存放session。</p><ol><li><p>修改index.jsp，取sessionid看一看</p><pre><code> &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;  pageEncoding=&quot;UTF-8&quot;%&gt; &lt;html lang=&quot;en&quot;&gt; SessionID:&lt;%=session.getId()%&gt; &lt;/br&gt; SessionIP:&lt;%=request.getServerName()%&gt; &lt;/br&gt; &lt;h1&gt;tomcat1&lt;/h1&gt; &lt;/html&gt;</code></pre><p>这样，就完成了对memcached作为session共享的配置。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级消息队列(五)——Spring集成RabbitMQ</title>
      <link href="/2019/01/27/%E9%AB%98%E7%BA%A7%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94Spring%E9%9B%86%E6%88%90RabbitMQ/"/>
      <url>/2019/01/27/%E9%AB%98%E7%BA%A7%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94Spring%E9%9B%86%E6%88%90RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Spring集成RabbitMQ"><a href="#一、Spring集成RabbitMQ" class="headerlink" title="一、Spring集成RabbitMQ"></a>一、Spring集成RabbitMQ</h2><h4 id="1、pom坐标依赖"><a href="#1、pom坐标依赖" class="headerlink" title="1、pom坐标依赖"></a>1、pom坐标依赖</h4><pre><code>&lt;!-- spring-rabbit依赖 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;  &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt;  &lt;version&gt;1.7.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>Spring AMQP 是一个消息的解决方案，它提供一个它提供了一个“模板”作为发送和接收消息的高级抽象。因此，在Spring中集成RabbitMQ时，只需要引入spring-rabbit依赖即可，而<strong>不再需要引入前面的<code>amqp-client</code>的RabbitMQ客户端依赖</strong>。</p><h4 id="2、编写一个Consumer类"><a href="#2、编写一个Consumer类" class="headerlink" title="2、编写一个Consumer类"></a>2、编写一个Consumer类</h4><pre><code>package com.carleviets.service;import org.springframework.stereotype.Service;@Servicepublic class ConsumerService {    public void test(Object obj){        System.out.println(&quot;消费者接收到消息:&quot;+obj);    }}</code></pre><h4 id="3、spring-xml具体配置"><a href="#3、spring-xml具体配置" class="headerlink" title="3、spring.xml具体配置"></a>3、spring.xml具体配置</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:rabbit=&quot;http://www.springframework.org/schema/rabbit&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/rabbit        http://www.springframework.org/schema/rabbit/spring-rabbit.xsd&quot;&gt;    &lt;context:component-scan base-package=&quot;com.carleviets&quot;/&gt;    &lt;!--配置rabbitMQ工厂类--&gt;    &lt;rabbit:connection-factory id=&quot;connectionFactory&quot; host=&quot;localhost&quot;       port=&quot;5672&quot; virtual-host=&quot;/test&quot; username=&quot;carleviets&quot; password=&quot;123456&quot;/&gt;    &lt;!-- 创建RabbitAdmin,用来管理exchange、queue、bindings --&gt;    &lt;rabbit:admin id=&quot;rabbitAdmin&quot; connection-factory=&quot;connectionFactory&quot;/&gt;    &lt;!--配置交换机，交换机可以配置多个--&gt;    &lt;rabbit:topic-exchange name=&quot;springExchange&quot;&gt;        &lt;rabbit:bindings&gt;            &lt;!--指定队列的匹配模式和队列名称，可以绑定多个队列--&gt;            &lt;rabbit:binding pattern=&quot;spring.#&quot; queue=&quot;spring_test&quot;/&gt;        &lt;/rabbit:bindings&gt;    &lt;/rabbit:topic-exchange&gt;    &lt;!--配置队列，可以配置多个--&gt;    &lt;rabbit:queue name=&quot;spring_test&quot;/&gt;    &lt;!--配置监听容器--&gt;    &lt;rabbit:listener-container connection-factory=&quot;connectionFactory&quot;&gt;        &lt;!--指定被监听Consumer消息消费类和方法，以及监听的队列名称--&gt;        &lt;rabbit:listener ref=&quot;consumerService&quot; method=&quot;test&quot; queue-names=&quot;spring_test&quot;/&gt;    &lt;/rabbit:listener-container&gt;    &lt;!--配置AMQPTemplate--&gt;    &lt;rabbit:template id=&quot;rabbitTemplate&quot; connection-factory=&quot;connectionFactory&quot; exchange=&quot;springExchange&quot; routing-key=&quot;spring.test&quot;/&gt;&lt;/beans&gt;</code></pre><h4 id="4、启动测试"><a href="#4、启动测试" class="headerlink" title="4、启动测试"></a>4、启动测试</h4><p>测试代码如下：</p><pre><code>package com.carleviets;import org.springframework.amqp.core.AmqpTemplate;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestSpringRabbitMQ {    public static void main(String[] args) {        ApplicationContext applicationContext=                new ClassPathXmlApplicationContext(&quot;spring-rabbitmq.xml&quot;);        AmqpTemplate rabbitTemplate= (AmqpTemplate) applicationContext.getBean(&quot;rabbitTemplate&quot;);        //通过rabbitTemplate模板类向队列中发送消息        rabbitTemplate.convertAndSend(&quot;Hello, Spring RabbitMQ&quot;);    }}</code></pre><h2 id="二、CRM项目中使用RabbitMQ"><a href="#二、CRM项目中使用RabbitMQ" class="headerlink" title="二、CRM项目中使用RabbitMQ"></a>二、CRM项目中使用RabbitMQ</h2><p>例如，CRM项目中需要实现记录用户行为的功能，考虑到日志记录不必立即执行，这可以通过RabbitMQ消息队列结合Spring AOP、自定义注解来实现。</p><p>自定义注解的代码如下:</p><pre><code>package com.carleviets.crm.annotations;import java.lang.annotation.*;@Target({ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface RequireLog {    String moduleName() default &quot;&quot;;}</code></pre><p>日志实体类的代码如下:</p><pre><code>package com.carleviets.crm.po;import java.io.Serializable;import java.util.Date;public class Log implements Serializable {    private static final long serialVersionUID = 1194600605382291359L;    private Integer id;              //id,主键    private String description;      //模块名称描述信息    private String method;           //调用的方法名    private String type;             //具体访问的类型    private String requestIp;        //请求ip    private String exceptionCode;    //异常代码    private String exceptionDetail;  //异常的具体信息    private Date createDate;         //创建时间    private Integer executeTime;     //执行时间    private String params;           //访问的形参值    private String createMan;        //创建人    private String result;           //方法执行结果    //=============== Getters and Setters ===============}</code></pre><p><strong>注意：日志类必须实现序列化接口，否则在消息队列的消费者方不能接收到该对象。</strong></p><p>AOP切面的定义如下:</p><pre><code>package com.carleviets.crm.aop;import com.carleviets.crm.annotations.RequireLog;import com.carleviets.crm.po.Log;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.amqp.core.AmqpTemplate;import org.springframework.stereotype.Component;import javax.annotation.Resource;import java.lang.reflect.Method;import java.util.Date;@Component@Aspectpublic class LogAspect {    @Resource    private AmqpTemplate rabbitTemplate;    @Pointcut(&quot;@annotation(com.carleviets.crm.annotations.RequireLog)&quot;)    public void log(){}    @Around(&quot;log()&quot;)    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {        //获取方法签名        MethodSignature methodSignature= (MethodSignature) proceedingJoinPoint.getSignature();        //获取所调用的方法        Method method=methodSignature.getMethod();        //通过Method对象获取到该方法上的注解        RequireLog annotation=method.getAnnotation(RequireLog.class);        //通过注解获取到注解上属性的值        String moduleName=annotation.moduleName();        Long startTime=System.currentTimeMillis();        Object result=proceedingJoinPoint.proceed();        Long endTime=System.currentTimeMillis();        Log log=new Log();        String[] moduleNameDetails=moduleName.split(&quot;-&quot;);        log.setDescription(moduleNameDetails[0]);        log.setMethod(method.getName());        log.setType(moduleNameDetails[1]);        log.setCreateDate(new Date());        log.setExecuteTime((int)(endTime-startTime));        //将log日志对象发送到消息队列中        //注意发送到队列中的对象必须能够序列化        rabbitTemplate.convertAndSend(log);        //AOP环绕通知中，调用有返回值的方法必须返回该方法执行后的结果        return result;    }}</code></pre><p>spring.xml中添加的配置如下:</p><pre><code>&lt;!--配置RabbitMQ连接工厂类--&gt;&lt;rabbit:connection-factory id=&quot;connectionFactory&quot; host=&quot;localhost&quot;       port=&quot;5672&quot; virtual-host=&quot;/crm&quot; username=&quot;carleviets&quot; password=&quot;123456&quot;/&gt;&lt;!-- 创建RabbitAdmin,用来管理exchange、queue、bindings --&gt;&lt;rabbit:admin id=&quot;rabbitAdmin&quot; connection-factory=&quot;connectionFactory&quot;/&gt;&lt;!--配置RabbitMQ交换机--&gt;&lt;rabbit:topic-exchange name=&quot;exchange_crm&quot;&gt;    &lt;rabbit:bindings&gt;        &lt;rabbit:binding pattern=&quot;crm.*&quot; queue=&quot;crm_log&quot;/&gt;    &lt;/rabbit:bindings&gt;&lt;/rabbit:topic-exchange&gt;&lt;!--配置RabbitMQ队列--&gt;&lt;rabbit:queue name=&quot;crm_log&quot;/&gt;&lt;!--配置监听容器--&gt;&lt;rabbit:listener-container connection-factory=&quot;connectionFactory&quot;&gt;    &lt;rabbit:listener ref=&quot;logService&quot; method=&quot;saveLog&quot; queue-names=&quot;crm_log&quot;/&gt;&lt;/rabbit:listener-container&gt;&lt;!--配置AMQP模板--&gt;&lt;rabbit:template id=&quot;rabbitTemplate&quot; connection-factory=&quot;connectionFactory&quot; exchange=&quot;exchange_crm&quot; routing-key=&quot;crm.log&quot;/&gt;</code></pre><p>消息消费方的具体代码如下:</p><pre><code>package com.carleviets.crm.service;import com.carleviets.crm.base.BaseService;import com.carleviets.crm.constants.CrmConstants;import com.carleviets.crm.dao.LogMapper;import com.carleviets.crm.po.Log;import com.carleviets.crm.utils.AssertUtil;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class LogService extends BaseService&lt;Log&gt; {    @Autowired    private LogMapper logMapper;    public void saveLog(Log log){        System.out.println(log);        AssertUtil.isTrue(logMapper.save(log)&lt;1, CrmConstants.OPS_FAILED_MSG);    }}</code></pre><p>可以看出，传送到队列中的Log对象，被消费方取出后即可调用LogMapper进行保存到数据库中去了。</p>]]></content>
      
      
      <categories>
          
          <category> AMQP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级消息队列(四)——RabbitMQ事务管理</title>
      <link href="/2019/01/27/%E9%AB%98%E7%BA%A7%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94RabbitMQ%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
      <url>/2019/01/27/%E9%AB%98%E7%BA%A7%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94RabbitMQ%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="一、RabbitMQ的事务机制"><a href="#一、RabbitMQ的事务机制" class="headerlink" title="一、RabbitMQ的事务机制"></a>一、RabbitMQ的事务机制</h2><p>在使用 RabbitMQ 的时候，我们可以通过消息持久化操作来解决因为服务器的异常奔溃导致的消息丢失，除此之外我们还会遇到一个问题，当消息的发布者在将消息发送出去之后，消息到底有没有正确到达 broker 代理服务器呢？如果不进行特殊配置的话，默认情况下发布操作是不会返回任何信息给生产者的，也就是默认情况下我们的生产者是不知道消息有没有正确到达 broker 的，如果在消息到达 broker 之前已经丢失的话，持久化操作也解决不了这个问题，因为消息根本就没到达代理服务器。</p><p>RabbitMQ 为我们提供了两种方式：</p><ol><li><p>通过 AMQP 事务机制实现，这也是 AMQP 协议层面提供的解决方案；</p></li><li><p>通过将 channel 设置成 confirm 模式来实现；</p></li></ol><h2 id="二、AMQP层面上的事物控制机制"><a href="#二、AMQP层面上的事物控制机制" class="headerlink" title="二、AMQP层面上的事物控制机制"></a>二、AMQP层面上的事物控制机制</h2><p>RabbitMQ 中与事务机制有关的方法有三个： txSelect(), txCommit()以及txRollback(), txSelect 用于将当前 channel 设置成事务模式，txCommit 用于提交事务， txRollback 用于回滚事。，在通过 txSelect 开启事务之后，我们便可以发布消息给 broker 代理服务器了，如果 txCommit 提交成功了，则消息一定到达了 broker 了，如果在 txCommit 执行之前 broker 异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过 txRollback 回滚事务。</p><p>使用AMQP层面上的事务机制时，Producer的代码如下:</p><pre><code>package com.carleviets.tx;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import java.io.IOException;import java.util.concurrent.TimeoutException;public class AMQPTxProducer {    public static final String QUEUE_NAME = &quot;hello&quot;;    public static void main(String[] args) throws IOException, TimeoutException {        //实例化工厂        ConnectionFactory connectionFactory = new ConnectionFactory();        connectionFactory.setHost(&quot;localhost&quot;);        connectionFactory.setPort(5672);        connectionFactory.setVirtualHost(&quot;/test&quot;);        connectionFactory.setUsername(&quot;carleviets&quot;);        connectionFactory.setPassword(&quot;123456&quot;);        //通过连接工厂获取连接        Connection connection = connectionFactory.newConnection();        //在连接上创建通道        Channel channel = connection.createChannel();        //开启事务        channel.txSelect();        try {            //在通道上声明队列            channel.queueDeclare(QUEUE_NAME, false, false, false, null);            String msg = &quot;Hello RabbitMQ&quot;;            channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, msg.getBytes(&quot;utf-8&quot;));            int a = 1 / 0;            channel.txCommit();        } catch (IOException e) {            e.printStackTrace();            channel.txRollback();        }        System.out.println(&quot;消息发送成功!&quot;);        //关闭资源        channel.close();        connection.close();    }}</code></pre><p>事务确实能够解决 producer 与 broker 之间消息确认的问题，只有消息成功被 broker 接受，事务提交才能成功，否则我们便可以在捕获异常进行事务回滚操作同时进行消息重发，但是使用事务机制的话会降低 RabbitMQ 的性能。</p><h2 id="三、Confirm-确认模式"><a href="#三、Confirm-确认模式" class="headerlink" title="三、Confirm 确认模式"></a>三、Confirm 确认模式</h2><h4 id="1、Confirm-确认模式原理"><a href="#1、Confirm-确认模式原理" class="headerlink" title="1、Confirm 确认模式原理"></a>1、Confirm 确认模式原理</h4><p>生产者将信道设置成 confirm 模式，一旦信道进入 confirm 模式，所有在该信道上面发布的消息都会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后， broker 就会发送一个确认给生产者（包含消息的唯一 ID）,这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出， broker 回传给生产者的确认消息中 deliver-tag 域包含了确认消息的序列号，此外 broker 也可以设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理。</p><p>confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息，生产者应用程序同样可以在回调方法中处理该 nack 消息。</p><p>在 channel 被设置成 confirm 模式之后，所有被 publish 的后续消息都将被 confirm（即 ack） 或者被 nack 一次。但是没有对消息被confirm 的快慢做任何保证，并且同一条消息不会既被 confirm 又被 nack 。</p><p>实现生产者 confirm 机制有三种方式:</p><ol><li><p>普通 confirm 模式：每发送一条消息后，调用 waitForConfirms()方法，等待服务器端 confirm。实际上是一种串行 confirm 。</p></li><li><p>批量 confirm 模式：每发送一批消息后，调用 waitForConfirms()方法，等待服务器端 confirm。</p></li><li><p>异步 confirm模式：提供一个回调方法，服务端 confirm 了一条或者多条消息后 Client端会回调这个方法。</p></li></ol><h4 id="2、串行Confirm"><a href="#2、串行Confirm" class="headerlink" title="2、串行Confirm"></a>2、串行Confirm</h4><p>使用串行Confirm来实现事务控制的代码样例如下:</p><pre><code>package com.carleviets.tx;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import java.io.IOException;import java.util.concurrent.TimeoutException;public class SyncConfirmProducer {    public static final String QUEUE_NAME = &quot;hello&quot;;    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException {        //创建连接工厂        ConnectionFactory connectionFactory = new ConnectionFactory();        connectionFactory.setHost(&quot;localhost&quot;);        connectionFactory.setPort(5672);        connectionFactory.setVirtualHost(&quot;/test&quot;);        connectionFactory.setUsername(&quot;carleviets&quot;);        connectionFactory.setPassword(&quot;123456&quot;);        //通过连接工厂获取连接对象        Connection connection=connectionFactory.newConnection();        //通过连接对象获取连接通道        Channel channel=connection.createChannel();        //开启confirm模式        channel.confirmSelect();        //在通道上声明队列        channel.queueDeclare(QUEUE_NAME, false, false, false,null);        String msg=&quot;hello&quot;;        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, msg.getBytes(&quot;utf-8&quot;));        if(channel.waitForConfirms()) {            System.out.println(&quot;消息正确到达中间件....&quot;);        }else{            //在这儿采取补救措施            System.out.println(&quot;消息发送失败...&quot;);        }        //关闭资源        channel.close();        connection.close();    }}</code></pre><h4 id="3、异步Confirm"><a href="#3、异步Confirm" class="headerlink" title="3、异步Confirm"></a>3、异步Confirm</h4><p>异步 confirm 模式的实现比较复杂， Channel 对象提供的ConfirmListener()回调方法只包含 deliveryTag（当前 Chanel 发出的消息序号），我们需要自己为每一个 Channel 维护一个 unconfirm 的消息序号集合，每publish 一条数据，集合中元素加 1，每回调一次 handleAck 方法， unconfirm集合删掉相应的一条（multiple=false）或多条（multiple=true）记录。从程序运行效率上看，这个 unconfirm 集合最好采用有序集合 SortedSet 存储结构。实际上， SDK 中的 waitForConfirms()方法也是通过 SortedSet 维护消息序号的。异步Confirm模式的代码实现样例如下:</p><pre><code>package com.carleviets.tx;import com.rabbitmq.client.Channel;import com.rabbitmq.client.ConfirmListener;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import java.io.IOException;import java.util.Collections;import java.util.SortedSet;import java.util.TreeSet;import java.util.concurrent.TimeoutException;public class AsyncConfirmProducer {    public static final String QUEUE_NAME=&quot;hello&quot;;    public static void main(String[] args) throws IOException, TimeoutException {        //创建连接工厂        ConnectionFactory connectionFactory=new ConnectionFactory();        connectionFactory.setHost(&quot;localhost&quot;);        connectionFactory.setPort(5672);        connectionFactory.setVirtualHost(&quot;/test&quot;);        connectionFactory.setUsername(&quot;carleviets&quot;);        connectionFactory.setPassword(&quot;123456&quot;);        //通过连接工厂获取到连接对象        Connection connection=connectionFactory.newConnection();        //维护信息发送回执id        final SortedSet&lt;Long&gt; confirmSet= Collections.synchronizedSortedSet(new TreeSet&lt;Long&gt;());        //通过连接对象打开通道        Channel channel=connection.createChannel();        //在通道上声明队列        channel.queueDeclare(QUEUE_NAME, false, false, false, null);        //开启Confirm模式        channel.confirmSelect();        String msg=&quot;Hello RabbitMQ&quot;;        //添加channel监听        channel.addConfirmListener(new ConfirmListener() {            //发送成功的情况            @Override            public void handleAck(long deliveryTag, boolean multiple) throws IOException {                if(multiple){                    System.out.println(&quot;handleAck--&gt;success--&gt;multiple&quot;+deliveryTag);                    //清除前deliveryTag项标识id                    confirmSet.headSet(deliveryTag+1).clear();                }else{                    System.out.println(&quot;handleAck--&gt;success--&gt;single&quot;+deliveryTag);                    confirmSet.remove(deliveryTag);                }            }            //发送失败的情况            @Override            public void handleNack(long deliveryTag, boolean multiple) throws IOException {                if(multiple){                    System.out.println(&quot;handleAck--&gt;failed--&gt;multiple&quot;+deliveryTag);                    //TODO 正常情况下要把失败的id拿出来进行发送                }else{                    System.out.println(&quot;headAck--&gt;failed--&gt;multiple&quot;+deliveryTag);                }            }        });        while (true){            Long seqNo=channel.getNextPublishSeqNo();            channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, msg.getBytes(&quot;utf-8&quot;));            confirmSet.add(seqNo);        }    }}</code></pre><h2 id="四、Consumer代码实现"><a href="#四、Consumer代码实现" class="headerlink" title="四、Consumer代码实现"></a>四、Consumer代码实现</h2><p>最后，所有上述消息生产者对应的消费者端的Java代码实现如下:</p><pre><code>package com.carleviets.tx;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Receiver {    public static final String QUEUE_NAME=&quot;hello&quot;;    public static void main(String[] args) throws IOException, TimeoutException {        //创建连接工厂        ConnectionFactory connectionFactory=new ConnectionFactory();        connectionFactory.setHost(&quot;localhost&quot;);        connectionFactory.setPort(5672);        connectionFactory.setVirtualHost(&quot;/test&quot;);        connectionFactory.setUsername(&quot;carleviets&quot;);        connectionFactory.setPassword(&quot;123456&quot;);        //通过连接工厂获取到连接        Connection connection=connectionFactory.newConnection();        //通过连接获取通道        Channel channel=connection.createChannel();        //在通道上声明队列        channel.queueDeclare(QUEUE_NAME, false, false, false, null);        //创建消费者对象        Consumer consumer=new DefaultConsumer(channel){            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {                String msg=new String(body, &quot;utf-8&quot;);                System.out.println(&quot;接收方收到消息--&gt;&quot;+msg);            }        };        //将队列加入监听        channel.basicConsume(QUEUE_NAME, true, consumer);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> AMQP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级消息队列(三)——RabbitMQ的几种模式</title>
      <link href="/2019/01/27/%E9%AB%98%E7%BA%A7%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E5%85%AD%E7%A7%8D%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/01/27/%E9%AB%98%E7%BA%A7%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94RabbitMQ%E7%9A%84%E5%85%AD%E7%A7%8D%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、工作队列-消息轮询分发-Round-robin"><a href="#一、工作队列-消息轮询分发-Round-robin" class="headerlink" title="一、工作队列-消息轮询分发(Round-robin)"></a>一、工作队列-消息轮询分发(Round-robin)</h2><p>对于前面的RabbitMQ入门程序，消息的消费者只有一个，当消息量非常大时，单个消费者处理消息就会变得很慢，同时给节点页带来很大压力，导致消息堆积越来越多。 对于这种情况， Rabbitmq 提供了工作队列模式，通过工作队列提供做个消费者，对 mq 产生的消息进行消费，提高 mq 消息的吞吐率，降低消息的处理时间。 处理模型图如下:</p><p><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1fzl75sst85j30hu06i3yw.jpg" alt=""></p><h4 id="1、Producer——消息生产者代码实现"><a href="#1、Producer——消息生产者代码实现" class="headerlink" title="1、Producer——消息生产者代码实现"></a>1、Producer——消息生产者代码实现</h4><p>消息生产者产生消息，并将消息投送到 work 队列，每产生一条消息，线程休眠 1 秒来模拟生产环境。具体代码实现如下:</p><pre><code>package com.carleviets.polling;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import java.io.IOException;import java.util.concurrent.TimeoutException;/** * 采用轮询的机制 */public class Producer {    public static final String QUEUE_NAME=&quot;work_polling&quot;;    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException {        //实例化连接工厂        ConnectionFactory connectionFactory=new ConnectionFactory();        connectionFactory.setHost(&quot;localhost&quot;);        connectionFactory.setPort(5672);        connectionFactory.setVirtualHost(&quot;/test&quot;);        connectionFactory.setUsername(&quot;carleviets&quot;);        connectionFactory.setPassword(&quot;123456&quot;);        //通过连接工厂获取连接        Connection connection=connectionFactory.newConnection();        //通过连接创建通道        Channel channel=connection.createChannel();        /**          *在通道上声明一个 Queue          *   第一个参数queue:队列的名称          *   第二个参数 durable：是否持久化          *   第三个参数 Exclusive：排他队列，如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，          *   并在连接断开时自动删除。这里需要注意三点：          *   其一，排他队列是基于连接可见的，同一连接的不同通道是可以同时访问同一个连接创建的排他队列的。          *   其二， “首次” ，如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同。          *   其三，即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除的。          *   这种队列适用于只限于一个客户端发送读取消息的应用场景。          *   第四个参数： Auto-delete:自动删除，如果该队列没有任何订阅的消费者的话，该队列会被自动删除。这种队列适用于临时队列。          */        channel.queueDeclare(QUEUE_NAME, false, false, false,null);        for(int i=0;i&lt;20;i++){            String msg=&quot;Hello rabbitMQ&quot;+i;            channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, msg.getBytes(&quot;utf-8&quot;));            System.out.println(&quot;消息发送成功--&gt;&quot;+msg);            Thread.sleep(1000);        }        channel.close();        connection.close();    }}</code></pre><h4 id="2、Consumer——消息消费者代码实现"><a href="#2、Consumer——消息消费者代码实现" class="headerlink" title="2、Consumer——消息消费者代码实现"></a>2、Consumer——消息消费者代码实现</h4><p>这里定义两个消费者， 01 消费者消费一条消息休眠 1 秒， 2 号消费者消费一条消息休眠 3 秒。两个消费者类的具体代码实现大同小异，这里给出 Consumer01的具体代码:</p><pre><code>package com.carleviets.polling;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Consumer01 {    public static final String QUEUE_NAME=&quot;work_polling&quot;;    public static void main(String[] args) throws IOException, TimeoutException {        //实例化连接工厂        ConnectionFactory connectionFactory=new ConnectionFactory();        connectionFactory.setHost(&quot;localhost&quot;);        connectionFactory.setPort(5672);        connectionFactory.setVirtualHost(&quot;/test&quot;);        connectionFactory.setUsername(&quot;carleviets&quot;);        connectionFactory.setPassword(&quot;123456&quot;);        //通过连接工厂获取连接        Connection connection=connectionFactory.newConnection();        //通过连接打开通道        Channel channel=connection.createChannel();         /**          *在通道上声明一个 Queue          *   第一个参数queue:队列的名称          *   第二个参数 durable：是否持久化          *   第三个参数 Exclusive：排他队列，如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，          *   并在连接断开时自动删除。这里需要注意三点：          *   其一，排他队列是基于连接可见的，同一连接的不同通道是可以同时访问同一个连接创建的排他队列的。          *   其二， “首次” ，如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同。          *   其三，即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除的。          *   这种队列适用于只限于一个客户端发送读取消息的应用场景。          *   第四个参数： Auto-delete:自动删除，如果该队列没有任何订阅的消费者的话，该队列会被自动删除。这种队列适用于临时队列。          */        channel.queueDeclare(QUEUE_NAME, false, false, false, null);        //创建Consumer对象        Consumer consumer=new DefaultConsumer(channel){            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {                String msg=new String(body, &quot;utf-8&quot;);                System.out.println(&quot;消费者01接受到消息--&gt;&quot;+msg);                try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        };        //将队列加入到监听        channel.basicConsume(QUEUE_NAME, true, consumer);    }}</code></pre><h4 id="3、测试结果"><a href="#3、测试结果" class="headerlink" title="3、测试结果"></a>3、测试结果</h4><p>启动消费者 01 ， 02 两方，等待处理 work 队列消息， 后启动生产者即可完成测试。从测试结果可以看出消息是平均分配到两个消费方的。</p><h2 id="二、工作队列-消息公平分发-fair-dispatch"><a href="#二、工作队列-消息公平分发-fair-dispatch" class="headerlink" title="二、工作队列-消息公平分发(fair dispatch)"></a>二、工作队列-消息公平分发(fair dispatch)</h2><p>默认情况下，消息分发采用的是轮询分发， 消息应答采用的自动应答模式， 这是因为当消息进入队列， RabbitMQ 就会分派消息。它不看消费者为应答的数目，只是盲目的将第 n 条消息发给第 n 个消费者。为了解决这个问题，我们使用 basicQos( prefetchCount = 1)方法，来限制RabbitMQ 只发不超过 1 条的消息给同一个消费者。当消息处理完毕后，有了反馈，才会进行第二次发送。 执行模型图如下</p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fzl7f73spwj30nt076my4.jpg" alt=""></p><h4 id="1、Producer——消息生产者代码实现-1"><a href="#1、Producer——消息生产者代码实现-1" class="headerlink" title="1、Producer——消息生产者代码实现"></a>1、Producer——消息生产者代码实现</h4><pre><code>package com.carleviets.fair;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import java.io.IOException;import java.util.concurrent.TimeoutException;/** * 采用公平分发的方式 */public class Producer {    public static final String QUEUE_NAME=&quot;work_fair&quot;;    public static void main(String[] args) throws IOException, TimeoutException, InterruptedException {        //创建连接工厂对象        ConnectionFactory connectionFactory=new ConnectionFactory();        connectionFactory.setHost(&quot;localhost&quot;);        connectionFactory.setPort(5672);        connectionFactory.setVirtualHost(&quot;/test&quot;);        connectionFactory.setUsername(&quot;carleviets&quot;);        connectionFactory.setPassword(&quot;123456&quot;);        //通过连接工厂获取到连接        Connection connection=connectionFactory.newConnection();        //通过连接打开通道        Channel channel=connection.createChannel();        //接收到队列里的消息但没有返回确认结果之前,它不会将新的消息分发给它        //// 每次分发不超过 1 条        channel.basicQos(1);        //在通道上创建队列        channel.queueDeclare(QUEUE_NAME, false, false, false, null);        for(int i=0;i&lt;30;i++){            String msg=&quot;Hello RabbitMQ--&gt;&quot;+i;            channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, msg.getBytes(&quot;utf-8&quot;));            System.out.println(&quot;消息发送成功--&gt;&quot;+msg);            Thread.sleep(1000);        }        //关闭资源        channel.close();        connection.close();    }}</code></pre><h4 id="2、Consumer——消息消费者代码实现-1"><a href="#2、Consumer——消息消费者代码实现-1" class="headerlink" title="2、Consumer——消息消费者代码实现"></a>2、Consumer——消息消费者代码实现</h4><p>两个消费者类的具体代码实现大同小异，这里给出 Consumer01的具体代码:</p><pre><code>package com.carleviets.fair;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Consumer01 {    public static final String QUEUE_NAME=&quot;work_fair&quot;;    public static void main(String[] args) throws IOException, TimeoutException {        //创建连接工厂        ConnectionFactory connectionFactory=new ConnectionFactory();        connectionFactory.setHost(&quot;localhost&quot;);        connectionFactory.setPort(5672);        connectionFactory.setVirtualHost(&quot;/test&quot;);        connectionFactory.setUsername(&quot;carleviets&quot;);        connectionFactory.setPassword(&quot;123456&quot;);        //通过连接工厂获取连接        Connection connection=connectionFactory.newConnection();        //在连接上打开通道        Channel channel=connection.createChannel();        //接收到队列里的消息但没有返回确认结果之前,它不会将新的消息分发给它        channel.basicQos(1);        //在通道上声明队列        channel.queueDeclare(QUEUE_NAME, false, false, false, null);        //创建消费者        Consumer consumer=new DefaultConsumer(channel){            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {                String msg=new String(body, &quot;utf-8&quot;);                System.out.println(&quot;消费方01接受到消息--&gt;&quot;+msg);                try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                //手动回复消息给MQ服务器                channel.basicAck(envelope.getDeliveryTag(), false);            }        };        //将队列加入到监听,false表示不主动回复MQ服务器消息        channel.basicConsume(QUEUE_NAME, false, consumer);    }}</code></pre><p>注意，在公平分发机制中，通过将channel.basicConsume()方法中的第二个参数设置为false，<strong>消费方不主动回复服务器消息，而是通过在Consumer中手动回复消息给RabbitMQ服务器</strong>。这点很重要。</p><h2 id="三、消息的发布与订阅-Publish-Subscribe"><a href="#三、消息的发布与订阅-Publish-Subscribe" class="headerlink" title="三、消息的发布与订阅(Publish/Subscribe)"></a>三、消息的发布与订阅(Publish/Subscribe)</h2><p>当生产者把消息投送出去后，不同的消费者均可以对该消息进行消费，而不是消息被一个消费者消费后就立即从队列中删除，对于这种消息处理，我们通常称之为消息的发布与订阅模式，凡是消费者订阅了该消息，均能够收到对应消息进行处理，比较常见的如用户注册操作。模型图如下：</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fzlatxwp30j30l406ymxw.jpg" alt=""></p><p>从图中看到:</p><p>1.消息产生后不是直接投送到队列中，而是将消息先投送给 Exchange 交换机，然后消息经过 Exchange 交换机投递到相关队列。</p><p>2.多个消费者消费的不再是同一个队列，而是每个消费者消费属于自己的队列。</p><h4 id="1、Producer——消息生产者代码实现（fanout）"><a href="#1、Producer——消息生产者代码实现（fanout）" class="headerlink" title="1、Producer——消息生产者代码实现（fanout）"></a>1、Producer——消息生产者代码实现（fanout）</h4><pre><code>package com.carleviets.publish_subscribe.fanout;import com.carleviets.utils.RabbitMQUtil;import com.rabbitmq.client.BuiltinExchangeType;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Publisher {    public static final String EXCHANGE_NAME = &quot;exchange_fanout&quot;;    public static void main(String[] args) throws IOException, TimeoutException {        //获取连接        Connection connection = RabbitMQUtil.getConnection();        //在连接上打开通道        Channel channel = connection.createChannel();        //fanout:绑定到交换机上的所有队列，均能够收到交换机路由的消息        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);        String msg = &quot;18817504384&amp;carleviets0420@163.com&quot;;        //将消息发送到绑定的交换机上        channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, msg.getBytes(&quot;utf-8&quot;));        System.out.println(&quot;消息发送成功...&quot;);        //关闭资源        channel.close();        connection.close();    }}</code></pre><p>在上面的消费端代码中，我们使用了封装了获取连接的RabbitMQUtil实用工具类，其具体代码如下:</p><pre><code>package com.carleviets.utils;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import java.io.IOException;import java.util.concurrent.TimeoutException;public class RabbitMQUtil {    public static Connection getConnection() throws IOException, TimeoutException {        //创建连接工厂        ConnectionFactory connectionFactory=new ConnectionFactory();        connectionFactory.setHost(&quot;localhost&quot;);        connectionFactory.setPort(5672);        connectionFactory.setVirtualHost(&quot;/test&quot;);        connectionFactory.setUsername(&quot;carleviets&quot;);        connectionFactory.setPassword(&quot;123456&quot;);        //获取连接并返回        return connectionFactory.newConnection();    }}</code></pre><h4 id="2、Consumer——消息消费者代码实现-2"><a href="#2、Consumer——消息消费者代码实现-2" class="headerlink" title="2、Consumer——消息消费者代码实现"></a>2、Consumer——消息消费者代码实现</h4><p>对于消费者，消费消息时，消息通过交换机 Exchange 被路由到指定队列,绑定队列到指定交换机来实现,其中一个消费者接到消息后，用于邮件发送模拟，另一消费者收到消息，用于短信发送模拟。</p><p>邮件消费者的具体代码，如下:</p><pre><code>package com.carleviets.publish_subscribe.fanout;import com.carleviets.utils.RabbitMQUtil;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class MailReceiver {    public static final String EXCHANGE_NAME=&quot;exchange_fanout&quot;;    public static final String QUEUE_NAME=&quot;mail&quot;;    public static void main(String[] args) throws IOException, TimeoutException {        //获取连接        Connection connection= RabbitMQUtil.getConnection();        //通过连接打开通道        Channel channel=connection.createChannel();        //通道上声明交换机和队列        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);        channel.queueDeclare(QUEUE_NAME, false, false, false, null);        //将队列、交换机和通道关联起来        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);        //创建消费者对象        Consumer consumer=new DefaultConsumer(channel){            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {                String msg=new String(body, &quot;utf-8&quot;);                System.out.println(&quot;邮件消费方收到消息--&gt;&quot;+msg);            }        };        //将队列加入到监听        channel.basicConsume(QUEUE_NAME, false, consumer);    }}</code></pre><p>短信发送消费者的具体代码如下:</p><pre><code>package com.carleviets.publish_subscribe.fanout;import com.carleviets.utils.RabbitMQUtil;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class SmsReceiver {    public static final String EXCHANGE_NAME=&quot;exchange_fanout&quot;;    public static final String QUEUE_NAME=&quot;sms&quot;;    public static void main(String[] args) throws IOException, TimeoutException {        //获取连接        Connection connection= RabbitMQUtil.getConnection();        //通过连接打开通道        Channel channel=connection.createChannel();        //在通道上声明交换机和队列        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);        channel.queueDeclare(QUEUE_NAME, false, false, false, null);        //将队列绑定到交换机        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);        //创建Consumer对象        Consumer consumer=new DefaultConsumer(channel){            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {                String msg=new String(body, &quot;utf-8&quot;);                System.out.println(&quot;短信消费方收到消息--&gt;&quot;+msg);            }        };        //将队列加入到监听        channel.basicConsume(QUEUE_NAME, true, consumer);    }}</code></pre><h4 id="3、测试结果-1"><a href="#3、测试结果-1" class="headerlink" title="3、测试结果"></a>3、测试结果</h4><p>测试过后，可以看到，基于发布订阅模型的fanout类型，两个绑定到不同队列的消费者都接收到了消息。</p><h2 id="四、消息路由（Routing）"><a href="#四、消息路由（Routing）" class="headerlink" title="四、消息路由（Routing）"></a>四、消息路由（Routing）</h2><p>针对不同的消息，在对消息进行消费时，通过 Exchange types 以及 Routing key 设置的规则 ，将不同消息路由到不同的队列中然后交给不同消费者进行消费操作。这是通过ExchangeTypes 中的 direct 类来实现的。</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fzl906j4gpj30nm08pgmo.jpg" alt=""></p><p>从图中可以看出:</p><ol><li><p>生产者产生的消息投给交换机</p></li><li><p>交换机投送消息时的 Exchange Types 为 direct 类型</p></li><li><p>消息通过定义的 Routing Key 被路由到指定的队列进行后续消费</p></li></ol><h4 id="1、Producer——消息生产者代码实现（direct）"><a href="#1、Producer——消息生产者代码实现（direct）" class="headerlink" title="1、Producer——消息生产者代码实现（direct）"></a>1、Producer——消息生产者代码实现（direct）</h4><p>生产者产生消息，对于交换机定义exchange types为 direct。例如日志信息需要根据不同级别投递到不同的队列的具体实现代码如下:</p><pre><code>package com.carleviets.publish_subscribe.direct;import com.carleviets.utils.RabbitMQUtil;import com.rabbitmq.client.BuiltinExchangeType;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Publisher {    public static final String  EXCHANGE_NAME=&quot;exchange_direct&quot;;    public static void main(String[] args) throws IOException, TimeoutException {        //获取连接        Connection connection= RabbitMQUtil.getConnection();        //通过连接打开通道        Channel channel=connection.createChannel();        //direct:绑定到交换机上的所有队列，交换机路由消息，通知指定具体的路由key进行有选择的路由        //在通道上声明交换机        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);        //声明并发布消息        String errorMsg=&quot;error 消息&quot;;        channel.basicPublish(EXCHANGE_NAME, &quot;error&quot;, null, errorMsg.getBytes(&quot;utf-8&quot;));        String infoMsg=&quot;info 消息&quot;;        channel.basicPublish(EXCHANGE_NAME, &quot;info&quot;, null, infoMsg.getBytes(&quot;utf-8&quot;));        String warningMsg=&quot;warning 消息&quot;;        channel.basicPublish(EXCHANGE_NAME, &quot;warning&quot;, null, warningMsg.getBytes(&quot;utf-8&quot;));        //关闭资源        channel.close();        connection.close();    }}</code></pre><h4 id="2、Consumer——消息消费者代码实现-3"><a href="#2、Consumer——消息消费者代码实现-3" class="headerlink" title="2、Consumer——消息消费者代码实现"></a>2、Consumer——消息消费者代码实现</h4><p>消费者对消息进行后续消费时，对于接收消息的队列在对消息进行接收时，绑定到每一个交换机上的队列均会指定其 Routing Key 规则，通过路由规则将消息路由到执行队列中。</p><p>消费者ErrorConsumer的 routing key=error， 错误日志消息均会路由到 error 队列中，代码如下:</p><pre><code>package com.carleviets.publish_subscribe.direct;import com.carleviets.utils.RabbitMQUtil;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class ErrorConsumer {    public static final String EXCHANGE_NAME=&quot;exchange_direct&quot;;    public static final String QUEUE_NAME=&quot;error&quot;;    public static void main(String[] args) throws IOException, TimeoutException {        //获取连接        Connection connection= RabbitMQUtil.getConnection();        //在连接上打开通道        Channel channel=connection.createChannel();        //在通道上声明交换机和队列        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);        channel.queueDeclare(QUEUE_NAME, false, false, false, null);        //将队列绑定到交换机上:添加绑定key, key可以绑定多个        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;error&quot;);        //创建Consumer对象        Consumer consumer=new DefaultConsumer(channel){            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {                String msg=new String(body, &quot;utf-8&quot;);                System.out.println(&quot;error消息消费方接收到消息--&gt;&quot;+msg);            }        };        //将队列加入到监听        channel.basicConsume(QUEUE_NAME, true, consumer);    }}</code></pre><p>而消费者InfoWarningConsumer的routing key=info 和routing key= warning，普通消息和警告消息都会路由到info_warning队列中：</p><pre><code>package com.carleviets.publish_subscribe.direct;import com.carleviets.utils.RabbitMQUtil;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class InfoWarningConsumer {    public static final String EXCHANGE_NAME=&quot;exchange_direct&quot;;    public static final String QUEUE_NAME=&quot;info_warning&quot;;    public static void main(String[] args) throws IOException, TimeoutException {        //获取连接        Connection connection= RabbitMQUtil.getConnection();        //通过连接打开通道        Channel channel=connection.createChannel();        //在通道上声明交换机和队列        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);        channel.queueDeclare(QUEUE_NAME, false, false, false,null);        //将队列绑定到交换机：添加绑定key，key可以绑定多个        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;info&quot;);        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;warning&quot;);        //创建Consumer对象        Consumer consumer=new DefaultConsumer(channel){            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {                String msg=new String(body, &quot;utf-8&quot;);                System.out.println(&quot;info_warning消费方收到消息--&gt;&quot;+msg);            }        };        //将队列加入到监听        channel.basicConsume(QUEUE_NAME, true, consumer);    }}</code></pre><h2 id="五、topic-主题模式"><a href="#五、topic-主题模式" class="headerlink" title="五、topic 主题模式"></a>五、topic 主题模式</h2><p>RabbitMq 除了 direct 模式外， Mq 同样还提供了 topics 主题模式来对消息进行匹配路由。topic模式routing key 匹配模式定义规则如下:</p><ul><li><p>routing key 为一个句点号“. ” 分隔的字符串（我们将被句点号“. ” 分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse” 、 “nyse.vmw” 、 “quick.orange.rabbit”等。</p></li><li><p>routing key 中可以存在两种特殊字符“<em>” 与“#” ，用于做模糊匹配，其中“</em>” 用于匹配一个单词， “#” 用于匹配多个单词（可以是零个）。</p></li></ul><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fzl98k22u5j30mw094jsb.jpg" alt=""></p><h4 id="1、Producer——消息生产者代码实现（direct）-1"><a href="#1、Producer——消息生产者代码实现（direct）-1" class="headerlink" title="1、Producer——消息生产者代码实现（direct）"></a>1、Producer——消息生产者代码实现（direct）</h4><p>考虑这样一种场景，在电子商务网站中，对于商品的查询功能在对商品进行查询时我们将查询消息路由到查询对应队列，而对于商品的添加、更新、删除等操作我们统一路由到另外一个队列来进行处理，这时样例代码可能如下:</p><pre><code>package com.carleviets.publish_subscribe.topics;import com.carleviets.utils.RabbitMQUtil;import com.rabbitmq.client.BuiltinExchangeType;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Producer {    public static final String EXCHANGE_NAME=&quot;exchange_topics&quot;;    public static void main(String[] args) throws IOException, TimeoutException {        //获取连接        Connection connection= RabbitMQUtil.getConnection();        //通过连接打开通道        Channel channel=connection.createChannel();        //topic：根据具体的模式匹配串进行key匹配操作        //在通道上声明交换机        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);        String updateMsg=&quot;订单更新&quot;;        channel.basicPublish(EXCHANGE_NAME, &quot;update.order&quot;, null, updateMsg.getBytes(&quot;utf-8&quot;));        String saveUserMsg=&quot;添加用户&quot;;        channel.basicPublish(EXCHANGE_NAME, &quot;save.user.register&quot;, null, saveUserMsg.getBytes(&quot;utf-8&quot;));        String queryOrderMsg=&quot;订单查询&quot;;        channel.basicPublish(EXCHANGE_NAME, &quot;query.order.by.userid&quot;, null, queryOrderMsg.getBytes(&quot;utf-8&quot;));        //关闭资源        channel.close();        connection.close();    }}</code></pre><h4 id="2、Consumer——消息消费者代码实现-4"><a href="#2、Consumer——消息消费者代码实现-4" class="headerlink" title="2、Consumer——消息消费者代码实现"></a>2、Consumer——消息消费者代码实现</h4><p>对于只针对查询队列的消费方:</p><pre><code>package com.carleviets.publish_subscribe.topics;import com.carleviets.utils.RabbitMQUtil;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class QueryConsumer {    public static final String EXCHANGE_NAME=&quot;exchange_topics&quot;;    public static final String QUEUE_NAME=&quot;query&quot;;    public static void main(String[] args) throws IOException, TimeoutException {        //获取连接        Connection connection= RabbitMQUtil.getConnection();        //通过连接打开通道        Channel channel=connection.createChannel();        //在通道上声明交换机和队列        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);        channel.queueDeclare(QUEUE_NAME, false, false, false, null);        //将队列绑定到交换机:添加绑定key,key可以绑定多个        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;query.#&quot;);        //创建消费者对象        Consumer consumer=new DefaultConsumer(channel){            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {                String msg=new String(body, &quot;utf-8&quot;);                System.out.println(&quot;查询消费方收到消息--&gt;&quot;+msg);            }        };        //将queue队列加入到监听        channel.basicConsume(QUEUE_NAME, true, consumer);    }}</code></pre><p>添加或更新的消费方：</p><pre><code>package com.carleviets.publish_subscribe.topics;import com.carleviets.utils.RabbitMQUtil;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class SaveOrUpdateConsumer {    public static final String EXCHANGE_NAME=&quot;exchange_topics&quot;;    public static final String QUEUE_NAME=&quot;saveOrUpdate&quot;;    public static void main(String[] args) throws IOException, TimeoutException {        //获得连接        Connection connection= RabbitMQUtil.getConnection();        //通过连接打开通道        Channel channel=connection.createChannel();        //在通道上声明交换机和队列        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);        channel.queueDeclare(QUEUE_NAME, false, false, false,null);        //将队列绑定到交换机：添加绑定key,key可以绑定多个        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;update.*&quot;);        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;save.*.*&quot;);        //创建消费者对象        Consumer consumer=new DefaultConsumer(channel){            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {                String msg=new String(body, &quot;utf-8&quot;);                System.out.println(&quot;添加或更新消费方收到消息--&gt;&quot;+msg);            }        };        //将queue队列加入到监听        channel.basicConsume(QUEUE_NAME, true, consumer);    }}</code></pre><h2 id="六、RPC-模式"><a href="#六、RPC-模式" class="headerlink" title="六、RPC 模式"></a>六、RPC 模式</h2><p>RabbitMQ 也支持 RPC 同步调用，其具体调用过程如下:</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fzlfovni2hj30ru0983zt.jpg" alt=""></p><p>RabbitMQ 中实现 RPC 的机制是：</p><ul><li><p>客户端发送请求（消息）时，在消息的属性（MessageProperties，在 AMQP 协议中定义了 14 种 properties，这些属性会随着消息一起发送）中设置 replyTo（一个Queue 名称，用于告诉服务器处理完成后将通知我的消息发送到这个 Queue 中）和 correlationId（此次请求的标识号，服务器处理完成后需要将此属性返还，客户端将根据这个 id 了解哪条请求被成功执行了或执行失败）这两个值。</p></li><li><p>服务器端收到消息并处理。</p></li><li><p>服务器端处理完消息后，将生成一条应答消息到 replyTo 指定的 Queue，同时带上 correlationId 属性。</p></li></ul><p>客户端之前已订阅 replyTo 指定的 Queue，从中收到服务器的应答消息后，根据其中的correlationId 属性分析哪条请求被执行了，根据执行结果进行后续业务处理。<strong>注意，这里不存在Producer和Consumer的概念，这里的客户端和服务器端既是服务的提供者，又是服务的消费者。</strong></p><h4 id="1、Client客户端的实现"><a href="#1、Client客户端的实现" class="headerlink" title="1、Client客户端的实现"></a>1、Client客户端的实现</h4><p>客户端的实现代码如下:</p><pre><code>package com.carleviets.rpc;import com.carleviets.utils.RabbitMQUtil;import com.rabbitmq.client.*;import java.io.IOException;import java.util.UUID;public class RpcClient {    private final static String QUEUE_NAME = &quot;rpc_queue&quot;;    private final static String REPLY_QUEUE = &quot;reply_queue&quot;;    public static void main(String[] args) throws Exception {        // 创建连接        Connection connection = RabbitMQUtil.getConnection();        // 创建通道并定义队列        Channel channel = connection.createChannel();        channel.queueDeclare(QUEUE_NAME, false, false, false, null);        //使用UUID来计算消息特有的correctionId，以保证其值唯一        final String correlationId = UUID.randomUUID().toString();        //构造BasicProperties对象        AMQP.BasicProperties replyProps = new AMQP.BasicProperties                .Builder().replyTo(REPLY_QUEUE)                .correlationId(correlationId)                .build();        // 向队列发送消息        channel.basicPublish(&quot;&quot;, QUEUE_NAME, replyProps, &quot;6&quot;.getBytes());        System.out.println(&quot;发送成功！&quot;);        // 接受服务器返回结果        channel.queueDeclare(REPLY_QUEUE, false, false, false, null);        // 定义消费者        Consumer consumer = new DefaultConsumer(channel) {            @Override            public void handleDelivery(String consumerTag, Envelope envelope,                                       com.rabbitmq.client.AMQP.BasicProperties properties, byte[] body) throws IOException {                String corrId = properties.getCorrelationId();                if (correlationId.equals(corrId)) {                    System.out.println(&quot;获取服务器的返回结果：&quot; + new String(body, &quot;utf-8&quot;));                }            }        };        //将队列加入到监听并指定consumer对象        channel.basicConsume(REPLY_QUEUE, true, consumer);    }}</code></pre><h4 id="2、Server服务器端的实现"><a href="#2、Server服务器端的实现" class="headerlink" title="2、Server服务器端的实现"></a>2、Server服务器端的实现</h4><p>服务器端的具体实现代码如下:</p><pre><code>package com.carleviets.rpc;import com.carleviets.utils.RabbitMQUtil;import com.rabbitmq.client.*;import java.io.IOException;import com.rabbitmq.client.AMQP.BasicProperties;public class RpcServer {    private final static String QUEUE_NAME = &quot;rpc_queue&quot;;    public static void main(String[] args) throws Exception {        // 创建连接        Connection connection = RabbitMQUtil.getConnection();        // 创建通道并定义队列        final Channel channel = connection.createChannel();        channel.queueDeclare(QUEUE_NAME, false, false, false, null);        // 定义消费者        Consumer consumer = new DefaultConsumer(channel) {            @Override            public void handleDelivery(String consumerTag, Envelope envelope,                                       BasicProperties properties, byte[] body)                    throws IOException {                String num = new String(body, &quot;utf-8&quot;);                System.out.println(&quot;接受的消息是：&quot; + num);                // 获取计算结果                int result = fib(Integer.parseInt(num));                System.out.println(&quot;计算算的结果:&quot; + result);                // 獲取返回結果的隊列                String replyToQueueName = properties.getReplyTo();                // 声明replyToQueueName                channel.queueDeclare(replyToQueueName, false, false, false, null);                // 发送消息到replyToQueueName 队列                channel.basicPublish(&quot;&quot;, replyToQueueName, properties, (result + &quot;&quot;).getBytes());            }        };        // 執行消費方法        channel.basicConsume(QUEUE_NAME, true, consumer);    }    private static int fib(int n) {        if (n == 0) return 0;        if (n == 1) return 1;        return fib(n-1) + fib(n-2);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> AMQP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级消息队列(二)——RabbitMq 快速入门与基本概念介绍</title>
      <link href="/2019/01/27/%E9%AB%98%E7%BA%A7%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94RabbitMq%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/01/27/%E9%AB%98%E7%BA%A7%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94RabbitMq%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="一、-RabbitMq-HelloWorld入门程序"><a href="#一、-RabbitMq-HelloWorld入门程序" class="headerlink" title="一、 RabbitMq HelloWorld入门程序"></a>一、 RabbitMq HelloWorld入门程序</h2><p>我们先来编写一个简单的消息队列的HelloWorld程序，再来解释相关的一些概念。</p><h4 id="1、引入pom依赖"><a href="#1、引入pom依赖" class="headerlink" title="1、引入pom依赖"></a>1、引入pom依赖</h4><p>要想在java中操作MQ，除了安装RabbitMQ服务端之外，我们还需要引入RabbitMQ客户端依赖：</p><pre><code>&lt;!-- rabbitmq客户端依赖 --&gt;&lt;dependency&gt;  &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;  &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;  &lt;version&gt;4.9.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="2、Produer-消息生产者"><a href="#2、Produer-消息生产者" class="headerlink" title="2、Produer 消息生产者"></a>2、Produer 消息生产者</h4><pre><code>package com.carleviets.hello;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Producer {    public static final String QUEUE_NAME=&quot;hello&quot;;    public static void main(String[] args) throws IOException, TimeoutException {        //实例化连接工厂        ConnectionFactory connectionFactory=new ConnectionFactory();        connectionFactory.setHost(&quot;localhost&quot;);        connectionFactory.setPort(5672);        connectionFactory.setVirtualHost(&quot;/test&quot;);        connectionFactory.setUsername(&quot;carleviets&quot;);        connectionFactory.setPassword(&quot;123456&quot;);        //通过连接工厂获取连接        Connection connection=connectionFactory.newConnection();        //在连接上创建通道        Channel channel=connection.createChannel();        /**          *在通道上声明一个 Queue          *   第一个参数queue:队列的名称          *   第二个参数 durable：是否持久化          *   第三个参数 Exclusive：排他队列，如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，          *   并在连接断开时自动删除。这里需要注意三点：          *   其一，排他队列是基于连接可见的，同一连接的不同通道是可以同时访问同一个连接创建的排他队列的。          *   其二， “首次” ，如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同。          *   其三，即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除的。          *   这种队列适用于只限于一个客户端发送读取消息的应用场景。          *   第四个参数： Auto-delete:自动删除，如果该队列没有任何订阅的消费者的话，该队列会被自动删除。这种队列适用于临时队列。          */        channel.queueDeclare(QUEUE_NAME, false, false, false, null);        String msg=&quot;Hello World&quot;;        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, msg.getBytes(&quot;utf-8&quot;));        System.out.println(&quot;消息发送成功!&quot;);        //关闭通道        channel.close();        //关闭连接        connection.close();    }}</code></pre><h4 id="3、Consumer-消息消费者"><a href="#3、Consumer-消息消费者" class="headerlink" title="3、Consumer 消息消费者"></a>3、Consumer 消息消费者</h4><pre><code>package com.carleviets.hello;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Receiver {    public static final String QUEUE_NAME=&quot;hello&quot;;    public static void main(String[] args) throws IOException, TimeoutException {        //实例化连接工厂        ConnectionFactory connectionFactory=new ConnectionFactory();        connectionFactory.setHost(&quot;localhost&quot;);        connectionFactory.setPort(5672);        connectionFactory.setVirtualHost(&quot;/test&quot;);        connectionFactory.setUsername(&quot;carleviets&quot;);        connectionFactory.setPassword(&quot;123456&quot;);        //通过连接工厂获取到连接        Connection connection=connectionFactory.newConnection();        //通过连接创建通道        Channel channel=connection.createChannel();        /**          *在通道上指定 Queue          *   第一个参数queue:队列的名称          *   第二个参数 durable：是否持久化          *   第三个参数 Exclusive：排他队列，如果一个队列被声明为排他队列，该队列仅对首次声明它的连接可见，          *   并在连接断开时自动删除。这里需要注意三点：          *   其一，排他队列是基于连接可见的，同一连接的不同通道是可以同时访问同一个连接创建的排他队列的。          *   其二， “首次” ，如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同。          *   其三，即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除的。          *   这种队列适用于只限于一个客户端发送读取消息的应用场景。          *   第四个参数： Auto-delete:自动删除，如果该队列没有任何订阅的消费者的话，该队列会被自动删除。这种队列适用于临时队列。          */        channel.queueDeclare(QUEUE_NAME, false, false, false, null);        //创建一个消费者        Consumer consumer=new DefaultConsumer(channel){            @Override            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {                String msg=new String(body, &quot;utf-8&quot;);                System.out.println(&quot;消费方收到消息——&gt;&quot;+msg);            }        };        //监听队列，如果队列中有消息就调用消费者进行处理        channel.basicConsume(QUEUE_NAME, true, consumer);    }}</code></pre><p>这样，我们就完成了一个简单的实现消息发送的RabbitMQ应用程序。</p><h2 id="二、RabbitMQ-客户端基本概念解释"><a href="#二、RabbitMQ-客户端基本概念解释" class="headerlink" title="二、RabbitMQ 客户端基本概念解释"></a>二、RabbitMQ 客户端基本概念解释</h2><h3 id="1、ConnectionFactory、-Connection-和-Channel"><a href="#1、ConnectionFactory、-Connection-和-Channel" class="headerlink" title="1、ConnectionFactory、 Connection 和 Channel"></a>1、ConnectionFactory、 Connection 和 Channel</h3><p>Connection 是 RabbitMQ 的 socket 连接，它封装了 socket 协议相关部分逻辑。 ConnectionFactory 为 Connection 的制造工厂。 Channel 是我们与 RabbitMQ 打交道的最重要的一个接口，我们大部分的业务操作是在 Channel这个接口中完成的，包括定义 Queue、定义 Exchange、绑定 Queue 与 Exchange、<br>发布消息等。</p><h3 id="2、Queue（队列）"><a href="#2、Queue（队列）" class="headerlink" title="2、Queue（队列）"></a>2、Queue（队列）</h3><p>Queue（队列）是 RabbitMQ 的内部对象，用于存储消息。</p><p>RabbitMQ 中的消息都只能存储在 Queue 中，生产者（下图中的 P）生产消息并最终投递到 Queue 中，消费者（下图中的 C）可以从 Queue 中获取消息并消费。</p><p><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1fzl73yr43hj30l904uwep.jpg" alt=""></p><p>多个消费者可以订阅同一个 Queue，这时 Queue 中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</p><p><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1fzl75sst85j30hu06i3yw.jpg" alt=""></p><h3 id="3、-Message-acknowledgment（消息回执）"><a href="#3、-Message-acknowledgment（消息回执）" class="headerlink" title="3、 Message acknowledgment（消息回执）"></a>3、 Message acknowledgment（消息回执）</h3><p>在实际应用中，可能会发生消费者收到 Queue 中的消息，但没有处理完成就宕机（或出现其他意外）的情况，这种情况下就可能会导致消息丢失。为了避免这种情况的发生，我们可以要求消费者在消费完消息后发送一个回执给 RabbitMQ，RabbitMQ 收到消息回执（Message acknowledgment）后才将该消息从 Queue 中移除；如果 RabbitMQ 没有收到回执并检测到消费者的 RabbitMQ 连接断开，则RabbitMQ 会将该消息发送给其他消费者（如果存在多个消费者）进行处理。这里不存在 timeout 概念，一个消费者处理消息时间再长也不会导致该消息被发送给其他消费者，除非它的 RabbitMQ 连接断开。这里会产生另外一个问题，如果我们的开发人员在处理完业务逻辑后，忘记发送回执给 RabbitMQ，这将会导致严重的 bug——Queue 中堆积的消息会越来越多；消费者重启后会重复消费这些消息并重复执行业务逻辑…</p><h3 id="4、Message-durability（消息的持久化）"><a href="#4、Message-durability（消息的持久化）" class="headerlink" title="4、Message durability（消息的持久化）"></a>4、Message durability（消息的持久化）</h3><p>如果我们希望即使在 RabbitMQ 服务重启的情况下，也不会丢失消息，我们可以将 Queue 与 Message 都设置为可持久化的（durable），这样可以保证绝大部分情况下我们的 RabbitMQ 消息不会丢失。但依然解决不了小概率丢失事件的发生（比如 RabbitMQ 服务器已经接收到生产者的消息，但还没来得及持久化该消息时 RabbitMQ 服务器就断电了），如果我们需要对这种小概率事件也要管理起来，那么我们要用到事务。</p><h3 id="5、Prefetch-count"><a href="#5、Prefetch-count" class="headerlink" title="5、Prefetch count"></a>5、Prefetch count</h3><p>前面我们讲到如果有多个消费者同时订阅同一个 Queue 中的消息， Queue 中的消息会被平摊给多个消费者。这时如果每个消息的处理时间不同，就有可能会致某些消费者一直在忙，而另外一些消费者很快就处理完手头工作并一直空闲的情况。我们可以通过设置 prefetchCount 来限制 Queue 每次发送给每个消费者的消息数，比如我们设置 prefetchCount=1，则 Queue 每次给每个消费者发送一条消息；消费者处理完这条消息后 Queue 会再给该消费者发送一条消息。</p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fzl7f73spwj30nt076my4.jpg" alt=""></p><h3 id="6、Exchange（交换机）"><a href="#6、Exchange（交换机）" class="headerlink" title="6、Exchange（交换机）"></a>6、Exchange（交换机）</h3><p>通过以上我们看到生产者将消息投递到 Queue 中，实际上这在 RabbitMQ 中这种事情永远都不会发生。实际的情况是，生产者将消息发送到 Exchange（交换器，下图中的 X），由 Exchange 将消息路由到一个或多个 Queue 中（或者丢弃）。</p><p>Exchange 是按照什么逻辑将消息路由到 Queue 的？这个将在 Binding 介绍。RabbitMQ 中的 Exchange 有四种类型，不同的类型有着不同的路由策略，这将在Exchange Types 介绍。</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fzl7l4d08bj30in06v0sz.jpg" alt=""></p><h3 id="7、Routing-Key（路由键）"><a href="#7、Routing-Key（路由键）" class="headerlink" title="7、Routing Key（路由键）"></a>7、Routing Key（路由键）</h3><p>生产者在将消息发送给 Exchange 的时候，一般会指定一个 routing key，来指定这个消息的路由规则，而这个 routing key 需要与 Exchange Type 及 binding key 联合使用才能最终生效。在 Exchange Type 与 binding key 固定的情况下（在正常使用时一般这些内容都是固定配置好的），我们的生产者就可以在发送消息给 Exchange 时，通过指定 routing key 来决定消息流向哪里。RabbitMQ 为 routing key 设定的长度限制为 255 bytes。</p><h3 id="8、Binding"><a href="#8、Binding" class="headerlink" title="8、Binding"></a>8、Binding</h3><p>RabbitMQ 中通过 Binding 将 Exchange 与 Queue 关联起来，这样 RabbitMQ 就知道如何正确地将消息路由到指定的 Queue 了。</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fzl8m0gq0vj30gw05eaad.jpg" alt=""></p><h3 id="9、Binding-key"><a href="#9、Binding-key" class="headerlink" title="9、Binding key"></a>9、Binding key</h3><p>在绑定（Binding）Exchange 与 Queue 的同时，一般会指定一个 binding key；生产者将消息发送给 Exchange 时，一般会指定一个 routing key；当 binding key 与 routing key 相匹配时，消息将会被路由到对应的 Queue 中。</p><p>在绑定多个 Queue 到同一个 Exchange 的时候，这些 Binding 允许使用相同的 binding key。 binding key 并不是在所有情况下都生效，它依赖于 Exchange Type，比如 fanout 类型的 Exchange 就会无视 binding key，而是将消息路由到所有绑定到该 Exchange 的 Queue。</p><h3 id="10、Exchange-Types"><a href="#10、Exchange-Types" class="headerlink" title="10、Exchange Types"></a>10、Exchange Types</h3><p>RabbitMQ 常用的 Exchange Type 有 fanout、 direct、 topic、 headers 这四种（AMQP 规范里还提到两种 Exchange Type，分别为 system 与自定义）。</p><ul><li><strong>fanout</strong></li></ul><p>fanout 会把消息路由到所有与该交换机绑定的队列中。下图中，生产者（P）发送到 Exchange（X）的所有消息都会路由到图中的两个 Queue，并最终被两个消费者（C1 与 C2）消费。</p><p><img src="http://wx4.sinaimg.cn/mw690/0060lm7Tly1fzl8wiaplhj30il089t9b.jpg" alt=""></p><ul><li><strong>direct</strong></li></ul><p>direct 类型会把消息路由到那些 binding key 与 routing key 完全匹配的 Queue 中。</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fzl906j4gpj30nm08pgmo.jpg" alt=""></p><ul><li><strong>topic</strong></li></ul><p>topic 类型与 direct 类型的 Exchage相似，也是将消息路由到 binding key 与 routing key 相匹配的 Queue 中，但这里的匹配规则有些不同，它约定：</p><ul><li><p>routing key 为一个句点号“. ” 分隔的字符串（我们将被句点号“. ” 分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse” 、 “nyse.vmw” 、 “quick.orange.rabbit”。</p></li><li><p>binding key 与 routing key 一样也是句点号“. ” 分隔的字符串。</p></li><li><p>binding key 中可以存在两种特殊字符“<em>” 与“#” ，用于做模糊匹配，其中“</em>” 用于匹配一个单词， “#” 用于匹配多个单词（可以是零个）。</p></li></ul><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fzl98k22u5j30mw094jsb.jpg" alt=""></p><ul><li><strong>headers</strong></li></ul><p>headers 类型的 Exchange 不依赖于 routing key 与 binding key 的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定 Queue<br>与 Exchange 时指定一组键值对；当消息发送到 Exchange 时， RabbitMQ 会取到该消息的 headers（也是一个键值对的形式），对比其中的键值对是否完全匹配<br>Queue 与 Exchange 绑定时指定的键值对；如果完全匹配则消息会路由到该 Queue，否则不会路由到该 Queue。该类型的 Exchange 目前用的不多。</p><ul><li><strong>RPC</strong></li></ul><p>MQ 本身是基于异步的消息处理，前面的示例中所有的生产者（P）将消息发送到 RabbitMQ 后不会知道消费者（C）处理成功或者失败（甚至连有没有消费者来处理这条消息都不知道）。但实际的应用场景中，我们很可能需要一些同步处理，需要同步等待服务端将我的消息处理完成后再进行下一步处理。这相当于RPC（Remote Procedure Call，远程过程调用）。在 RabbitMQ 中也支持 RPC。</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fzl9ct5rgkj30rr09zdh5.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> AMQP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级消息队列(一)——消息队列的介绍与RabbitMQ的安装</title>
      <link href="/2019/01/27/%E9%AB%98%E7%BA%A7%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BB%8B%E7%BB%8D%E4%B8%8ERabbit%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/01/27/%E9%AB%98%E7%BA%A7%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BB%8B%E7%BB%8D%E4%B8%8ERabbit%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="一、MQ简介"><a href="#一、MQ简介" class="headerlink" title="一、MQ简介"></a>一、MQ简介</h2><p>在计算机科学中，消息队列（Message queue）是<strong>一种进程间通信</strong>或<strong>同一进程的不同线程间</strong>的通信方式， 软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了 <strong>异步的通信协议</strong> ，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列互交。消息会保存在队列中，直到接收者取回它。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>消息队列常常保存在链表结构中。拥有权限的进程可以向消息队列中写入或读取消息。</p><p>目前，有很多消息队列有很多开源的实现，包括 JBoss Messaging、 JORAM、Apache ActiveMQ、 Sun Open Message Queue、 RabbitMQ、 IBM MQ、 Apache Qpid 和 HTTPSQS等。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息，而不需要等待回应。但消息队列的异步特点，也造成了一个缺点，就是接收者必须轮询消息队列，才能收到最近的消息。</p><p>和信号相比，消息队列能够传递更多的信息。与管道相比，消息队列提供了有格式的数据。但消息队列仍然有大小限制。</p><p>当前国内市面上拥有的 MQ 系列 RabbitMq、 ActiveMq、 ZeroMq、 kafka，为什么要选用 RabbitMq 呢？</p><pre><code>性能好支持高并发，基于 erlang 语言持持久化消息：就是 MQ 挂了或者服务器挂了，重新连接后消息不会丢失与 kafka 比较， kafka 解决的日志处理，并不是消息处理</code></pre><h4 id="MQ-特点"><a href="#MQ-特点" class="headerlink" title="MQ 特点"></a>MQ 特点</h4><p>MQ 是生产者-消费者模型的一个典型的代表，一端往消息队列中不断写入消息，而另一端则可以读取或者订阅队列中的消息。 MQ 和 JMS 类似，但不同的是 JMS是 SUN JAVA 消息中间件服务的一个标准和 API 定义，而 MQ 则是遵循了 AMQP 协议的具体实现和产品。</p><p><strong>注意</strong>：</p><ol><li><p>AMQP，即 Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。</p></li><li><p>JMS， Java 消息服务（Java Message Service）应用程序接口，是一个Java 平台中关于面向消息中间件的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 Java 消息服务是一个与具体平台无关的 API，绝大多数 MOM 提供商都对 JMS 提供支持。</p></li></ol><p><strong>使用场景</strong></p><p>在项目中，将一些无需即时返回且耗时的操作提取出来，进行了异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。</p><h2 id="二、-RabbitMQ的安装"><a href="#二、-RabbitMQ的安装" class="headerlink" title="二、 RabbitMQ的安装"></a>二、 RabbitMQ的安装</h2><h4 id="Erlang-环境准备"><a href="#Erlang-环境准备" class="headerlink" title="Erlang 环境准备"></a>Erlang 环境准备</h4><p>RabbitMQ 依赖于 Erlang,需要先安装 Erlang。Erlang的下载地址： <a href="http://www.erlang.org/downloads" target="_blank" rel="noopener">http://www.erlang.org/downloads</a></p><h4 id="安装-RabbitMQ"><a href="#安装-RabbitMQ" class="headerlink" title="安装 RabbitMQ"></a>安装 RabbitMQ</h4><p>Rabbit MQ的下载地址:<a href="http://www.rabbitmq.com/download.html。" target="_blank" rel="noopener">http://www.rabbitmq.com/download.html。</a></p><p>安装好后，打开命令行命令行,进入 RabbitMQ 的安装目录: cd rabbitmq_server-3.6.5\sbin，输入 rabbitmqctl.bat status , 如果出现以下的图，说明安装是成功的，并且说明现在RabbitMQ Server 已经启动了,运行正常。</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fzkazfeseaj30ia0agaai.jpg" alt=""></p><p>如果没有出现的话在执行：</p><ol><li><p>rabbitmqservice.bat install </p></li><li><p>2.rabbitmqservice.bat start，如果是关闭的话就是rabbitmqservice.bat stop，如果还不行的话需要同步一个.erlang.cookie 的文件, 将系统 Windows 下的.erlang.cookie 文件拷贝到你的用户目录下。</p></li></ol><h4 id="管理界面基本操作"><a href="#管理界面基本操作" class="headerlink" title="管理界面基本操作"></a>管理界面基本操作</h4><p>1、打开命令行,进入 RabbitMQ 的安装目录: cd rabbitmq_server-3.6.5\sbin</p><p>2、输入&gt;rabbitmq-plugins.bat list 显示如下</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fzkbjn0585j30r20jun05.jpg" alt=""></p><p>3、输入 rabbitmq-plugins.bat enable rabbitmq_management</p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fzkblneuzej30vf09a0ts.jpg" alt=""></p><p>4、浏览器输入： 127.0.0.1:15672即可进入RabbitMQ登录页面</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fzkbn41e7ij30bx05sq2s.jpg" alt=""></p><p>这样，RabbitMQ就安装完成了，用户就可以通过guest账号进行登录了。</p>]]></content>
      
      
      <categories>
          
          <category> AMQP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo实现分布式服务</title>
      <link href="/2019/01/26/Dubbo%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/01/26/Dubbo%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、单体应用与SOA应用"><a href="#一、单体应用与SOA应用" class="headerlink" title="一、单体应用与SOA应用"></a>一、单体应用与SOA应用</h2><h4 id="1、单体应用"><a href="#1、单体应用" class="headerlink" title="1、单体应用"></a>1、单体应用</h4><p>一个归档包（可以是JAR、WAR、EAR或其它归档格式）包含所有功能的应用程序，通常称为单体应用。单体应用的特点如下:</p><ol><li><p>代码比较集中（前端+后端）</p><pre><code> 后端:dao，service,controller（war）&lt;br/&gt; 前端:html，css,js,images</code></pre></li><li><p>应用独立部署-部署比较简单,应用上线打包（通常为一个war）    </p></li><li><p>版本迭代时，应用技术复杂度越来越高，维护成本加大</p></li><li><p>异常全局性（一个异常可能会导致服务器不可用）</p></li><li><p>代码重复性较大（service服务不可拆分）</p></li></ol><h4 id="2、SOA-面向服务-接口-开发"><a href="#2、SOA-面向服务-接口-开发" class="headerlink" title="2、SOA:面向服务(接口)开发"></a>2、SOA:面向服务(接口)开发</h4><p>面向服务的架构（SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）进行拆分，并通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。SOA应用程序的特点如下:</p><ol><li><p>代码分散(多个应用组件)</p></li><li><p>项目部署在多台机器上(分布式部署-分布式项目)</p></li><li><p>服务被拆分到不同应用</p></li><li><p>服务与服务之间调用跨机器(远程调用)</p></li></ol><h2 id="二、RPC基本概念"><a href="#二、RPC基本概念" class="headerlink" title="二、RPC基本概念"></a>二、RPC基本概念</h2><h4 id="1、RPC协议-Remote-Procedure-Call-Protocol"><a href="#1、RPC协议-Remote-Procedure-Call-Protocol" class="headerlink" title="1、RPC协议(Remote Procedure Call Protocol)"></a>1、RPC协议(Remote Procedure Call Protocol)</h4><p><strong>跨越应用层与传输层，实现机器与机器之间的远程通信协议。开发者不需要关注底层实现细节，只需要关注服务的实现与服务调用。</strong></p><p>RPC 协议假定某些传输协议的存在，如 TCP 或 UDP，为通信程序之间携带信息数据。在OSI七层网络通信模型中， RPC 跨越了传输层和应用层。 RPC 使得开发包括网络分布式程序在内的应用程序更加容易。</p><p>RPC 采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行</p><h4 id="2、RPC框架"><a href="#2、RPC框架" class="headerlink" title="2、RPC框架"></a>2、RPC框架</h4><p>在同一台电脑上不同进程间、或在不同机器之间进行远程通信的框架。如:Java RMI(底层tcp)、Dubbo(仅支持java)、grpc、thrift等。</p><h4 id="3、RPC与HTTP、TCP、UDP、Socket-的区别"><a href="#3、RPC与HTTP、TCP、UDP、Socket-的区别" class="headerlink" title="3、RPC与HTTP、TCP、UDP、Socket 的区别"></a>3、RPC与HTTP、TCP、UDP、Socket 的区别</h4><p>TCP/UDP: 都是传输协议，主要区别是 tcp 协议连接需要 3 次握手，断开需要四次挥手，是通过流来传输的，就是确定连接后，一直发送信息，传完后断开。 udp 不需要进行连接，直接把信息封装成多个报文，直接发送。所以 udp 的速度更快写，但是不保证数据的完整性。</p><p>Http：超文本传输协议是一种应用层协议，建立在 TCP 协议之上。</p><p>Socket： 是在应用程序层面上对 TCP/IP 协议的封装和应用。其实是一个调用接口，方便程序员使用 TCP/IP 协议栈而已。程序员通过 socket 来使用 tcp/ip 协议。但是 socket 并不是一定要使用 tcp/ip 协议，Socket 编程接口在设计的时候，就希望也能适应其他的网络协议。</p><p><strong>小结</strong>：我们把网络传输类比于一条公路，那 TCP/UDP 就是货车， HTTP 就是货物， 而 socket就是发动机。</p><p>RPC 是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。所以 RPC 的实现可以通过不同的协议去实现比如可以使用http、 RMI 等。</p><h4 id="4、RPC-的运行流程"><a href="#4、RPC-的运行流程" class="headerlink" title="4、RPC 的运行流程"></a>4、RPC 的运行流程</h4><p>首先，要解决<strong>通讯的问题</strong>，主要是通过在客户端和服务器之间建立<strong>TCP连接</strong>，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。</p><p>第二，要解决<strong>寻址的问题</strong>，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么，这样才能完成调用。比如基于Web服务协议栈的RPC，就要提供一个endpointURI，或者是从UDDI(一种目录服务，通过该目录服务进行服务注册与搜索)服务上查找。如果是 RMI 调用的话，还需要一个 RMI Registry 来注册服务的地址。这通过<strong>本地存根</strong>来实现。</p><p>第三，当A服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议，如TCP传递到B服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是<strong>序列化</strong>（Serialize）或编组（marshal），通过寻址和传输将序列化的二进制发送给B服务器。</p><p>第四，B服务器收到请求后，需要对参数进行<strong>反序列化</strong>（序列化的逆操作），恢复为内存中的表达方式，然后找到对应的方法（寻址的一部分）进行本地调用，然后得到返回值。</p><p>第五，返回值还要发送回服务器A上的应用，也要经过序列化的方式发送，服务器A接到后，再反序列化，恢复为内存中的表达方式，交给 A 服务器上的应用。</p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fzdenhbn7pj30u50ifgyl.jpg" alt=""></p><p>JAVAEE里面的stub是为屏蔽客户调用远程主机上的对象，必须提供某种方式来模拟本地对象,这种本地对象称为存根(stub),存根负责接收本地方法调用,并将它们委派给各自的具体实现对象。</p><h4 id="5、RPC基于RMI的简单实现"><a href="#5、RPC基于RMI的简单实现" class="headerlink" title="5、RPC基于RMI的简单实现"></a>5、RPC基于RMI的简单实现</h4><p>参见博客<strong>rmi远程方法调用</strong>部分。</p><h2 id="三、Dubbo——面向服务的分布式RPC远程调用框架"><a href="#三、Dubbo——面向服务的分布式RPC远程调用框架" class="headerlink" title="三、Dubbo——面向服务的分布式RPC远程调用框架"></a>三、Dubbo——面向服务的分布式RPC远程调用框架</h2><h4 id="1、Dubbo流程图说明"><a href="#1、Dubbo流程图说明" class="headerlink" title="1、Dubbo流程图说明"></a>1、Dubbo流程图说明</h4><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fzddfwn0uzj30es0bkt8x.jpg" alt=""></p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fzddi75wdpj30my0gc3z5.jpg" alt=""></p><p>Dubbo 提供三个核心功能： 基于接口的远程调用、 容错和负载均衡， 以及服务的自动注册与发现。</p><h4 id="2、关于Dubbo所采用的协议"><a href="#2、关于Dubbo所采用的协议" class="headerlink" title="2、关于Dubbo所采用的协议"></a>2、关于Dubbo所采用的协议</h4><ul><li><p>dubbo://</p><p>  Dubbo 缺省协议采用<strong>单一长连接</strong> 和 <strong>NIO 异步通讯</strong>，适合于 <strong>小数据量大并发</strong> 的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。 具体详情请参照官网:<a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html</a></p></li></ul><p>其他具体的协议类型如rmi、hessian、http、thrift、redis等请参照官网。</p><h4 id="3、关于注册中心"><a href="#3、关于注册中心" class="headerlink" title="3、关于注册中心"></a>3、关于注册中心</h4><ul><li><p><strong>Multicast 注册中心</strong></p><p>  Multicast 注册中心不需要启动任何中心节点，只要广播地址一样，就可以互相发现。</p><p>  <img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fzdfsz1jwaj30j308zta5.jpg" alt=""></p><p>  Multicast注册中心的配置如下:</p><pre><code>  &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot; /&gt;</code></pre><p>  或:</p><pre><code>  &lt;dubbo:registry protocol=&quot;multicast&quot; address=&quot;224.5.6.7:1234&quot; /&gt;</code></pre></li><li><p><strong>zookeeper 注册中心</strong></p><p>  Zookeeper 是 Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。</p><p>  <img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fzdfx02qlbj30kc0iatbq.jpg" alt=""></p><p>  zookeeper注册中心的使用，需要在 provider 和 consumer 中引入zookeeper坐标依赖和zookeeper客户端坐标依赖：</p><pre><code>  &lt;!--zookeeper坐标依赖--&gt;  &lt;dependency&gt;      &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;      &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;      &lt;version&gt;3.3.3&lt;/version&gt;  &lt;/dependency&gt;  &lt;!--zookeeper客户端zkClient依赖--&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;      &lt;artifactId&gt;zkclient&lt;/artifactId&gt;      &lt;version&gt;0.1&lt;/version&gt;  &lt;/dependency&gt;</code></pre><p>  zookeeper的安装：</p><pre><code>  wget http://archive.apache.org/dist/zookeeper/zookeeper-3.3.3/zookeeper-3.3.3.tar.gz  tar zxvf zookeeper-3.3.3.tar.gz  cd zookeeper-3.3.3      cp conf/zoo_sample.cfg conf/zoo.cfg    </code></pre><p>  zookeeper的配置：</p><p>  如果不需要集群，zoo.cfg的配置如下:</p><pre><code>  tickTime=2000  initLimit=10  syncLimit=5  dataDir=/home/dubbo/zookeeper-3.3.3/data    //存放节点数据目录  dataLogDir=/home/software/zk_3.4.13/log        //存放运行日志目录  clientPort=2181</code></pre></li></ul><p>这里只需要关注dataDir和dataLogDir这两个属性，其中dataDir配置的是存放节点数据的目录，dataLogDir配置的是存放运行日志的目录，其他的配置都是zookeeper默认的。</p><pre><code>启动：    ./bin/zkServer.sh startzookeeper的具体安装详情参见: http://dubbo.apache.org/zh-cn/docs/admin/install/zookeeper.html</code></pre><ul><li><p><strong>Redis 注册中心</strong></p><p>  Redis注册中心的具体详情请参见官网:<a href="http://dubbo.apache.org/zh-cn/docs/user/references/registry/redis.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/references/registry/redis.html</a></p></li><li><p><strong>Simple 注册中心</strong></p><p>  Simple注册中心的具体详情请参见官网:<a href="http://dubbo.apache.org/zh-cn/docs/user/references/registry/simple.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/references/registry/simple.html</a></p></li></ul><h2 id="四、Dubbo服务发布的简单实现"><a href="#四、Dubbo服务发布的简单实现" class="headerlink" title="四、Dubbo服务发布的简单实现"></a>四、Dubbo服务发布的简单实现</h2><p>新建一个maven多模块工程，父模块为dubbo_par，在父模块中定义dubbo_api(服务接口的定义)、dubbo_provider(服务实现的提供)、dubbo_consumer(服务的具体消费方)，其中，dubbo_provider模块和dubbo_consumer模块都依赖于dubbo_api模块。</p><h4 id="1、pom坐标依赖"><a href="#1、pom坐标依赖" class="headerlink" title="1、pom坐标依赖"></a>1、pom坐标依赖</h4><pre><code>&lt;!-- dubbo依赖坐标 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;dubbo&lt;/artifactId&gt;    &lt;version&gt;2.5.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--zookeeper依赖坐标--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;    &lt;version&gt;3.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--zookeeper客户端坐标依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;    &lt;artifactId&gt;zkclient&lt;/artifactId&gt;    &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>由于provider和consumer都依赖于dubbo和zookeeper，故把pom依赖坐标放在父模块的pom文件中。</p><h4 id="2、api中服务接口的定义"><a href="#2、api中服务接口的定义" class="headerlink" title="2、api中服务接口的定义"></a>2、api中服务接口的定义</h4><p>由于服务的生产者和消费者都会依赖这个接口， 因此强烈建议把这个接口定义在一个独立的模块， 然后由生产者模块和消费者模块各自依赖即可：</p><pre><code>package com.carleviets.api.service;import com.carleviets.api.po.User;public interface IUserService {    User queryUserById(Integer userId);}</code></pre><h4 id="3、provider中的具体配置"><a href="#3、provider中的具体配置" class="headerlink" title="3、provider中的具体配置"></a>3、provider中的具体配置</h4><h5 id="3-1-服务的具体实现"><a href="#3-1-服务的具体实现" class="headerlink" title="3.1 服务的具体实现"></a>3.1 服务的具体实现</h5><pre><code>package com.carleviets.provicer.service;import com.carleviets.api.po.User;import com.carleviets.api.service.IUserService;import org.springframework.beans.factory.annotation.Autowired;public class UserServiceImpl implements IUserService {    @Autowired    private UserDao userDao;    @Override    public User queryUserById(Integer userId) {        return userDao.queryUserById(userId);    }}</code></pre><h5 id="3-2-provider-中-spring-xml-的具体配置-配置生产者"><a href="#3-2-provider-中-spring-xml-的具体配置-配置生产者" class="headerlink" title="3.2 provider 中 spring.xml 的具体配置(配置生产者)"></a>3.2 provider 中 spring.xml 的具体配置(配置生产者)</h5><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://code.alibabatech.com/schema/dubbo       http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;    &lt;bean id=&quot;userServiceImpl&quot; class=&quot;com.carleviets.provicer.service.UserServiceImpl&quot;/&gt;    &lt;!--配置dubbo应用名称--&gt;    &lt;dubbo:application name=&quot;dubbo_provider&quot;/&gt;    &lt;!--配置dubbo注册中心--&gt;    &lt;!--&lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot;/&gt;--&gt;    &lt;dubbo:registry address=&quot;zookeeper://192.168.107.220:2181&quot;/&gt;    &lt;!--配置dubbo采用的协议和端口--&gt;    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt;    &lt;!--配置服务提供方在dubbo注册中心所提供的服务--&gt;    &lt;dubbo:service interface=&quot;com.carleviets.api.service.IUserService&quot; ref=&quot;userServiceImpl&quot;/&gt;&lt;/beans&gt;</code></pre><h5 id="3-3-服务的发布"><a href="#3-3-服务的发布" class="headerlink" title="3.3 服务的发布"></a>3.3 服务的发布</h5><p>dubbo服务的发布只需要启动spring容器即可，这里我们为了进行测试，编写了一个测试类,具体如下:</p><pre><code>package com.carleviets;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.io.IOException;public class Publisher {    public static void main(String[] args) throws IOException {        ClassPathXmlApplicationContext applicationContext =                new ClassPathXmlApplicationContext(&quot;provider.xml&quot;);        applicationContext.start();        System.in.read();   // press any key to exit    }}</code></pre><h4 id="4、consumer中的具体配置"><a href="#4、consumer中的具体配置" class="headerlink" title="4、consumer中的具体配置"></a>4、consumer中的具体配置</h4><h5 id="4-1-Consumer类的具体实现"><a href="#4-1-Consumer类的具体实现" class="headerlink" title="4.1 Consumer类的具体实现"></a>4.1 Consumer类的具体实现</h5><pre><code>package com.carleviets.consumer.controller;import com.carleviets.api.po.User;import com.carleviets.api.service.IUserService;public class UserController {    private IUserService userService;    public void setUserService(IUserService userService) {        this.userService = userService;    }    public User queryUserById(Integer userId){        return userService.queryUserById(userId);    }}</code></pre><h5 id="4-2-provider-中-spring-xml-的具体配置（配置消费者）"><a href="#4-2-provider-中-spring-xml-的具体配置（配置消费者）" class="headerlink" title="4.2 provider 中 spring.xml 的具体配置（配置消费者）"></a>4.2 provider 中 spring.xml 的具体配置（配置消费者）</h5><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://code.alibabatech.com/schema/dubbo       http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;    &lt;!--配置dubbo应用名称--&gt;    &lt;dubbo:application name=&quot;dubbo_consumer&quot;/&gt;    &lt;!--配置dubbo注册中心--&gt;    &lt;!--&lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot;/&gt;--&gt;    &lt;dubbo:registry address=&quot;zookeeper://192.168.107.220:2181&quot;/&gt;    &lt;!--配置服务消费方在注册中心订阅的服务--&gt;    &lt;dubbo:reference interface=&quot;com.carleviets.api.service.IUserService&quot; id=&quot;userService&quot;/&gt;    &lt;bean id=&quot;userController&quot; class=&quot;com.carleviets.consumer.controller.UserController&quot;&gt;        &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h5 id="4-3-服务的消费"><a href="#4-3-服务的消费" class="headerlink" title="4.3 服务的消费"></a>4.3 服务的消费</h5><p>服务消费的具体测试代码如下:</p><pre><code>package com.carleviets;import com.carleviets.consumer.controller.UserController;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class ConsumerTest {    public static void main(String[] args) {        ApplicationContext applicationContext=                new ClassPathXmlApplicationContext(&quot;consumer.xml&quot;);        UserController userController = (UserController) applicationContext.getBean(&quot;userController&quot;);        while (true){            System.out.println(userController.queryUserById(1));        }    }}</code></pre><p>这样，我们就完成了一个简单的使用zookeeper作为注册中心的dubbo服务发布和消费的demo。</p><p>五、Dubbo常用标签的解释说明</p><ul><li><p><strong>dubbo:application</strong></p><p>  配置应用名称 &nbsp;&nbsp; 用于服务提供方和服务消费方 &nbsp;&nbsp; name=”应用名称”</p></li><li><p><strong>dubbo:registry</strong></p><p>  注册中心 &nbsp;&nbsp; 用于服务提供方和服务消费方 &nbsp;&nbsp; address=”” (广播|zookeeper(推荐))</p></li><li><p><strong>dubbo:protocol</strong></p><p>  配置服务注册协议 &nbsp;&nbsp; name=”dubbo”(推荐使用dubbo)&nbsp;port=”20880” &nbsp;&nbsp; 用于服务提供方</p></li><li><p><strong>dubbo:service</strong></p><p>  注册的服务信息配置 &nbsp;&nbsp; 用于服务提供方 &nbsp;&nbsp; interface=”服务名”(接口全路径-包名.接口)&nbsp;ref=”实现类id标识” &nbsp;&nbsp; 可以配置多个</p></li><li><p><strong>dubbo:reference</strong></p><p>  配置订阅的服务信息 &nbsp;&nbsp; 用于服务消费方 &nbsp;&nbsp;interface=”服务名”(接口全路径-包名.接口) &nbsp; id=”bean的唯一标识” &nbsp;&nbsp; 可以配置多个</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis总结</title>
      <link href="/2019/01/20/Redis%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/20/Redis%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关系型数据库和非关系型数据库的对比"><a href="#一、关系型数据库和非关系型数据库的对比" class="headerlink" title="一、关系型数据库和非关系型数据库的对比"></a>一、关系型数据库和非关系型数据库的对比</h2><h4 id="1、关系型数据库"><a href="#1、关系型数据库" class="headerlink" title="1、关系型数据库"></a>1、关系型数据库</h4><ul><li>表与表之间存在约束关系(即所谓的范式)</li><li>表设计</li><li>SQL编写 </li><li>当表数据量很大，进行查询时，效率比较低（多表关联） </li><li>存在IO开销问题</li></ul><h4 id="2、非关系型数据库"><a href="#2、非关系型数据库" class="headerlink" title="2、非关系型数据库"></a>2、非关系型数据库</h4><p>非关系型数据库，基于key-value形式对数据进行存储，优先基于内存（内存+磁盘），类似的产品（Redis、MemcachedMongoDB-基于文档存储..）。关系库能够存储的数据，在非关系库中都能实现。</p><p>特点:</p><ul><li>不存在表概念</li><li>不需要编写SQL</li><li>访问数据效率更高（优先基于内存）</li><li>支持持久化</li><li>Redis支持分布式存储（高可用-HA）</li></ul><h2 id="二、Redis介绍"><a href="#二、Redis介绍" class="headerlink" title="二、Redis介绍"></a>二、Redis介绍</h2><p>Redis是一个<strong>内存中的</strong>数据结构存储系统，它可以用作<strong>数据库、缓存和消息中间件</strong>。它支持多种类型的数据结构，如<strong>字符串（strings）、散列（hashes）、列表（lists)、集合（sets）、有序集合（sorted sets）</strong>与范围查询，bitmaps，hyperloglogs和地理空（geospatial）索引半径查询。 Redis内置了复制（replication），LUA脚本（Lua scripting），LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的磁盘持久化（persistence，并通过 Redis哨兵（Sentinel）和自动分区（Cluster）供高可用性（high availability）。从这段简介中我们应该掌握一下几点：</p><pre><code>1. Redis 是把数据存放在内存当中，所以它的运行速度会非常快2. Redis 具有多种数据存储结构3. Redis 具有持久化的功能4. Redis 上的数据可以设置过期5. Redis 支持集群，而且可以自动切换6. 跨平台 支持多种语言客户端</code></pre><h2 id="三、CentOS环境下Redis的安装"><a href="#三、CentOS环境下Redis的安装" class="headerlink" title="三、CentOS环境下Redis的安装"></a>三、CentOS环境下Redis的安装</h2><p>(1) 执行下面的命令执行下载并解压:</p><pre><code>wget http://download.redis.io/releases/redis-3.2.8.tar.gztar -zxvf redis-3.2.8.tar.gz</code></pre><p>(2) 如果centos没有gcc环境, 需要先安装gcc</p><pre><code>yum install gcc</code></pre><p>(3) 进入解压后的目录，通过make命令执行编译</p><pre><code>cd redis-3.2.8make</code></pre><h2 id="四、Redis的运行"><a href="#四、Redis的运行" class="headerlink" title="四、Redis的运行"></a>四、Redis的运行</h2><h4 id="1、配置文件说明"><a href="#1、配置文件说明" class="headerlink" title="1、配置文件说明"></a>1、配置文件说明</h4><pre><code>redis.conf                     redis服务器启动基本配置文件sentinel.conf                 redis哨兵配置文件redis-server                 启动服务器脚本redis-cli                     连接redis服务器脚本redis-sentinel                 redis哨兵服务器启动脚本</code></pre><h4 id="2、Redis的运行"><a href="#2、Redis的运行" class="headerlink" title="2、Redis的运行"></a>2、Redis的运行</h4><p>(1) redis-server启动方式一</p><p>进入redis-3.2.8目录下，执行以下命令:</p><pre><code>src/redis-server</code></pre><p>但是通过这种方式启动Redis之后当前窗口无法再继续其他操作，不推荐。</p><p>(2) redis-server启动方式二</p><p>修改redis.conf配置文件中daemonize默认属性no修改为yes，如下:</p><pre><code>daemonize yes</code></pre><p>保存并退出后执行以下命令指定配置文件启动服务器:</p><pre><code>src/redis-server ./redis.conf</code></pre><p>注意vi非编辑模式下可以通过    “/+待查找文本” 来执行查找，通过”:noh”来取消选中标记。</p><p>(3) 通过redis.conf文件中的requirepass password配置密码，如下将服务器的密码设置为123456：</p><pre><code>requirepass 123456</code></pre><p>(4)Redis客户端的启动</p><pre><code>src/redis-cli -p port -a password</code></pre><p>通过执行redis-cli并指定所连接的端口号和密码来启动客户端。</p><h2 id="五、Redis通用命令介绍"><a href="#五、Redis通用命令介绍" class="headerlink" title="五、Redis通用命令介绍"></a>五、Redis通用命令介绍</h2><pre><code>exists key                         检测指定key是否存在，返回1表示存在，0不存在del key1 key2 ...... keyN         删除给定 key,返回删除key的数目，0表示给定key都不存在type key                         返回给定key值的类型。返回none表示key不存在,string——字符类型，list——链表类型，set——无序集合类型......keys pattern                     返回匹配指定模式的所有keyrandomkey                           返回从当前数据库中随机选择的一个key,如果当前数据库是空的，返回空串rename oldkey newkey             重命名一个key,如果newkey存在，将会被覆盖，返回1表示成功，0失败。返回0时可能是oldkey不存在或者和newkey 相同。renamenx oldkey newkey             同上，但是如果newkey存在返回失败。expire key seconds                 为key指定过期时间，单位是秒。返回1成功，0表示key已经设置过过期时间或者不存在。ttl key                             返回设置过过期时间key的剩余过期秒数。-1表示key不存在或者未设置过期时间。select db-index                 通过索引选择数据库，默认连接的数据库是0,默认数据库数是16个。返回1表示成功，0失败。move key db-index                 将key从当前数据库移动到指定数据库。返回1表示成功。0表示key不存在或者已经在指定数据库中</code></pre><h2 id="六、五种基本数据类型"><a href="#六、五种基本数据类型" class="headerlink" title="六、五种基本数据类型"></a>六、五种基本数据类型</h2><h4 id="1、string类型基本命令"><a href="#1、string类型基本命令" class="headerlink" title="1、string类型基本命令"></a>1、string类型基本命令</h4><p>string是最基本的类型，而且string类型是二进制安全的。意思是redis的string可以包含任何数据。比如 jpg 图片或者序列化的对象。从内部实现来看其实string可以看作byte组，最大上限是 1G 字节。string类型的基本命令如下:</p><pre><code>set key value                                 设置key对应string类型的值，返回1表示成功，0表示失败。setnx key value                             如果key不存在，设置key对应string类型的值。如果key已经存在，返回0。get key                                     获取key对应的string值,如果key不存在返回nilgetset key value                             先获取key的值，再设置key的值。如果key不存在返回 nil。mget key1 key2 ......keyN                     一次获取多个key的值，如果对应key不存在，则对应返回nil。mset key1 value1 ......keyN valueN             一次设置多个key的值，成功返回1，表示所有的值都设置了，失败返回0表示没有任何值被设置。msetnx key1 value1 ......keyN valueN         一次设置多个 key 的值，但是不会覆盖已经存在的keyincr key                                     对key的值做++操作，并返回新的值。注意incr一个不是int的value会返回错误，incr一个不存在的key，                                            则设置key值为1。decr key                                     对key的值做--操作，decr一个不存在的key，则设置key值为-1。incrby key integer                             对key加上指定值，key不存在时候会设置key，并认为原来的value是0。decrby key integer                             对key减去指定值。decrby完全是为了可读性，我们完全可以通过incrby一个负值来实现同样效果，反之一样。</code></pre><h4 id="2、Hash类型基本命令"><a href="#2、Hash类型基本命令" class="headerlink" title="2、Hash类型基本命令"></a>2、Hash类型基本命令</h4><pre><code>hset key field value                             设置 hash field 为指定值，如果 key 不存在，则创建hget key field                                     获取指定的 hash field。hmget key filed1....fieldN                         获取全部指定的 hash filed。hmset key filed1 value1 ......filedN valueN     同时设置 hash 的多个 field。hincrby key field integer                         将指定的hash filed加上指定值。成功返回hash filed变更后的值。hexists key field                                 检测指定 field 是否存在。hdel key field                                     删除指定的hash field。hlen key                                         返回指定 hash 的 field 数量hkeys key                                         返回 hash 的所有 field。hvals key                                         返回 hash 的所有 value。hgetall key                                     返回 hash 的所有 filed 和 value。</code></pre><p>内部实现方式:Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，当Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject 的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap。</p><h4 id="3、List类型基本命令"><a href="#3、List类型基本命令" class="headerlink" title="3、List类型基本命令"></a>3、List类型基本命令</h4><pre><code>lpush key string                                 在key对应list的头部添加字符串元素，返回1表示成功，0表示key存在且不是list类型。rpush key string                                 在key对应list的尾部添加字符串元素。llen key                                         返回key对应list的长度，如果key不存在返回0，如果key对应类型不是list返回错误。lrange key start end                             返回指定区间内的元素，下标从0开始，负值表示从后面计算，-1表示倒数第一个元素 ，key不存在返回空列表。ltrim key start end                             截取list指定区间内元素，成功返回 1，key不存在返回错误。lset key indexvalue                             设置list中指定下标的元素值，成功返回 1，key或者下标不存在返回错误。lrem key count value                             从List的头部（count 正数）或尾部（count 负数）删除一定数量（count）匹配value的元素，返回删除的元素数量。count为0时候删除全部。lpop key                                         从list的头部删除并返回删除元素。如果key对应list不存在或者是空返回nil，如果key对应值不是 list 返回错误。rpop key                                         从list的尾部删除并返回删除元素。blpop key1 ......keyN timeout                     从左到右扫描，返回对第一个非空list进行lpop 操作并返回，比如 blpop list1 list2 list3 0 ,如果list不存在                                                   list2,list3 都是非空则对 list2 做 lpop 并返回从 list2 中删除的元素。如果所有的list都是空或不存在，则                                                会阻塞timeout秒，timeout为0表示一直阻塞。当阻塞时，如果有client对key1...keyN中的任意key进行push操作，则                                                第一在这个key上被阻塞的client会立即返回。如果超时发生，则返回nil。有点像unix的select或者poll。brpop                                             同blpop，一个是从头部删除一个是从尾部删除</code></pre><p>Lists的另一个应用就是队列,可以利用Lists的PUSH操作，将任务存在List中，然后工作线程再用POP操作将任务取出进行执行。</p><p>内部实现方式：Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis 内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。</p><h4 id="4、Set类型基本命令"><a href="#4、Set类型基本命令" class="headerlink" title="4、Set类型基本命令"></a>4、Set类型基本命令</h4><p>是无序集合，最大可以包含(2的32次方-1)个元素。set的是通过hashtable实现的，所以添加，删除，查找的复杂度都是 O(1)。hash table会随着添加或者删除自动的调整大小。需要注意的是调整hashtable大小时候需要同步（获取写锁）会阻塞其他读写操作。关于 set 集合类型除了基本的添加删除操作，其它有用的操作还包含集合的取并集(union)，交集(intersection)，差集(difference)。通过这些操作可以很容易的实现SNS中的好友推荐和blog的tag功能。set集合的基本命令如下:</p><pre><code>sadd key member                         添加一个string元素到key对应set集合中，成功返回1,如果元素以及在集合中则返回0，                                        key对应的set不存在则返回错误。srem key member                         从key对应set中移除指定元素，成功返回1，如果member在集合中不存在或者key不存在返回0，                                        如果key对应的不是set类型的值返回错误。spop key                                 删除并返回key对应set中随机的一个元素,如果set是空或者key不存在返回nil。srandmember key                         同spop，随机取set中的一个元素，但是不删除元素。smove srckey dstkey member                 从srckey对应set中移除member并添加到dstkey对应set中，整个操作是原子的。                                        成功返回1,如果member在srckey中不存在返回0，如果key不是set类型返回错误。Scard key                                 返回set的元素个数，如果set是空或者key不存在返回0。sismember key member                     判断member是否在set中，存在返回1，0表示不存在或者key不存在。sinter key1 key2 …… keyN                 返回所有给定key的交集。sinterstore dstkey key1 ....... keyN     返回所有给定key的交集，并保存交集存到dstkey下。sunion key1 key2 ...... keyN             返回所有给定key的并集。sunionstore dstkey key1 ......keyN         返回所有给定key的并集，并保存并集到dstkey下。sdiff key1 key2 ......keyN                 返回所有给定key的差集。sdiffstore dstkey key1 ......keyN         返回所有给定key的差集，并保存差集到dstkey下。smembers key                             返回key对应set的所有元素，结果是无序的。</code></pre><p>set的内部实现是一个value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。</p><h4 id="5、Sorted-Set类型基本命令"><a href="#5、Sorted-Set类型基本命令" class="headerlink" title="5、Sorted Set类型基本命令"></a>5、Sorted Set类型基本命令</h4><p>Sorted Set是有序集合，它在set的基础上增加了一个顺序属性，这一属性在添加修改元素的时候可以指定，每次指定后，会自动重新按新的值调整顺序。可以理解了有两列的mysql表，一列存 value，一列存顺序。操作中 key 理解为sorted set的名字，最多包含2^(32-1)个元素。Sorted Set集合的基本，命令如下:</p><pre><code>zadd key score member                     添加元素到集合，元素在集合中存在则更新对应score。zrem key member                         删除指定元素，1表示成功，如果元素不存在返回0。zincrby key incrmember                     增加对应member的score，然后移动元素并保持skip list保持有序。返回更新后的 score 值。zrank key member                         返回指定元素在集合中的排名（下标），集合中元素是按score从小到大排序的。zrevrankkey member                         同上,但是集合中元素是按 score 从大到小排序。zrange key start end                     类似lrange操作从集合中去指定区间的元素。返回的是有序结果zrevrange key start end                 同上，返回结果是按score逆序的。zrangebyscore key min max                 返回集合中score在给定区间的元素。zcount key min max                         返回集合中score在给定区间的数量。zcard key                                 返回集合中元素个数。zscore key element                         返回给定元素对应的 score</code></pre><h2 id="四、集群环境下Redis实现主备切换和读写分离"><a href="#四、集群环境下Redis实现主备切换和读写分离" class="headerlink" title="四、集群环境下Redis实现主备切换和读写分离"></a>四、集群环境下Redis实现主备切换和读写分离</h2><p>Redis支持主从复用。数据可以从主服务器向任意数量的从服务器上同步，同步使用的是发布/订阅机制。Mater Slave的模式，从Slave向Master发起 SYNC 命令。可以是1 Master 多 Slave，也可以分层，Slave 下可以再接Slave，可扩展成树状结构。这里使用单机来模拟redis主从服务器 ，实现读写分离配置。具体实现步骤如下：</p><h4 id="1、Redis实现读写分离"><a href="#1、Redis实现读写分离" class="headerlink" title="1、Redis实现读写分离"></a>1、Redis实现读写分离</h4><p>(1) Redis节点准备</p><p>在home目录新建ha文件夹并拷贝三份 redis 服务器文件到该目录下，分别更名为redis-6379，redis-6380和redis-6381，其中redis-6379作为主服务器，redis-6380和redis-6381作为从服务器。通过以下命令执行复制:</p><pre><code>cp -r 源目录 目标目录</code></pre><p>(2) 修改主服务器的配置</p><p>进入redis-6379目录，以vi编辑模式进入redis.conf文件，修改slave-read-only属性的值修改为yes,requirepass属性指定具体的密码:</p><pre><code>slave-read-only yes 从服务器默认是只读的不允许输入requirepass 123456    指定主服务器的访问密码</code></pre><p>(3) 修改从服务器的配置</p><p>分别进入redis-6380和redis-6381目录，以vi编辑模式进入redis.conf文件，需要修改的配置如下:</p><pre><code>port 6380    指定从服务器的端口requirepass 123456    指定该从服务器的访问密码slaveof &lt;masterip&gt; &lt;masterport&gt;        指定该从服务器所隶属的主服务器的ip和端口masterauth 指定该从服务器的主服务器密码</code></pre><p>slave of 后填写主服务器的ip和主服务器的端口。</p><p>以上两处修改完毕后，查看服务器的具体信息,命令如下:</p><pre><code>info replication</code></pre><h4 id="2、Redis实现主备切换"><a href="#2、Redis实现主备切换" class="headerlink" title="2、Redis实现主备切换"></a>2、Redis实现主备切换</h4><p>(1) Redis节点准备</p><p>Redis服务器三台：</p><pre><code>redis-6379(master)redis-6380(slave)redis-6381(slave)</code></pre><p>Sentinel 哨兵服务器三台:</p><pre><code>redis-26379redis-26380redis-26381</code></pre><p>(2)主从节点redis.conf配置</p><p>主节点配置:</p><pre><code>设置端口(port),daemonize,密码(requirepass)，主节点密码(masterauth),禁用 bind 等基本配置。</code></pre><p><strong>注意</strong>，这里必须加入<strong>masterauth</strong>属性，因为如果主节点宕机后，再重新加入集群是作为从服务器的，需要主节点的访问密码。</p><p>从节点配置:</p><pre><code>设置端口(port),requirepass,daemonize,主节点密码(masterauth),禁用 bind ,slaveof 属性设置等。</code></pre><p>(3)sentinel.conf 哨兵文件配置</p><p>初始化启动配置:</p><ul><li>默认监听 6379 端口</li><li>设置连接服务器密码属性: sentinel auth-pass mymaster</li><li>设置同意选举成功的票数为 2 台(通常为:至少为半数票数通过)</li></ul><p>具体说明如下:</p><pre><code>##redis## 哨兵监听进程端口号设置port 26379#master# 指示 Sentinel 去监视一个名为 master 的主服务器， 这个主服务器的 IP 地址为# 127.0.0.1 ， 端口号为 6379 ， 而将这个主服务器判断为失效至少需要 1 个# Sentinel 同意 （只要同意 Sentinel 的数量不达标，自动故障迁移就不会执行）。sentinel monitor master 192.168.132.8 6379 2# Sentinel 认为服务器已经断线所需的毫秒数sentinel down-after-milliseconds master 5000#若 sentinel 在该配置值内未能完成 failover 操作（即故障时 master/slave 自动切换），则认为本次 failover 失败。sentinel failover-timeout master 900000</code></pre><p>(4)测试主备切换</p><ul><li>服务器启动顺序:先启动redis服务器，后启动哨兵服务器</li><li>关闭主服务器，查看哨兵日志信息-&gt;找到新的主节点 添加redis 数据</li></ul><h2 id="五、Redis-持久化"><a href="#五、Redis-持久化" class="headerlink" title="五、Redis 持久化"></a>五、Redis 持久化</h2><p>对于 Redis,其提供了不同级别的持久化操作:</p><ul><li><p>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照。</p></li><li><p>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。</p></li><li><p>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时,它会优先使用 AOF 文件来还原数据集,因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</p></li><li><p>持久化功能当然也可以进行关闭操作，让数据仅在服务器运行时存在</p></li></ul><h4 id="1、RDB持久化操作（快照-SnapShot-方式）"><a href="#1、RDB持久化操作（快照-SnapShot-方式）" class="headerlink" title="1、RDB持久化操作（快照 SnapShot 方式）"></a>1、RDB持久化操作（快照 SnapShot 方式）</h4><p>默认情况下，Redis将数据库快照保存在名字为 dump.rdb 的二进制文件中。当然， 这里可以通过修改 redis.conf 配置文件来对数据存储条件进行定义，规定在“ N 秒内数据集至少有 M 个改动”这一条件被满足时,自动保存一次数据集。 也可以通过调用save 或 bgsave ,手动让 Redis 进行数据集保存操作。</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fzd6umpa2aj30hl0azjrx.jpg" alt=""></p><p><strong>Save | Bgsave 手动方式即时保存数据</strong></p><p>通过 save 操作 ，当前 io 操作被阻塞，当 save 保存执行完毕才会进行后续 io 操作。而bgsave 操作在背后开启一个新的进程来对数据进行快照处理。保存后的快照存放在 dump.rdb 文件中，快照RDB文件的名称和具体位置在redis.conf如下:</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fzd6zuidurj30fv05uwem.jpg" alt=""></p><p><strong>快照运行方式</strong></p><p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作：</p><ul><li>Redis调用 fork()，同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中。</li><li>当子进程完成对新RDB文件的写入时，Redis用新RDB文件替换原来的RDB文件，并删除旧的RDB文件。</li></ul><p><strong>RDB 优缺点</strong></p><p>优点:</p><ul><li><p>RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 该文件适合用于进行备份 。 比如说，可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。</p></li><li><p>RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心。</p></li><li><p>RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。</p></li><li><p>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p></li></ul><p>缺点：</p><ul><li><p>如果想要做到数据实时备份级别，此时使用 rdb 快照进行备份可能会出现数据无法备份完整情况，比如在数据备份完毕下次备份操作发起前，服务器由于某种原因意外宕机，此时采用 rdb 就无法对当前情况做的实时响应处理。</p></li><li><p>RDB 需要经常 fork 子进程来保存数据集到硬盘上,当数据集比较大的时候,fork 的过程是非常耗时的,可能会导致 Redis 在一些毫秒级内不能响应客户端的请求.如果数据集巨大并且 CPU 性能不是很好的情况下,这种情况会持续 1 秒,AOF 也需要 fork,但是你可以调节重写日志文件的频率来提高数据集的耐久度。</p></li></ul><h4 id="2、AOF只追加操作的文件"><a href="#2、AOF只追加操作的文件" class="headerlink" title="2、AOF只追加操作的文件"></a>2、AOF只追加操作的文件</h4><p> AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， AOF文件的体积也会变得越来越大。但是，AOF可以在不打断服务客户端的情况下，对 AOF 文件进行重建（rebuild）。 Redis 2.4 则可以自动触发 AOF 重写。AOF 重写文件配置:</p><pre><code>############################## APPEND ONLY MODE################################ 是否开启 AOF，默认关闭（no）appendonly yes# 指定 AOF 文件名appendfilename appendonly.aof# Redis 支持三种不同的刷写模式：# appendfsync always #每次收到写命令就立即强制写入磁盘，是最有保证的完全的持久化，但速度也是最慢的，一般不推荐使用。appendfsync everysec #每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，是受推荐的方式。# appendfsync no #完全依赖 OS 的写入，一般为 30 秒左右一次，性能最好但是持久化最没有保证，不被推荐。#在日志重写时，不进行命令追加操作，而只是将其放在缓冲区里，避免与命令的追加造成DISK IO 上的冲突。#设置为 yes 表示 rewrite 期间对新写操作不 fsync,暂时存在内存中,等 rewrite 完成后再写入，默认为 nono-appendfsync-on-rewrite no#当前 AOF 文件大小是上次日志重写得到 AOF 文件大小的二倍时，自动启动新的日志重写过程。auto-aof-rewrite-percentage 100#当前 AOF 文件启动新的日志重写过程的最小值，避免刚刚启动 Reids 时由于文件尺寸较小导致频繁的重写。auto-aof-rewrite-min-size 64mb</code></pre><h2 id="六、使用-Jedis-客户端工具操作-redis"><a href="#六、使用-Jedis-客户端工具操作-redis" class="headerlink" title="六、使用 Jedis 客户端工具操作 redis"></a>六、使用 Jedis 客户端工具操作 redis</h2><h4 id="1、服务端环境准备"><a href="#1、服务端环境准备" class="headerlink" title="1、服务端环境准备"></a>1、服务端环境准备</h4><ul><li><p>添加访问认证</p><pre><code>  requirepass 123456        指定该从服务器的访问密码</code></pre></li><li><p>ip地址bind属性修改</p><p>  <img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fzd8fh6orrj30fg044jrf.jpg" alt=""></p></li></ul><p>将 bind 127.0.0.1 属性禁用（如果不禁用，仅限本机ip访问redis服务器）能够让外界客户端进行访问。</p><ul><li><p>关闭防火墙</p><pre><code>  service iptables stop</code></pre></li></ul><h4 id="2、pom依赖引入"><a href="#2、pom依赖引入" class="headerlink" title="2、pom依赖引入"></a>2、pom依赖引入</h4><pre><code>&lt;!--Jedis客户端依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;redis.clients&lt;/groupId&gt;  &lt;artifactId&gt;jedis&lt;/artifactId&gt;  &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="3、通过-junit-进行简单测试"><a href="#3、通过-junit-进行简单测试" class="headerlink" title="3、通过 junit 进行简单测试"></a>3、通过 junit 进行简单测试</h4><pre><code>package com.carleviets;import org.junit.Test;import redis.clients.jedis.Jedis;import java.util.HashMap;import java.util.Map;public class RedisTest {    @Test    public void test01(){        Jedis jedis=new Jedis(&quot;192.168.107.220&quot;, 6379);        jedis.auth(&quot;123456&quot;);   //设置连接密码        jedis.set(&quot;2019&quot;, &quot;hello redis!&quot;);        System.out.println(jedis.get(&quot;2019&quot;));        System.out.println(jedis.type(&quot;2019&quot;));    }}</code></pre><h4 id="4、Jedis客户端操作数据的RedisUtil工具类"><a href="#4、Jedis客户端操作数据的RedisUtil工具类" class="headerlink" title="4、Jedis客户端操作数据的RedisUtil工具类"></a>4、Jedis客户端操作数据的RedisUtil工具类</h4><p>以下是用连接池的思想实行封装的RedisUtil工具类:</p><pre><code>package com.carleviets.util;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import redis.clients.jedis.Jedis;public final class RedisUtil {    //Redis 服务器 IP    private static String ADDR = &quot;192.168.107.220&quot;;    //Redis 的端口号    private static int PORT = 6379;    //访问密码    private static String AUTH = &quot;123456&quot;;    //可用连接实例的最大数目，默认值为 8；    //如果赋值为-1，则表示不限制；如果 pool 已经分配了 maxActive 个 jedis 实例，则此时 pool 的状态为 exhausted(耗尽)。    private static int MAX_ACTIVE = 1024;    //控制一个 pool 最多有多少个状态为 idle(空闲的)的 jedis 实例，默认值也是 8。    private static int MAX_IDLE = 200;    //等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。    //如果超过等待时间，则直接抛出 JedisConnectionException；    private static int MAX_WAIT = 10000;    private static int TIMEOUT = 10000;    //在 borrow 一个 jedis 实例时，是否提前进行 validate 操作；    //如果为 true，则得到的 jedis 实例均是可用的；    private static boolean TEST_ON_BORROW = true;    private static JedisPool jedisPool = null;    /**     * 初始化 Redis 连接池     */    static {        try {            JedisPoolConfig config = new JedisPoolConfig();            config.setMaxTotal(MAX_ACTIVE);            config.setMaxIdle(MAX_IDLE);            config.setMaxWaitMillis(MAX_WAIT);            config.setTestOnBorrow(TEST_ON_BORROW);            jedisPool = new JedisPool(config, ADDR, PORT, TIMEOUT, AUTH);        } catch (Exception e) {            e.printStackTrace();        }    }    /**     * 获取 Jedis 实例     * @return     */    public synchronized static Jedis getJedis() {        try {            if (jedisPool != null) {                Jedis resource = jedisPool.getResource();                return resource;            } else {                return null;            }        } catch (Exception e) {            e.printStackTrace();            return null;        }    }    /**     * 释放 jedis 资源     * @param jedis     */    public static void returnResource(final Jedis jedis) {        if (jedis != null) {            //此处close()方法将连接还给连接池对象，并不是关闭jedis连接            jedisPool.close();        }    }}</code></pre><p>如果要想获取一个Redis连接的话，只需要调用RedisUtil.getJedis()方法即可。</p><h2 id="七、Spring-Data-Redis-操作-redis-服务器"><a href="#七、Spring-Data-Redis-操作-redis-服务器" class="headerlink" title="七、Spring-Data-Redis 操作 redis 服务器"></a>七、Spring-Data-Redis 操作 redis 服务器</h2><h4 id="1、pom坐标依赖"><a href="#1、pom坐标依赖" class="headerlink" title="1、pom坐标依赖"></a>1、pom坐标依赖</h4><pre><code>&lt;!-- spring-data-redis --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;  &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;  &lt;version&gt;1.8.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--jedis 客户端--&gt;&lt;dependency&gt;  &lt;groupId&gt;redis.clients&lt;/groupId&gt;  &lt;artifactId&gt;jedis&lt;/artifactId&gt;  &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="2、spring-xml具体配置"><a href="#2、spring-xml具体配置" class="headerlink" title="2、spring.xml具体配置"></a>2、spring.xml具体配置</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--jedis连接池配置--&gt;    &lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;        &lt;!--允许的最大连接数--&gt;        &lt;property name=&quot;maxTotal&quot; value=&quot;1024&quot;/&gt;        &lt;!--最大空闲连接数--&gt;        &lt;property name=&quot;maxIdle&quot; value=&quot;200&quot;/&gt;        &lt;!--获取连接时最大等待毫秒数--&gt;        &lt;property name=&quot;maxWaitMillis&quot; value=&quot;10000&quot;/&gt;        &lt;!--在获取连接时检查有效性--&gt;        &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置客户端连接工厂--&gt;    &lt;bean id=&quot;jedisConnectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;&gt;        &lt;property name=&quot;usePool&quot; value=&quot;true&quot;/&gt;        &lt;property name=&quot;hostName&quot; value=&quot;192.168.107.220&quot;/&gt;        &lt;property name=&quot;port&quot; value=&quot;6379&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;        &lt;constructor-arg name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置RedisTemplate模板--&gt;    &lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;        &lt;!--配置redis模板的连接工厂--&gt;        &lt;property name=&quot;connectionFactory&quot; ref=&quot;jedisConnectionFactory&quot;/&gt;        &lt;!--配置键序列化以及哈希键序列化方式--&gt;        &lt;property name=&quot;keySerializer&quot;&gt;            &lt;bean class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;/&gt;        &lt;/property&gt;        &lt;property name=&quot;hashKeySerializer&quot;&gt;            &lt;bean class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;/&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h4 id="3、测试代码"><a href="#3、测试代码" class="headerlink" title="3、测试代码"></a>3、测试代码</h4><pre><code>package com.carleviets;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = {&quot;classpath:spring.xml&quot;})public class SpringDataRedisTest {    @Resource    private RedisTemplate&lt;String, Object&gt; redisTemplate;    @Test    public void test01(){        ValueOperations&lt;String, Object&gt; valueOperations= redisTemplate.opsForValue();        valueOperations.set(&quot;spring_data_redis&quot;, &quot;redis is not easy!&quot;);        //System.out.println(valueOperations.get(&quot;spring_data_redis&quot;));    }}</code></pre><h2 id="八、Spring-Data-Redis环境下读写分离配置"><a href="#八、Spring-Data-Redis环境下读写分离配置" class="headerlink" title="八、Spring-Data-Redis环境下读写分离配置"></a>八、Spring-Data-Redis环境下读写分离配置</h2><h4 id="1、pom坐标依赖-1"><a href="#1、pom坐标依赖-1" class="headerlink" title="1、pom坐标依赖"></a>1、pom坐标依赖</h4><p>pom坐标依赖同上述单机环境下的坐标依赖。</p><h4 id="2、spring-xml具体配置（spring-sentinel-xml）"><a href="#2、spring-xml具体配置（spring-sentinel-xml）" class="headerlink" title="2、spring.xml具体配置（spring-sentinel.xml）"></a>2、spring.xml具体配置（spring-sentinel.xml）</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--Redis连接池配置--&gt;    &lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;        &lt;!--最大连接数--&gt;        &lt;property name=&quot;maxTotal&quot; value=&quot;1024&quot;/&gt;        &lt;!--最大空闲连接数--&gt;        &lt;property name=&quot;maxIdle&quot; value=&quot;200&quot;/&gt;        &lt;!--获取连接时最大等待毫秒数--&gt;        &lt;property name=&quot;maxWaitMillis&quot; value=&quot;10000&quot;/&gt;        &lt;!--在获取连接时检查有效性--&gt;        &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot;/&gt;    &lt;/bean&gt;    &lt;!--哨兵配置，注意哨兵节点只监视主节点--&gt;    &lt;bean id=&quot;redisSentinelConfiguration&quot; class=&quot;org.springframework.data.redis.connection.RedisSentinelConfiguration&quot;&gt;        &lt;property name=&quot;master&quot;&gt;            &lt;bean class=&quot;org.springframework.data.redis.connection.RedisNode&quot;&gt;                &lt;property name=&quot;name&quot; value=&quot;mymaster&quot;/&gt;            &lt;/bean&gt;        &lt;/property&gt;        &lt;property name=&quot;sentinels&quot;&gt;            &lt;set&gt;                &lt;bean class=&quot;org.springframework.data.redis.connection.RedisNode&quot;&gt;                    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.107.220&quot;/&gt;                    &lt;constructor-arg name=&quot;port&quot; value=&quot;26379&quot;/&gt;                &lt;/bean&gt;                &lt;bean class=&quot;org.springframework.data.redis.connection.RedisNode&quot;&gt;                    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.107.220&quot;/&gt;                    &lt;constructor-arg name=&quot;port&quot; value=&quot;26380&quot;/&gt;                &lt;/bean&gt;                &lt;bean class=&quot;org.springframework.data.redis.connection.RedisNode&quot;&gt;                    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.107.220&quot;/&gt;                    &lt;constructor-arg name=&quot;port&quot; value=&quot;26381&quot;/&gt;                &lt;/bean&gt;            &lt;/set&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!--Redis连接工厂配置--&gt;    &lt;bean id=&quot;jedisConnectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;&gt;        &lt;!--连接池的引用--&gt;        &lt;property name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot;/&gt;        &lt;!--哨兵配置的引用--&gt;        &lt;constructor-arg name=&quot;sentinelConfig&quot; ref=&quot;redisSentinelConfiguration&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置redis模板--&gt;    &lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;        &lt;!--配置连接工厂引用--&gt;        &lt;property name=&quot;connectionFactory&quot; ref=&quot;jedisConnectionFactory&quot;/&gt;        &lt;!--配置keySerializer和hashKeySerializer--&gt;        &lt;property name=&quot;keySerializer&quot;&gt;            &lt;bean class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;&gt;&lt;/bean&gt;        &lt;/property&gt;        &lt;property name=&quot;hashKeySerializer&quot;&gt;            &lt;bean class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;&gt;&lt;/bean&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p><strong>说明:</strong><br>Spring-data-redis 中是先将 key 与 value 进行序列化成变成 byte[] 字节数组进行传输，再调用对应的 redis的java客户端进行存储的。默认情况下，Redis采用JdkSerializationRedisSerializer，该序列化器序列化的是Object对象。而在一般情况下，对于 key 序列化采用字符串进行序列化，对于value序列化采用默认的JdkSerializationRedisSerializer。</p><h4 id="3、测试代码-1"><a href="#3、测试代码-1" class="headerlink" title="3、测试代码"></a>3、测试代码</h4><pre><code>package com.carleviets;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = {&quot;classpath:spring-sentinel.xml&quot;})public class SpringDataRedisTest2 {    @Resource    private RedisTemplate redisTemplate;    @Test    public void test(){        redisTemplate.opsForValue().set(&quot;spring_redis_sentinel&quot;, &quot;Hello, redis sentinel!&quot;);    }}</code></pre><h2 id="九、采用Spring-Data-Redis的RedisUtil实用工具类的简单封装"><a href="#九、采用Spring-Data-Redis的RedisUtil实用工具类的简单封装" class="headerlink" title="九、采用Spring-Data-Redis的RedisUtil实用工具类的简单封装"></a>九、采用Spring-Data-Redis的RedisUtil实用工具类的简单封装</h2><pre><code>package com.carleviets.util;import org.springframework.data.redis.core.HashOperations;import org.springframework.data.redis.core.ListOperations;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.stereotype.Component;import org.springframework.util.CollectionUtils;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit;/** * Redis操作数据的简单封装 */@Component@SuppressWarnings(&quot;all&quot;)public class RedisUtils {    private RedisTemplate&lt;String,Object&gt; redisTemplate;    private ValueOperations&lt;String, Object&gt; valueOperations;    private ListOperations&lt;String, Object&gt; listOperations;    private HashOperations&lt;String, String, Object&gt; hashOperations;    public RedisUtils(RedisTemplate&lt;String, Object&gt; redisTemplate) {        this.redisTemplate = redisTemplate;        valueOperations=this.redisTemplate.opsForValue();        listOperations=this.redisTemplate.opsForList();        hashOperations=this.redisTemplate.opsForHash();    }    public void setString(String key,Object value){        valueOperations.set(key, value);    }    public void setStringExpires(String key,Object value,Long time){        valueOperations.set(key, value, time, TimeUnit.MINUTES);    }    public Object getString(String key){        return valueOperations.get(key);    }    public void clearKeyByPattern(String pattern){        Set&lt;String&gt; keys= redisTemplate.keys(pattern);        if(!CollectionUtils.isEmpty(keys)){            redisTemplate.delete(keys);        }    }    public void delKey(String key){        if(redisTemplate.hasKey(key)){            redisTemplate.delete(key);        }    }    public void setList(String key,List list){        if(!CollectionUtils.isEmpty(list)){            for(Object t:list){                listOperations.rightPush(key, t);            }        }    }    public List&lt;Object&gt; getList(String key){        List&lt;Object&gt; list=null;        if(redisTemplate.hasKey(key)){            list=listOperations.range(key, 0, -1);        }        return list;    }    public void setHash(String key,String field,Object t){        hashOperations.put(key, field, t);    }    public void setHashAll(String key,Map&lt;String, Object&gt; map){        hashOperations.putAll(key, map);    }    public Object getHash(String key,String field){        return hashOperations.get(key, field);    }    public List&lt;Object&gt; getMultiHash(String key,List fields){        return hashOperations.multiGet(key, fields);    }    public Map getHashMap(String key){        return hashOperations.entries(key);    }}</code></pre><h2 id="十、热点问题"><a href="#十、热点问题" class="headerlink" title="十、热点问题"></a>十、热点问题</h2><h4 id="1、缓存穿透现象"><a href="#1、缓存穿透现象" class="headerlink" title="1、缓存穿透现象"></a>1、缓存穿透现象</h4><p>缓存系统，按照 KEY 去查询 VALUE,当 KEY 对应的 VALUE 一定不存在的时候并对 KEY 并发请求量很大的时候，就会造成缓存穿透情况!</p><p>缓存穿透场景:</p><ul><li><p>根据key查询对应value不存在时，到数据库中查询</p></li><li><p>当key对应value一定不存在，且查询并发量很大时，数据库压力增大!</p></li></ul><p>解决方案:</p><ul><li><p>对查询结果为空也进行缓存，并设置缓存过期时间</p></li><li><p>对不存在的 key 进行过滤操作——布隆过滤器</p></li></ul><p>业务代码中添加缓存时，并发量高的情况下下出现缓存穿透问题,这种情况下的解决方案:</p><ul><li>双重检查锁 类比单例模式下 双重检查锁实现</li></ul><h4 id="2、缓存雪崩现象"><a href="#2、缓存雪崩现象" class="headerlink" title="2、缓存雪崩现象"></a>2、缓存雪崩现象</h4><p>如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，就有可能造成存雪崩现象。</p><p>解决方案:</p><ul><li><p>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p></li><li><p>不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀</p></li><li><p>做二级缓存，或者双缓存策略。比如A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> jedis </tag>
            
            <tag> spring-data-redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令总结</title>
      <link href="/2019/01/19/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/19/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、git的三个分区"><a href="#一、git的三个分区" class="headerlink" title="一、git的三个分区"></a>一、git的三个分区</h2><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fzc630ca3uj30qp0b60ur.jpg" alt=""></p><ul><li><p>工作区（Working Directory）<br>是直接编辑的地方，肉眼可见，直接操作。</p></li><li><p>暂存区（Stage 或 Index）<br>数据暂时存放的区域。 </p></li><li><p>版本库（commit History）<br>存放已经提交的数据，push 的时候，就是把这个区的数据 push 到远程git仓库了。</p></li></ul><h2 id="二、git创建版本库"><a href="#二、git创建版本库" class="headerlink" title="二、git创建版本库"></a>二、git创建版本库</h2><pre><code>cd: 切换目录,比如 cd e: 切换到 e 盘mkdir: 创建一个文件夹pwd: 查看当前目录git init: 初始化一个本地库$ git config --global user.name &quot;name&quot;: 设置用户名$ git config --global user.email &quot;email@example.com&quot;: 设置邮箱</code></pre><h2 id="三、基本文件操作"><a href="#三、基本文件操作" class="headerlink" title="三、基本文件操作"></a>三、基本文件操作</h2><pre><code>git add: 添加文件到缓存区git commit: 提交文件到分支,-m 添加说明git status: 查看文件是否有修改git diff: 对比文件修改内容git log: 查看提交历史git reset --hard HEAD^: 回到上一个版本git reset --hard xxx: 回到指定版本,版本号可以不写全git reflog: 查看历史提交版本git rm: 删除版本库文件rm: 删除本地文件ls: 查看文件目录</code></pre><h2 id="四、创建远程版本库"><a href="#四、创建远程版本库" class="headerlink" title="四、创建远程版本库"></a>四、创建远程版本库</h2><pre><code>1. 创建 SSH Key      $ ssh-keygen -t rsa -C &quot;your email&quot;    在用户主目录里找到.ssh 目录， 里面有 id_rsa 和 id_rsa.pub2. 登陆 GitHub， 打开“Account settings”， “SSH Keys”页面。 点“Add SSH Key”，填上任意 Title，    在 Key 文本框里粘贴 id_rsa.pub 文件的内容。 点“Add Key”， 你就应该看到已经添加的 Key3. 验证是否成功    $ ssh -T git@github.com    如果出现:Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access,则表示成功!</code></pre><h2 id="五、添加远程库"><a href="#五、添加远程库" class="headerlink" title="五、添加远程库"></a>五、添加远程库</h2><pre><code>1. 登陆 GitHub， 在右上角找到“Create a new repo”按钮， 创建一个新的仓库。2. 在Repository name填入&quot;仓库名称&quot;，其他保持默认设置，点击 “Create repository” 按钮，就成功地创建了一个新的Git 仓库。3. $ git remote add origin git@github:&lt;your github address&gt;， 添加远程库，名字叫做 origin。4. $ git push -u origin master，把本地库推送到远程库上。由于远程库是空的，我们第一次推送 master 分支时，加上了-u 参数，Git 不但会把本地的 master 分支内容。推送的远程新的 master 分支，还会把本地的 master 分支和远程的master 分支关联起来，在以后的推送或者拉取时就可以简化命令。5. 以后提交只用写，$ git push origin master。6. 克隆远程库，$ git clone git@github.com:&lt;your github programe address&gt;.git。</code></pre><h2 id="六、分支管理"><a href="#六、分支管理" class="headerlink" title="六、分支管理"></a>六、分支管理</h2><pre><code>1、 创建dev分支，切换到dev分支    $ git checkout -b dev    (git checkout 命令加上-b 参数表示创建并切换， 相当于以下两条命令：        $ git branch dev        $ git checkout dev    )2、 查看当前分支    $ git branch3、 修改 readme.txt, add、 commit4、 切换回 master    $ git checkout master5、 合并分支    $ git merge dev6、 删除分支    $ git branch -d dev7、 解决冲突    找到冲突文件,去掉 &lt;&lt;&lt;&lt;&lt; =====    $ git add 冲突文件名字    $ git commit -m ‘注释’</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring aop 简单总结</title>
      <link href="/2019/01/19/Spring%20aop%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/19/Spring%20aop%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关于Spring-aop"><a href="#一、关于Spring-aop" class="headerlink" title="一、关于Spring aop"></a>一、关于Spring aop</h2><h4 id="1、简单介绍"><a href="#1、简单介绍" class="headerlink" title="1、简单介绍"></a>1、简单介绍</h4><p>在软件开发中，散布于应用中多处的功能被称为横切关注点（crosscutting concern）。通常来讲，这些横切关注点从概念上是与应用的业务逻辑相分离的（但是往往会直接嵌入到应用的业务逻辑之中）。简而言之，横切关注点可以被描述为影响应用多处的功能。</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fz9w687qgaj30km0cowj1.jpg" alt=""></p><p>AOP,即面向切面编程（Aspect Oriented Programing），相较OOP而言，AOP 关注的不再是程序代码中某个类或某些方法，而 aop 考虑的更多的是一种面到面的切入，即层与层之间的一种切入，所以称之为切面。</p><h4 id="2、应用场景"><a href="#2、应用场景" class="headerlink" title="2、应用场景"></a>2、应用场景</h4><p>AOP主要应用于日志、安全、事务管理性能统计等方面，实现公共功能代码的复用。</p><h4 id="3、AOP带来的好处"><a href="#3、AOP带来的好处" class="headerlink" title="3、AOP带来的好处"></a>3、AOP带来的好处</h4><p>(1) 降低模块与模块之间的耦合度，提高业务代码的聚合度，即所谓的高内聚低耦合（DI有助于应用对象之间的解耦，而AOP可以实现横切关注点与它们所影响的对象之间的解耦）。</p><p>(2) 提高了代码的复用性。</p><p>(3) 提高系统的扩展性。</p><h2 id="二、AOP基本概念"><a href="#二、AOP基本概念" class="headerlink" title="二、AOP基本概念"></a>二、AOP基本概念</h2><h4 id="1、通知（Advice"><a href="#1、通知（Advice" class="headerlink" title="1、通知（Advice)"></a>1、通知（Advice)</h4><p>在AOP术语中，切面的工作被称为通知。通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。Spring切面可以应用5种类型的通知：</p><pre><code>前置通知（Before）：在目标方法被调用之前调用通知功能；后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；返回通知（After-returning）：在目标方法成功执行之后调用通知；异常通知（After-throwing）：在目标方法抛出异常后调用通知；环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</code></pre><h4 id="2、连接点（Join-point）"><a href="#2、连接点（Join-point）" class="headerlink" title="2、连接点（Join point）"></a>2、连接点（Join point）</h4><p>连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。<br><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fz9wn10ky6j30mn0g7tbx.jpg" alt=""></p><h4 id="3、-切点（Poincut）"><a href="#3、-切点（Poincut）" class="headerlink" title="3、 切点（Poincut）"></a>3、 切点（Poincut）</h4><p>如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处”。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p><h4 id="4、切面（Aspect）"><a href="#4、切面（Aspect）" class="headerlink" title="4、切面（Aspect）"></a>4、切面（Aspect）</h4><p>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——它是什么，在何时和何处完成其功能。切点定义了要拦截哪些类的哪些方法， 通知则定义了拦截过方法后要做什么，切面则是横切关注点的抽象，与类相似，类是对物体特征的抽象，切面则是横切关注点抽象。</p><h4 id="5、引入（Introduction）"><a href="#5、引入（Introduction）" class="headerlink" title="5、引入（Introduction）"></a>5、引入（Introduction）</h4><p>在不修改原有应用程序代码的情况下，在程序运行期为类动态添加方法或者字段的过程称为引入。</p><p>####6、织入（Weaving）</p><p>织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多个点可以进行织入，包括编译期、类加载期和运行期，但是Spring的AOP只支持在运行期织入。</p><h2 id="三、Spring-对AOP的支持"><a href="#三、Spring-对AOP的支持" class="headerlink" title="三、Spring 对AOP的支持"></a>三、Spring 对AOP的支持</h2><h4 id="1、Spring在运行时通知对象"><a href="#1、Spring在运行时通知对象" class="headerlink" title="1、Spring在运行时通知对象"></a>1、Spring在运行时通知对象</h4><p>Spring AOP是基于动态代理的，通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。如图所示，代理类封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fz9y9bib6nj30q20ds0ul.jpg" alt=""></p><p>直到应用需要被代理的bean时，Spring才创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入Spring AOP的切面。</p><h4 id="2、Spring只支持方法级别的连接点"><a href="#2、Spring只支持方法级别的连接点" class="headerlink" title="2、Spring只支持方法级别的连接点"></a>2、Spring只支持方法级别的连接点</h4><p>因为Spring基于动态代理，所以Spring只支持方法连接点。这与一些其他的AOP框架是不同的，例如AspectJ和JBoss，除了方法切点，它们还提供了字段和构造器接入点。 Spring缺少对字段连接点的支持，无法让我们创建细粒度的通知，例如拦截对象字段的修改。而且它不支持构造器连接点，我们就无法在bean创建时应用通知，但是方法拦截可以满足绝大部分的需求。</p><h2 id="四、切点表达式语言"><a href="#四、切点表达式语言" class="headerlink" title="四、切点表达式语言"></a>四、切点表达式语言</h2><p>在Spring AOP中，要使用AspectJ的切点表达式语言来定义切点，但是，Spring仅支持AspectJ切点指示器（pointcut designator）的一个子集。如下：</p><pre><code>AspectJ指示器                                             描　　述 arg()                                         限制连接点匹配参数为指定类型的执行方法 @args()                                    限制连接点匹配参数由指定注解标注的执行方法 execution()                                 用于匹配是连接点的执行方法 this()                                     限制连接点匹配AOP代理的bean引用为指定类型的类 target                                     限制连接点匹配目标对象为指定类型的类 @target()                                    限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解 within()                                     限制连接点匹配指定的类型 @within()                                    限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方法定义在由指定的注解所标注的类里） @annotation                                 限定匹配带有指定注解的连接点 bean()                                        允许我们在切点表达式中使用bean的ID来匹配特定的bean</code></pre><p>注意，只有execution指示器是实际执行匹配的，而其他的指示器都是用来限制匹配的。如下是一个式例声明：</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fz9yx6ksutj30lg08mgnb.jpg" alt=""></p><h2 id="五、具体使用"><a href="#五、具体使用" class="headerlink" title="五、具体使用"></a>五、具体使用</h2><h4 id="1、配置文件"><a href="#1、配置文件" class="headerlink" title="1、配置文件"></a>1、配置文件</h4><p>要想使用Spring aop,首先需要在pom.xml中引入如下的坐标依赖:</p><pre><code> &lt;!--spring 核心依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring-aop面向切面--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectj代理--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;  &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;  &lt;version&gt;1.8.9&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>其次，需要在spring.xml开启组件扫描和AspectJ自动代理:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!--组件扫描--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets&quot;/&gt;    &lt;!--aspectj自动代理--&gt;    &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt;</code></pre><h4 id="2、使用AOP"><a href="#2、使用AOP" class="headerlink" title="2、使用AOP"></a>2、使用AOP</h4><p>例如，对于演出而言，观众是很重要的一个关注点，但就演出本身而言，它并不是演出的核心功能，在演出前观众需要就坐和把手机调到静音，演出很精彩的话观众可能会鼓掌，演出没有达到预期的话观众可能就需要退款了，如下是通过java的方式将观众配置为一个切面：</p><pre><code>package com.carleviets.aop;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;@Component@Aspectpublic class Audience {    @Pointcut(&quot;execution(* com.carleviets.concert.Perfermance.perform(..))&quot;)    public void performance(){}    @Before(&quot;performance()&quot;)    public void silenceCellPhones(){        System.out.println(&quot;将手机调到静音...&quot;);    }    @Before(&quot;performance()&quot;)    public void takeSeats(){        System.out.println(&quot;就坐...&quot;);    }    @AfterReturning(&quot;performance()&quot;)    public void applause(){        System.out.println(&quot;鼓掌...&quot;);    }    @AfterThrowing(&quot;performance()&quot;)    public void demandRefund(){        System.out.println(&quot;需要退款...&quot;);    }}</code></pre><p>注意上面定义的perfermance()方法本身的内容并不重要，该方法本身只是一个标识，供@Pointcut注解依附以便声明切点。同时也需要注意上面使用AspectJ注解声明了通知的方法。</p><p>同样，我们也可以通过xml的方式进行切面配置, 首先，去掉注解后的Audience类是一个普通的POJO类:</p><pre><code>package com.carleviets.aop;import org.springframework.stereotype.Component;@Componentpublic class Audience {    public void silenceCellPhones(){        System.out.println(&quot;将手机调到静音...&quot;);    }    public void takeSeats(){        System.out.println(&quot;就坐...&quot;);    }    public void applause(){        System.out.println(&quot;鼓掌...&quot;);    }    public void demandRefund(){        System.out.println(&quot;需要退款...&quot;);    }}</code></pre><p>在spring.xml中，需要添加如下配置：</p><pre><code>&lt;aop:config&gt;    &lt;!--声明切面--&gt;    &lt;aop:aspect ref=&quot;audience&quot;&gt;        &lt;!--声明切点--&gt;        &lt;aop:pointcut id=&quot;perfermance&quot; expression=&quot;execution(* com.carleviets.concert.Perfermance.perform(..))&quot;/&gt;        &lt;!--声明前置通知--&gt;        &lt;aop:before pointcut-ref=&quot;perfermance&quot; method=&quot;silenceCellPhones&quot;/&gt;        &lt;aop:before pointcut-ref=&quot;perfermance&quot; method=&quot;takeSeats&quot;/&gt;        &lt;!--声明返回通知--&gt;        &lt;aop:after-returning pointcut-ref=&quot;perfermance&quot; method=&quot;applause&quot;/&gt;        &lt;!--声明异常通知--&gt;        &lt;aop:after-throwing pointcut-ref=&quot;perfermance&quot; method=&quot;demandRefund&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><p>这样，我们就通过Java配置的方式和通过xml的方式完成了一个切面的配置。</p><h4 id="3、使用环绕通知"><a href="#3、使用环绕通知" class="headerlink" title="3、使用环绕通知"></a>3、使用环绕通知</h4><p>在所有的通知中，环绕通知是功能最为强大的类型。它能够让你所编写的逻辑将被通知的目标方法完全包装起来。实际上就像在一个通知方法中同时编写前置通知和后置通知。同样以上述的表演为例，环绕通知的Java配置如下:</p><pre><code>package com.carleviets.aop;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;@Component@Aspectpublic class Audience {    @Pointcut(&quot;execution(* com.carleviets.concert.Perfermance.perform(..))&quot;)    public void performance(){}    @Around(&quot;performance()&quot;)    public Object watchPerfermance(ProceedingJoinPoint proceedingJoinPoint){        Object result=null;        try {            //在演出开始前把手机调到静音和就坐            System.out.println(&quot;将手机调到静音...&quot;);            System.out.println(&quot;就坐...&quot;);            //调用被拦截的方法，如果方法有返回值需要在最后通过return返回结果            result=proceedingJoinPoint.proceed();            //演出成功，鼓掌            System.out.println(&quot;鼓掌...&quot;);        } catch (Throwable throwable) {            throwable.printStackTrace();            //演出不符合预期            System.out.println(&quot;需要退款...&quot;);        }        return result;    }}</code></pre><p>在上面的配置中需要注意的是ProceedingJoinPoint对象的proceed方法的调用，当然你也可以不调用proceed()方法，这样的话会阻塞对被通知方法的访问，同样，你也可以在通知中对它进行多次调用。同样，如果用xml来配置环绕通知的话，此时，具体Java类的代码如下:</p><pre><code>package com.carleviets.aop;import org.aspectj.lang.ProceedingJoinPoint;import org.springframework.stereotype.Component;@Componentpublic class Audience {    public Object watchPerfermance(ProceedingJoinPoint proceedingJoinPoint){        Object result=null;        try {            //在演出开始前把手机调到静音和就坐            System.out.println(&quot;将手机调到静音...&quot;);            System.out.println(&quot;就坐...&quot;);            //调用被拦截的方法，如果方法有返回值需要在最后通过return返回结果            result=proceedingJoinPoint.proceed();            //演出成功，鼓掌            System.out.println(&quot;鼓掌...&quot;);        } catch (Throwable throwable) {            throwable.printStackTrace();            //演出不符合预期            System.out.println(&quot;需要退款...&quot;);        }        return result;    }}</code></pre><p>具体的xml配置如下:</p><pre><code>&lt;aop:config&gt;    &lt;!--声明切面--&gt;    &lt;aop:aspect ref=&quot;audience&quot;&gt;        &lt;!--声明切点--&gt;        &lt;aop:pointcut id=&quot;perfermance&quot; expression=&quot;execution(* com.carleviets.concert.Perfermance.perform(..))&quot;/&gt;        &lt;!--配置环绕通知--&gt;        &lt;aop:around method=&quot;watchPerfermance&quot; pointcut-ref=&quot;perfermance&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><h4 id="4、处理通知中的参数"><a href="#4、处理通知中的参数" class="headerlink" title="4、处理通知中的参数"></a>4、处理通知中的参数</h4><p>上面的通知方法中都没有参数，但是，如果要往通知中传入参数，该怎么办?下面是一个记录音乐CD播放的磁道计数的Java切面代码:</p><pre><code>package com.carleviets.aop;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;import java.util.HashMap;import java.util.Map;@Component@Aspectpublic class TrackCounter {    //定义一个Map,键为歌曲在磁道中的位置，值为磁道中对应歌曲所对应的播放次数计数值    private Map&lt;Integer, Integer&gt; tracks=new HashMap&lt;&gt;();    @Pointcut(&quot;execution(* com.carleviets.soundsystem.CD.playTrack(int )) &amp;&amp; args(trackNumber))&quot;)    public void trackPlayed(int trackNumber){}    @Before(&quot;trackPlayed(trackNumber)&quot;)    public void trackCount(int trackNumber){        int currentCount=getPlayCount(trackNumber);        tracks.put(trackNumber, currentCount++);    }    /**     * 如果该trackNumber之前存在播放记录，则返回之前的播放次数，否则返回0     * @param trackNumber     * @return     */    private int getPlayCount(int trackNumber) {        return tracks.containsKey(trackNumber) ? tracks.get(trackNumber) : 0;    }}</code></pre><p>切点表达式的具体解释如下图所示:</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fzc4m51xibj30ot095406.jpg" alt=""></p><p>上述代码如果采用xml来配置的话，Java类如下:</p><pre><code>package com.carleviets.aop;import org.aspectj.lang.annotation.Aspect;import org.springframework.stereotype.Component;import java.util.HashMap;import java.util.Map;@Componentpublic class TrackCounter {    //定义一个Map,键为歌曲在磁道中的位置，值为磁道中对应歌曲所对应的播放次数计数值    private Map&lt;Integer, Integer&gt; tracks=new HashMap&lt;&gt;();    public void trackCount(int trackNumber){        int currentCount=getPlayCount(trackNumber);        tracks.put(trackNumber, currentCount++);    }    /**     * 如果该trackNumber之前存在播放记录，则返回之前的播放次数，否则返回0     * @param trackNumber     * @return     */    private int getPlayCount(int trackNumber) {        return tracks.containsKey(trackNumber) ? tracks.get(trackNumber) : 0;    }}</code></pre><p>spring.xml的具体配置如下:</p><pre><code>&lt;aop:config&gt;    &lt;!--声明切面--&gt;    &lt;aop:aspect ref=&quot;trackCounter&quot;&gt;        &lt;!--声明切点--&gt;        &lt;aop:pointcut id=&quot;trackPlayed&quot; expression=&quot;execution(* com.carleviets.soundsystem.CD.playTrack(int)) and args(trackNumber)))&quot;/&gt;        &lt;!--声明前置通知--&gt;        &lt;aop:before method=&quot;trackCount&quot; pointcut-ref=&quot;trackPlayed&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><h4 id="1、代理模式实现三要素"><a href="#1、代理模式实现三要素" class="headerlink" title="1、代理模式实现三要素"></a>1、代理模式实现三要素</h4><pre><code>（1）接口定义（2）目标对象 与代理对象必须实现统一接口（3）代理对象持有目标对象的引用 增强目标对象行为</code></pre><h4 id="2、代理模式实现分类以及对应区别"><a href="#2、代理模式实现分类以及对应区别" class="headerlink" title="2、代理模式实现分类以及对应区别"></a>2、代理模式实现分类以及对应区别</h4><pre><code>（1）静态代理：手动为目标对象制作代理对象，即在程序编译阶段完成代理对象的创建（2）动态代理：在程序运行期动态创建目标对象对应代理对象。    jdk 动态代理：被代理目标对象必须实现某一或某一组接口 实现方式 通过回调创建代理对象。    cglib 动态代理：被代理目标对象可以不必实现接口，继承的方式实现。    动态代理相比较静态代理，提高开发效率，可以批量化创建代理，提高代码复用率。</code></pre><h4 id="3、Aop-理解"><a href="#3、Aop-理解" class="headerlink" title="3、Aop 理解"></a>3、Aop 理解</h4><pre><code>(1)面向切面，相比oop, aop关注的是代码中的层或面(2) 解耦，提高系统扩展性(3) 提高代码复用</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代理模式总结</title>
      <link href="/2019/01/16/Java%E4%BB%A3%E7%90%86%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/16/Java%E4%BB%A3%E7%90%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、代理模式介绍"><a href="#一、代理模式介绍" class="headerlink" title="一、代理模式介绍"></a>一、代理模式介绍</h2><p>代理(Proxy)是一种设计模式,提供了对目标对象另外的一种访问方式:即通过代理对象访问目标对象。这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。用图表示如下:</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fz8jpxbn9xj30lb06gq36.jpg" alt=""></p><p>代理模式分为静态代理和动态代理。代理模式的设计有两个重要的原则:</p><pre><code>1、 代理类与委托类具有相似的行为（共同）2、 代理类增强委托类的行为</code></pre><h2 id="二、静态代理"><a href="#二、静态代理" class="headerlink" title="二、静态代理"></a>二、静态代理</h2><p>为某个对象提供一个代理，代理角色固定，以控制对这个对象的访问。代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象替代。 代理类负责请求的预处理、 过滤、 将请求分派给委托类处理、 以及委托类执行完请求后的后续处理。</p><p>代理接口的定义如下:</p><pre><code>package com.carleviets;/** * 代理接口的定义 */public interface Marry {    void toMarry();}</code></pre><p>目标类的定义如下:</p><pre><code>package com.carleviets.demo;import com.carleviets.Marry;/** * 目标类的具体实现 */public class Person implements Marry {    @Override    public void toMarry() {        System.out.println(&quot;即将结婚了...&quot;);    }}</code></pre><p>代理类的定义如下:</p><pre><code>package com.carleviets.demo;import com.carleviets.Marry;/** * 代理类的具体实现 */public class Company implements Marry {    //代理的对象，委托类    private Person target;         public Company(Person target) {        this.target = target;    }    public void before(){        System.out.println(&quot;布置婚礼现场...&quot;);    }    public void after(){        System.out.println(&quot;进入人生第二阶段，好嗨哟...&quot;);    }    @Override    public void toMarry() {        before();        target.toMarry();   //真实行为        after();    }}</code></pre><p>测试代码:</p><pre><code>package com.carleviets.demo;import org.junit.Test;public class CompanyTest {    @Test    public void test(){        Person person=new Person();        //构造代理角色的同时传入真实角色        Company company=new Company(person);        company.toMarry();    }}</code></pre><p>静态代理的总结：<br><br>1.可以做到在不修改目标对象的功能前提下,对目标功能扩展。<br><br>2、缺点:因为静态代理对于代理的角色是固定的,并且代理对象需要与目标对象实现相同的接口,所以会有很多的代理类。同时,一旦接口增加方法,目标对象与代理对象都需要维护，这使得静态代理就无法满足生产上的需要，于是就催生了动态代理的思想。</p><h2 id="三、JDK动态代理"><a href="#三、JDK动态代理" class="headerlink" title="三、JDK动态代理"></a>三、JDK动态代理</h2><p>JDK动态代理具有如下的特点:</p><pre><code>1.代理对象,不需要实现接口2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)</code></pre><p>要使用JDK中的代理，我们首先需要了解JDK中的代理接口:</p><p>1、java.lang.reflect.Proxy：这是Java动态代理机制的主类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象。其中Proxy代理类中具有如下常用的核心方法:</p><pre><code>// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器static InvocationHandler getInvocationHandler(Object proxy) // 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象static Class getProxyClass(ClassLoader loader, Class[] interfaces) // 方法 3：该方法用于判断指定类对象是否是一个动态代理类static boolean isProxyClass(Class cl) // 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)</code></pre><p>2、java.lang.reflect.InvocationHandler：这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。该类具有如下的核心方法:</p><pre><code>// 该方法负责集中处理动态代理类上的所有方法调用。第一个参数既是代理类实例，第二个参数是被调用的方法对象// 第三个方法是调用参数。调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行Object invoke(Object proxy, Method method, Object[] args)</code></pre><p>每次生成动态代理类对象时都需要指定一个实现了该接口的调用处理器对象（参见 Proxy 静态方法 4 的第三个参数）。</p><p>3、java.lang.ClassLoader：这是类装载器类，负责将类的字节码装载到Java虚拟机（JVM）中并为其定义类对象，然后该类才能被使用。Proxy 静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是由 JVM 在运行时动态生成的而非预存在于任何一个 .class 文件中。每次生成动态代理类对象时都需要指定一个类装载器对象（参见 Proxy 静态方法 4 的第一个参数）。</p><p>动态代理的底层原理比较负责，这里直接进入动态代理的使用,以下是InvocationHandler接口的具体实现:</p><pre><code>package com.carleviets.jdk;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * JDK动态代理 */public class JdkHandler implements InvocationHandler {    //目标类    private Object target;    public JdkHandler(Object target) {        this.target = target;    }    /**     * 程序运行期间动态创建代理角色     * @return     */    public Object getProxy(){        /**         * 获取代理对象：         *  1、类加载器         *  2、目标类   实现的接口   class         *  3、当前类         */        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this);    }    public void before(){        System.out.println(&quot;婚礼现场紧张布置中...&quot;);    }    public void after(){        System.out.println(&quot;恭喜你成功进入人生的第二阶段...&quot;);    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        before();        Object object=method.invoke(target, args);        after();        return object;    }}</code></pre><p>以下是JDK动态代理的具体测试代码:</p><pre><code>package com.carleviets.jdk;import com.carleviets.demo.Person;import org.junit.Test;public class JdkHandlerTest {    @Test    public void test() throws Throwable {        Person you=new Person();  //委托类        JdkHandler handler=new JdkHandler(you); //代理工厂        Object proxy=handler.getProxy();        handler.invoke(proxy, Person.class.getMethod(&quot;toMarry&quot;), null);    //执行    }}</code></pre><h2 id="四、Cglib动态代理"><a href="#四、Cglib动态代理" class="headerlink" title="四、Cglib动态代理"></a>四、Cglib动态代理</h2><p>Cglib（code generator library，代码生成库),是一个第三方提供的动态代理实现方案。与JDK动态代理相比:<br></p><pre><code>Proxy代理：委托类必须有接口，制作过程比较快，执行较慢。Cglib代理:委托类可以没有接口,使用继承的思维来实现相似性，制作代理过程相对较慢，执行快。 主要用于解决没有接口类的代理实现。</code></pre><p>使用Cglib来实现代理需要实现MethodInterceptor接口，具体实现如下:</p><pre><code>package com.carleviets.cglib;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class CglibInterceptor implements MethodInterceptor {    //被代理的目标对象    private Object target;    public CglibInterceptor(Object target) {        this.target = target;    }    //运行期动态创建代理类    public Object getProxy(){        Enhancer enhancer=new Enhancer();        //设置父类  class        enhancer.setSuperclass(target.getClass());        enhancer.setCallback(this);        return enhancer.create();    }    public void before(){        System.out.println(&quot;婚礼现场紧张布置中...&quot;);    }    public void after(){        System.out.println(&quot;进入人生第二阶段，好嗨哟...&quot;);    }    @Override    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {        before();   //增强真实角色行为        Object result=methodProxy.invoke(target, objects);        after();    //增强真实角色行为        return result;    }}</code></pre><p>具体的测试代码如下:</p><pre><code>package com.carleviets.cglib;import com.carleviets.demo.Person;import org.junit.Test;public class CglibInterceptorTest {    @Test    public void test(){        //创建目标对象        Person you=new Person();        CglibInterceptor cglibInterceptor=new CglibInterceptor(you);        //获取代理对象        Person proxy= (Person) cglibInterceptor.getProxy();        //调用代理对象的方法        proxy.toMarry();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RMI远程方法调用</title>
      <link href="/2019/01/16/%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/"/>
      <url>/2019/01/16/%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、RMI介绍"><a href="#一、RMI介绍" class="headerlink" title="一、RMI介绍"></a>一、RMI介绍</h2><p>Java远程方法调用 (Remote Method Invocation，RMI)是一种机制，能够让在某个Java虚拟机上的对象调用另一个Java虚拟机中的对象上的方法。JVM可以位于相同或不同计算机上，在多个JVM中，一个JVM可以调用存储在其它JVM的对象的方法。</p><p>RMI是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口， 它是客户机上运行的程序可以调用远程服务器上的对象，远程方法调用特性使 Java 编程人员能够在网络环境中分布操作。</p><p>Java RMI极大地依赖于接口，在需要创建一个远程对象的时候，程序员通过传递一个接口来隐藏底层的实现细节，客户端得到的远程对象句柄正好与本地的根代码连接，由后者负责透过网络通信。 这样一来，程序员只需关心如何通过自己的接口句柄发送消息。</p><p>RMI底层封装了Socket反射机制——java语言当中分布式的基础（实现 java 之间的互相访问）。RMI 本质就是使用代理类来封装 Socket 的通信细节！ </p><h2 id="二、RMI实现常用API"><a href="#二、RMI实现常用API" class="headerlink" title="二、RMI实现常用API"></a>二、RMI实现常用API</h2><p>1）Remote接口：每一个要暴露出去的java类，都需要实现 Remote 接口，并且所有的方法必须抛出 RemoteException。</p><p>2）UnicastRemoteObject类:服务端程序的实现方案之一就是继承这个类，无参构造器也要抛出 RemoteException。</p><p>3）LocateRegistry类:创建能在特定接口接受调用远程对象注册服务程序。</p><pre><code>    public static Registry createRegistry(int port) throws RemoteException</code></pre><p>4) Naming类：提供了存储和获得远程对象注册服务程序中的远程对象进行引用的方法</p><pre><code>    public static Remote lookup(String name) throws NotBoundException, MalformedURException, ReoteException    public static void bind(String name,Remote obj) throws AlreadyBoundException, MalforedURException, RemoteException</code></pre><h2 id="三、通过Java-RMI远程方法调用"><a href="#三、通过Java-RMI远程方法调用" class="headerlink" title="三、通过Java RMI远程方法调用"></a>三、通过Java RMI远程方法调用</h2><p>下面是使用Maven的多模块模拟远程方法调用的过程，首先先建一个父工程<code>rmi_par</code>,在<code>rmi_par</code>模块下建立如下子模块：</p><pre><code>rmi_api模块：远程方法调用的接口定义rmi_server模块:远程方法调用的具体服务实现rmi_client模块:调用远程方法的具体模块</code></pre><h3 id="1、服务的接口定义——rmi-api模块"><a href="#1、服务的接口定义——rmi-api模块" class="headerlink" title="1、服务的接口定义——rmi_api模块"></a>1、服务的接口定义——rmi_api模块</h3><p>以下是服务接口的定义:</p><pre><code>package com.carleviets.service;import java.rmi.Remote;import java.rmi.RemoteException;/** * 1、接口继承自Remote * 2、对外服务方法声明RemoteException异常 */public interface IHelloService extends Remote {    String sayHello(String msg) throws RemoteException;}</code></pre><h3 id="2、服务接口的具体实现和发布——rmi-server模块"><a href="#2、服务接口的具体实现和发布——rmi-server模块" class="headerlink" title="2、服务接口的具体实现和发布——rmi_server模块"></a>2、服务接口的具体实现和发布——rmi_server模块</h3><p>以下是服务端服务接口的具体实现:</p><pre><code>package com.carleviets.service.impl;import com.carleviets.service.IHelloService;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;/** * 1、继承 UnicastRemoteObject * 2、提供无参构造，对外声明 RemoteException */public class HelloServiceImpl extends UnicastRemoteObject implements IHelloService {    protected HelloServiceImpl() throws RemoteException {    }    @Override    public String sayHello(String msg) throws RemoteException {        System.out.println(&quot;服务器端接收到消息：&quot;+msg);        return &quot;hello:&quot;+msg;    }}</code></pre><p>现在，就可以把服务发布出去了，具体的发布代码如下：</p><pre><code>package com.carleviets.service.impl;import java.net.MalformedURLException;import java.rmi.AlreadyBoundException;import java.rmi.Naming;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;/** * 对外发布服务 */public class Publish {    public static void main(String[] args) throws RemoteException, AlreadyBoundException, MalformedURLException {        //注册端口        LocateRegistry.createRegistry(8888);        //对外发布RMI服务        Naming.bind(&quot;rmi://127.0.0.1:8888/hello&quot;, new HelloServiceImpl());    }}</code></pre><h3 id="3、服务的调用——rmi-client模块"><a href="#3、服务的调用——rmi-client模块" class="headerlink" title="3、服务的调用——rmi_client模块"></a>3、服务的调用——rmi_client模块</h3><pre><code>package com.carleviets;import com.carleviets.service.IHelloService;import org.junit.Test;import java.net.MalformedURLException;import java.rmi.Naming;import java.rmi.NotBoundException;import java.rmi.RemoteException;public class TestRMI {    @Test    public void test() throws RemoteException, NotBoundException, MalformedURLException {        IHelloService helloService= (IHelloService) Naming.lookup(&quot;rmi://127.0.0.1:8888/hello&quot;);        String hello=helloService.sayHello(&quot;I&#39;m a hero.&quot;);        System.out.println(hello);    }}</code></pre><p>注意，这里只是通过maven的多模块对RMI远程调用进行模拟测试，在具体的现实环境中，要通过RMI进行远程方法调用，需要服务器端和客户端实现相同的接口。</p><h2 id="四、通过Spring来实现远程方法调用"><a href="#四、通过Spring来实现远程方法调用" class="headerlink" title="四、通过Spring来实现远程方法调用"></a>四、通过Spring来实现远程方法调用</h2><p>使用Spring的RMI，提供的服务简单方便，不用继承特定的类，也不需要抛出异常。</p><h3 id="1、-服务的接口定义——rmi-api模块："><a href="#1、-服务的接口定义——rmi-api模块：" class="headerlink" title="1、 服务的接口定义——rmi_api模块："></a>1、 服务的接口定义——rmi_api模块：</h3><pre><code>package com.carleviets.service;import java.rmi.Remote;import java.rmi.RemoteException;/** * 1、接口继承自Remote * 2、对外服务方法声明RemoteException异常 */public interface IHelloService extends Remote {    String sayHello(String msg) throws RemoteException;}</code></pre><p>可以看出，在提供服务的接口这一块儿，没有任何变化。</p><h3 id="2、服务接口的具体实现和发布——spring-server模块"><a href="#2、服务接口的具体实现和发布——spring-server模块" class="headerlink" title="2、服务接口的具体实现和发布——spring_server模块"></a>2、服务接口的具体实现和发布——spring_server模块</h3><pre><code>package com.carleviets.service.impl;import com.carleviets.service.IHelloService;import org.springframework.stereotype.Service;import java.rmi.RemoteException;/** * 使用spring实现服务器端服务 */@Servicepublic class HelloServiceImpl implements IHelloService {    @Override    public String sayHello(String msg) throws RemoteException {        System.out.println(&quot;服务端收到消息：&quot;+msg);        return &quot;hello:&quot;+msg;    }}</code></pre><p>同时，需要将上述的服务实现的具体类在spring的配置文件中通过相应的配置发布出去，具体配置如下:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!--定义组件扫描的范围--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets&quot;/&gt;    &lt;!--加入rmi相关配置--&gt;    &lt;bean class=&quot;org.springframework.remoting.rmi.RmiServiceExporter&quot;&gt;        &lt;!--配置对外提供服务的名称--&gt;        &lt;property name=&quot;serviceName&quot; value=&quot;hello&quot;/&gt;        &lt;!--指定服务的具体实现bean--&gt;        &lt;property name=&quot;service&quot; ref=&quot;helloServiceImpl&quot;/&gt;        &lt;!--配置发布的服务接口--&gt;        &lt;property name=&quot;serviceInterface&quot; value=&quot;com.carleviets.service.IHelloService&quot;/&gt;        &lt;!--配置服务注册的端口号--&gt;        &lt;property name=&quot;registryPort&quot; value=&quot;1199&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>这样，spring容器在启动的时候，就会自动将服务注册到对应的rmi地址上:</p><pre><code>package com.carleviets.service.impl;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 测试spring实现RMI的服务器端 */public class HelloServiceImplTest {    public static void main(String[] args) {        //布置RMI服务只需要启动容器即可        new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);    }}</code></pre><h3 id="3、客户端服务的调用——spring-client模块"><a href="#3、客户端服务的调用——spring-client模块" class="headerlink" title="3、客户端服务的调用——spring_client模块"></a>3、客户端服务的调用——spring_client模块</h3><p>要使用以上通过spring发布的服务，首先需要在spring.xml配置RMI代理工厂bean：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--配置Rmi代理工厂bean--&gt;    &lt;bean class=&quot;org.springframework.remoting.rmi.RmiProxyFactoryBean&quot;&gt;        &lt;!--指定提供服务的地址、端口和服务名称--&gt;        &lt;property name=&quot;serviceUrl&quot; value=&quot;rmi://localhost:1199/hello&quot;/&gt;        &lt;!-- 指定使用服务的接口 --&gt;        &lt;property name=&quot;serviceInterface&quot; value=&quot;com.carleviets.service.IHelloService&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>这样，就可以使用具体的服务了，如下是调用远程服务的测试代码:</p><pre><code>package com.carleviets;import com.carleviets.service.IHelloService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.rmi.RemoteException;/** * Spring实现RMI的客户端 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = {&quot;classpath:spring.xml&quot;})public class TestSpringRmiClient {    @Autowired    private IHelloService helloService;    @Test    public void test() throws RemoteException {        String hello=helloService.sayHello(&quot;I&#39;m spring rmi.&quot;);        System.out.println(hello);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rmi远程方法调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring mvc中的全局异常处理</title>
      <link href="/2019/01/16/Spring%20mvc%E4%B8%AD%E7%9A%84%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2019/01/16/Spring%20mvc%E4%B8%AD%E7%9A%84%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-mvc中的全局异常处理"><a href="#Spring-mvc中的全局异常处理" class="headerlink" title="Spring mvc中的全局异常处理"></a>Spring mvc中的全局异常处理</h1><p>在spring mvc中，对全局异常处理的支持有以下三种方式:</p><pre><code>1、使用Spring mvc提供的简单异常处理器 SimpleMappingExceptionResolver；2、实现Spring的异常处理接口 HandlerExceptionResolver 自定义自己的异常处理器;3、使用@ExceptionHandler 注解实现异常处理；4、控制器通知和@ExceptionHandler注解结合使用</code></pre><h2 id="一、使用SimpleMappingExceptionResolver进行异常处理"><a href="#一、使用SimpleMappingExceptionResolver进行异常处理" class="headerlink" title="一、使用SimpleMappingExceptionResolver进行异常处理"></a>一、使用SimpleMappingExceptionResolver进行异常处理</h2><p>使用Spring中的自带的SimpleMappingExceptionResolver类进行异常处理，具有集成简单、扩展性好、对已有代码没有侵入性等优点，但该方法仅能获取到异常信息，若在出现异常时，对需要获取除异常以外的数据的情况不适用。要使用SimpleMappingExceptionResolver，需要配置bean:</p><pre><code>&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;    &lt;!-- 为所有的异常定义默认的异常处理页面，exceptionMappings未定义的异常使用本默认配置 --&gt;    &lt;property name=&quot;defaultErrorView&quot; value=&quot;error&quot;/&gt;    &lt;!-- 定义异常处理页面用来获取异常信息的变量名，默认名为exception --&gt;    &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;/&gt;    &lt;!--定义需要特殊处理的异常，用类名或完全路径名作为key，异常页文件名作为值，将不同的异常映射到不同的页面上。--&gt;    &lt;property name=&quot;exceptionMappings&quot;&gt;        &lt;props&gt;            &lt;prop key=&quot;com.carleviets.exception.BusinessException&quot;&gt;business_error&lt;/prop&gt;            &lt;prop key=&quot;com.carleviets.exception.ParamsException&quot;&gt;params_error&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p>一个典型的异常显示界面如下：</p><pre><code>&lt;html&gt; &lt;head&gt;&lt;title&gt;Exception!&lt;/title&gt;&lt;/head&gt; &lt;body&gt; 　　&lt;% Exception e = (Exception)request.getAttribute(&quot;ex&quot;); %&gt; 　　&lt;H2&gt;Exception: &lt;%= e.getMessage();%&gt;&lt;/H2&gt; 　　&lt;P/&gt; 　　&lt;% e.printStackTrace(new java.io.PrintWriter(out)); %&gt; &lt;/body&gt; &lt;/html&gt; </code></pre><p>exception 是在 SimpleMappingExceptionResolver 被存放到 request 中的，具体可以查看源代码。</p><h2 id="二、实现-HandlerExceptionResolver-接口"><a href="#二、实现-HandlerExceptionResolver-接口" class="headerlink" title="二、实现 HandlerExceptionResolver 接口"></a>二、实现 HandlerExceptionResolver 接口</h2><p>使用这种方式只需要实现 resolveException 方法，该方法返回一个 ModelAndView 对象，在方法内部对异常的类型进行判断，然后返回合适的 ModelAndView 对象，如果该方法返回 null，则 Spring 会继续寻找其他的实现了 HandlerExceptionResolver 接口的 Bean。换句话说，Spring 会搜索所有注册在其环境中的实现了 HandlerExceptionResolver 接口的 Bean，逐个执行，直到返回了一个 ModelAndView 对象。</p><pre><code>package com.carleviets.exceptions.handler;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.HashMap;import java.util.Map;public class MyExceptionHandler implements HandlerExceptionResolver {    /**     *     * @param request     * @param response     * @param target   被调用的方法     * @param ex       用来接收异常的局部变量名     * @return     */    @Override    public ModelAndView resolveException(HttpServletRequest request,                                         HttpServletResponse response, Object target, Exception ex) {        //此处定义的Map实际上就是Spring mvc中的Model(Model的内部实现就是一个Map)        Map&lt;String,Object&gt; map=new HashMap&lt;String, Object&gt;();        map.put(&quot;ex&quot;, ex);        if(ex instanceof ParamsException){            return new ModelAndView(&quot;error_param&quot;, map);        }        if(ex instanceof BusinessException){            return new ModelAndView(&quot;error_business&quot;, map);        }        return new ModelAndView(&quot;error&quot;, map);    }}</code></pre><p>要注意，实现HandlerExceptionResolver接口的类必须声明到 Spring 配置文件中，或者使用 @Component 标签，让 Spring 管理它。</p><h2 id="三、使用-ExceptionHandler-注解实现异常处理"><a href="#三、使用-ExceptionHandler-注解实现异常处理" class="headerlink" title="三、使用 @ExceptionHandler 注解实现异常处理"></a>三、使用 @ExceptionHandler 注解实现异常处理</h2><p>该方法需要定义在某个 Controller 内部，表示能够处理同一个控制器中所有处理器方法抛出的相应异常。@ExceptionHandler 中可以添加一个或多个异常的类型，如果为空的话则认为可以触发所有的异常类型错误。</p><pre><code>package com.carleviets.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.ExceptionHandler;import javax.servlet.http.HttpServletRequest;import java.io.IOException;@Controllerpublic class  BaseController {    @ExceptionHandler(value={ParamsException.class,BusinessException.class, IOException.class})    public String exp(HttpServletRequest request, Exception ex) {        request.setAttribute(&quot;ex&quot;, ex);        if(ex instanceof ParamsException){            return &quot;error_param&quot;;        }        if(ex instanceof BusinessException){            return &quot;error_business&quot;;        }        return &quot;error&quot;;    }} </code></pre><p>上面我们写了一个BaseController,所有继承了该类的控制器就可以实现相应异常的处理。但这种方式对代码具有侵入性，考虑到Java具有单继承多实现的特点，这种方式不推荐使用。</p><h2 id="四、使用控制器通知"><a href="#四、使用控制器通知" class="headerlink" title="四、使用控制器通知"></a>四、使用控制器通知</h2><p>控制器通知是Spring 3.2引入的一个新特性，通俗来讲，控制器通知（controller advice）是任意带有@ControllerAdvice注解的类，这个类会包含一个或多个如下类型的方法：</p><pre><code>@ExceptionHandler 注解标注的方法；@InitBinder 注解标注的方法；@ModelAttribute 注解标注的方法</code></pre><p>在带有@ControllerAdvice注解的类中，以上所述的这些方法会运用到整个应用程序所有控制器中带有@RequestMapping注解的方法上。下面是Spring中ControllerAdvice的源码:</p><pre><code>@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface ControllerAdvice {    @AliasFor(&quot;basePackages&quot;)    String[] value() default {};    @AliasFor(&quot;value&quot;)    String[] basePackages() default {};    Class&lt;?&gt;[] basePackageClasses() default {};    Class&lt;?&gt;[] assignableTypes() default {};    Class&lt;? extends Annotation&gt;[] annotations() default {};}</code></pre><p>@ControllerAdvice注解本身已经使用了@Component，因此@ControllerAdvice注解所标注的类将会自动被组件扫描获取到，就像带有@Component注解的类一样。控制器通知最为实用的一个场景就是将所有的@ExceptionHandler方法收集到一个类中，这样所有控制器的异常就能在一个地方进行一致的处理。如下:</p><pre><code>package com.carleviets.exceptions.handler;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;//定义控制器通知@ControllerAdvicepublic class GlobalExceptionHandler {    //定义异常处理方法    @ExceptionHandler(BusinessException.class)    public String businessExceptionHandle(){        return &quot;error_business&quot;;    }    //定义异常处理方法    @ExceptionHandler(ParamsException.class)    public String businessExceptionHandle(){        return &quot;params_business&quot;;    }}</code></pre><h2 id="五、将具体的异常映射为HTTP状态码"><a href="#五、将具体的异常映射为HTTP状态码" class="headerlink" title="五、将具体的异常映射为HTTP状态码"></a>五、将具体的异常映射为HTTP状态码</h2><p>在默认情况下， Spring会将自身的一些异常自动转换为合适的状态码。但是我们也可以通过@ResponseStatus将具体的异常隐射为具体的HTTP状态码。</p><pre><code>package com.carleviets.exceptions;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.ResponseStatus;@ResponseStatus(value = HttpStatus.NOT_FOUND, reason = &quot;文档不存在&quot;)public class DocumentNotFoundException extends RuntimeException {}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 全局异常处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring定时任务的实现</title>
      <link href="/2019/01/14/Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2019/01/14/Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、通过xml的方式配置定时任务"><a href="#一、通过xml的方式配置定时任务" class="headerlink" title="一、通过xml的方式配置定时任务"></a>一、通过xml的方式配置定时任务</h2><p>以下是通过XML实现定时任务的具体Java代码:</p><pre><code>package com.carleviets;import org.springframework.stereotype.Component;@Componentpublic class TaskJob {    public void job01(){        System.out.println(&quot;job01...&quot;);    }    public void job02(){        System.out.println(&quot;job02...&quot;);    }}</code></pre><p>以下是使用XML配置定时任务时spring.xml的具体配置:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;   xmlns:task=&quot;http://www.springframework.org/schema/task&quot;   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd   http://www.springframework.org/schema/task   http://www.springframework.org/schema/task/spring-task.xsd&quot;&gt;    &lt;!--启动Spring组件扫描--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets&quot;/&gt;    &lt;!--XML的方式配置定时任务--&gt;    &lt;task:scheduled-tasks&gt;        &lt;task:scheduled ref=&quot;taskJob&quot; method=&quot;job01&quot; cron=&quot;0/5 * * * * ? &quot;/&gt;        &lt;task:scheduled ref=&quot;taskJob&quot; method=&quot;job02&quot; cron=&quot;0/2 * * * * ? &quot; /&gt;    &lt;/task:scheduled-tasks&gt;&lt;/beans&gt;</code></pre><h2 id="二、通过注解的方式配置定时任务"><a href="#二、通过注解的方式配置定时任务" class="headerlink" title="二、通过注解的方式配置定时任务"></a>二、通过注解的方式配置定时任务</h2><p>以下是通过注解的方式实现定时任务的具体Java代码：</p><pre><code>package com.carleviets;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;@Componentpublic class TaskJob {    @Scheduled(cron = &quot;0/5 * * * * ? &quot;)    public void job01(){        System.out.println(&quot;job03...&quot;);    }    @Scheduled(cron = &quot;0/2 * * * * ? &quot;)    public void job02(){        System.out.println(&quot;job04...&quot;);    }}</code></pre><p>以下是使用注解配置定时任务时spring.xml的具体配置:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;   xmlns:task=&quot;http://www.springframework.org/schema/task&quot;   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd   http://www.springframework.org/schema/task   http://www.springframework.org/schema/task/spring-task.xsd&quot;&gt;    &lt;!--启动Spring组件扫描--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets&quot;/&gt;      &lt;!--引入定时任务的注解驱动--&gt;       &lt;task:annotation-driven/&gt;&lt;/beans&gt;</code></pre><h2 id="三、分析总结"><a href="#三、分析总结" class="headerlink" title="三、分析总结"></a>三、分析总结</h2><p>不管是用过XML的方式还是通过注解的方式配置定时任务，都应该先引入spring-task的命名空间:</p><pre><code>xmlns:task=&quot;http://www.springframework.org/schema/taskhttp://www.springframework.org/schema/taskhttp://www.springframework.org/schema/task/spring-task.xsd</code></pre><p>其次，根据不同的情况来给定时任务的代码使用Cron表达式，具体Cron表达式的生成可参照: <a href="http://cron.qqe2.com/" target="_blank" rel="noopener">http://cron.qqe2.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Spring中的作用域问题</title>
      <link href="/2019/01/13/%E5%85%B3%E4%BA%8ESpring%E4%B8%ADbean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2019/01/13/%E5%85%B3%E4%BA%8ESpring%E4%B8%ADbean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="一、bean的四种作用域"><a href="#一、bean的四种作用域" class="headerlink" title="一、bean的四种作用域"></a>一、bean的四种作用域</h2><p>Spring定义了多种作用域，可以基于这些作用域创建bean，包括:</p><pre><code>单例（Singleton）：在整个应用中，只创建bean的一个实例。原型（Prototype）：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。会话（Session）：在Web应用中，为每个会话创建一个bean实例。请求（Rquest）：在Web应用中，为每个请求创建一个bean实例 </code></pre><p>在默认情况下， Spring应用上下文中所有bean都是作为以单例（singleton）的形式创建的。也就是说，不管给定的一个bean被注入到其他bean多少次，每次所注入的都是同一个实例。在大多数情况下，单例bean是很理想的方案。但是在某些情况下，你所使用的类是易变的（mutable），它们会保持一些状态，因此重用是不安全的。在这种情况下，将class声明为单例的bean就不是什么好主意了。</p><h2 id="二、使用其他作用域的bean"><a href="#二、使用其他作用域的bean" class="headerlink" title="二、使用其他作用域的bean"></a>二、使用其他作用域的bean</h2><p>要声明bean为其他作用域，可以使用@Scope注解，以下是用过@Scope注解和@Component注解一起使用，声明了一个原型作用域的bean：</p><pre><code>@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class Notepad{...}</code></pre><p>这里，使用ConfigurableBeanFactory类的<code>SCOPE_PROTOTYPE</code>常量设置了原型作用域。你当然也可以使用@Scope(“prototype”)，但是使用<code>SCOPE_PROTOTYPE</code>常量更加安全并且不易出错。</p><p>同样，@Scope注解也可以和@Bean注解一起使用:</p><pre><code>@Bean@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public Notepad notepad(){    return new Notepad();}</code></pre><p>同样，可以使用scope属性通过XML的方式配置其他作用域的bean:</p><pre><code>&lt;bean id=&quot;notepad&quot; class=&quot;com.carleviets.Notepad&quot; scope=&quot;prototype&quot;/&gt;</code></pre><h2 id="三、使用会话和请求作用域"><a href="#三、使用会话和请求作用域" class="headerlink" title="三、使用会话和请求作用域"></a>三、使用会话和请求作用域</h2><p>在典型的电子商务应用中，可能会有一个bean代表用户的购物车。如果购物车是单例的话，那么将会导致所有的用户都会向同一个购物车中添加商品。另一方面，如果购物车是原型作用域的，那么在应用中某一个地方往购物车中添加商品，在应用的另外一个地方可能就不可用了。就购物车bean来说，会话作用域是最为合适的，因为它与给定的用户关联性最大。</p><pre><code>@Component@Scope(value=WebApplicationContext.SCOPE_SESSION, proxyMode=ScopedProxyMode.INTERFACES)public class ShoppingCart{...}</code></pre><p>注意,@Scope同时还有一个proxyMode属性，它被设置成了ScopedProxyMode.INTERFACES。这个属性解决了将会话或请求作用域的bean注入到单例bean中所遇到的问题。例如，如下的StoreService bean表示在线商店提供的服务:</p><pre><code>@Componentpublic class StoreService{    private ShoppingCart shoppingCart;    @Autowired    public void setShoppingCart(ShoppingCart shoppingCart){        this.shoppingCart=shoppingCart;    }    ...}</code></pre><p>因为StoreService是一个单例的bean，会在Spring应用上下文加载的时候创建。当它创建的时候， Spring会试图将ShoppingCart bean注入到setShoppingCart()方法中。但是ShoppingCart bean是会话作用域的，此时并不存在。直到某个用户进入系统，创建了会话之后，才会出现ShoppingCart实例。</p><p>如果使用了proxyMode=ScopedProxyMode.INTERFACES的话，Spring并不会将实际的ShoppingCart bean注入到StoreService中，而是会注入一个到ShoppingCart bean的代理，如图所示。这个代理会暴露与ShoppingCart相同的方法，所以StoreService会认为它就是一个购物车。但是，当StoreService调用ShoppingCart的方法时，代理会对其进行懒解析并将调用委托给会话作用域内真正的ShoppingCart bean。</p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fz6igknkjlj30r00dy78f.jpg" alt="avatar"></p><p>这是使用的是Spring基于接口的代理，但如果ShoppingCart是一个具体的类的话，Spring就没有办法创建基于接口的代理了。此时，它必须使用CGLib来生成基于类的代理。所以，如果bean类型是具体类的话，我们必须要将proxyMode属性设置为ScopedProxyMode.TARGET_CLASS，以此来表明要以生成目标类扩展的方式创建代理。</p><p>尽管这里主要关注了会话作用域，但是请求作用域的bean会面临相同的装配问题。因此，请求作用域的bean应该也以作用域代理的方式进行注入。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 四种作用域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>邮件发送实的现</title>
      <link href="/2019/01/13/%E4%BD%BF%E7%94%A8JDK%E5%92%8C%E4%BD%BF%E7%94%A8Spring%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E7%9A%84%E5%8F%91%E9%80%81/"/>
      <url>/2019/01/13/%E4%BD%BF%E7%94%A8JDK%E5%92%8C%E4%BD%BF%E7%94%A8Spring%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E7%9A%84%E5%8F%91%E9%80%81/</url>
      
        <content type="html"><![CDATA[<h3 id="一、邮件发送相关的协议"><a href="#一、邮件发送相关的协议" class="headerlink" title="一、邮件发送相关的协议"></a>一、邮件发送相关的协议</h3><pre><code>SMTP： 简单邮件传输协议（Simple Mail Transfer Protocol），该协议定义了邮件发送的机制。POP3：邮局协议（Post Office Protocol），目前用的是版本3，也称POP3。POP3协议定义了接收电子邮件的标准。IMAP： 互联网消息协议(Internet Message Access Protocol)，是更高级的用于接收消息的协议，作为POP3的替代。MIME： 代表多用途因特网邮件扩展标准（Multipurpose Internet Mail Extensions） 。 它不是邮件传输协议。 但对传输内容的消息、       附件及其它的内容定义了格式。</code></pre><h3 id="二、JavaMail中的关键属性"><a href="#二、JavaMail中的关键属性" class="headerlink" title="二、JavaMail中的关键属性"></a>二、JavaMail中的关键属性</h3><pre><code>属性名                                   属性类型                             说明mail.smtp.host                              String                 SMTP服务器地址， 如smtp.sina.com.cnmail.smtp.port                           int                     SMTP服务器端口号，默认为 25mail.smtp.auth                              boolean                 SMTP服务器是否需要用户认证，默认为 falsemail.smtp.user                              String                 SMTP默认的登陆用户名mail.smtp.from                              String                 默认的邮件发送源地址mail.smtp.socketFactory.class             String                 socket工厂类类名， 通过设置该属性可以覆盖提供者默认的实现，                                                                必须实现 javax.NET.SocketFactory接口mail.smtp.socketFactory.port              int                       指定 socket 工厂类所用的端口号，如果没有规定， 则使用默认的端口号mail.smtp.socketFactory.fallback          boolean                 设置为 true时，当使用指定的socket类创建socket失败后，将使用                                                                Java.net.Socket 创建 socket， 默认为 truemail.smtp.timeout                          int                     I/O连接超时时间， 单位为毫秒，默认为永不超时</code></pre><h3 id="三、JavaMail中的关键对象"><a href="#三、JavaMail中的关键对象" class="headerlink" title="三、JavaMail中的关键对象"></a>三、JavaMail中的关键对象</h3><h4 id="3-1-Session对象"><a href="#3-1-Session对象" class="headerlink" title="3.1 Session对象"></a>3.1 Session对象</h4><p>创建 Session 对象时，并没有对应的物理连接， 它只不过是一对配置信息的集合。 Session 的主要作用包括两个方面：</p><pre><code>1） 接收各种配置属性信息：通过 Properties 对象设置的属性信息；2） 初始化JavaMail环境：根据JavaMail的配置文件，初始化JavaMail环境，以便通过Session对象创建其他重要类的实例。</code></pre><h4 id="3-2-Transport对象和Store对象"><a href="#3-2-Transport对象和Store对象" class="headerlink" title="3.2 Transport对象和Store对象"></a>3.2 Transport对象和Store对象</h4><p>Transport对象对应着邮件的发送，而Store对象对应着邮件的接收。</p><h4 id="3-3-Message对象"><a href="#3-3-Message对象" class="headerlink" title="3.3 Message对象"></a>3.3 Message对象</h4><p>Message对象即为用户发送的邮件，由于Messa类是一个抽象类，多数情况下使用其子类为javax.mail.internet.MimeMessage。MimeMessage是个能理解MIME类型和头的电子邮件消息。</p><h4 id="3-4-Address对象"><a href="#3-4-Address对象" class="headerlink" title="3.4 Address对象"></a>3.4 Address对象</h4><p>Address对象是邮件发送的地址，和Message一样，Address也是个抽象类。您用的是javax.mail.internet.InternetAddress类。</p><h4 id="3-5-Authenticator对象"><a href="#3-5-Authenticator对象" class="headerlink" title="3.5 Authenticator对象"></a>3.5 Authenticator对象</h4><p>JavaMail API利用Authenticator通过用户名和密码访问受保护的资源。对于JavaMail API来说，这些资源就是邮件服务器。</p><p>要使用 Authenticator，先创建一个抽象类的子类，并从getPasswordAuthentication()方法中返回PasswordAuthentication实例。 创建完<br>成后，您必需向session注册Authenticator。然后，在需要认证的时候，就会通知Authenticator。</p><h3 id="三、使用JDK实现邮件的发送功能"><a href="#三、使用JDK实现邮件的发送功能" class="headerlink" title="三、使用JDK实现邮件的发送功能"></a>三、使用JDK实现邮件的发送功能</h3><p>下面是通过JDK的方式实现邮件发送功能的代码：</p><pre><code>package com.carleviets.jdk;import com.carleviets.auth.MyAuthenticator;import javax.activation.DataHandler;import javax.activation.FileDataSource;import javax.mail.*;import javax.mail.internet.*;import java.io.File;import java.io.UnsupportedEncodingException;import java.util.Date;import java.util.Properties;/** *  通过JDK的方式发送邮件 */public class SendMail {    /**     * 发送一封带附件的html邮件     *  1、设置配置信息     *  2、创建Session对象，添加配置和授权     *  3、设置收件人、发件人和邮件信息     *  4、发送邮件     */    public void test() throws MessagingException, UnsupportedEncodingException {        //===============设置配置信息===============        //定义邮箱服务器配置        Properties properties=new Properties();        //163   邮件服务器地址        properties.put(&quot;mail.smtp.host&quot;, &quot;smtp.163.com&quot;);        //163   邮件服务器端口        properties.put(&quot;mail.smtp.port&quot;, &quot;25&quot;);        //163   邮件服务器认证属性        properties.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;);        //===============创建Session会话，添加配置和授权===============        Session session=Session.getInstance(properties,                new MyAuthenticator(&quot;carleviets0420@163.com&quot;, &quot;carleviets0318&quot;));        //===============设置收件人、发件人和邮件信息===============        Message message=new MimeMessage(session);        message.setFrom(new InternetAddress(&quot;carleviets0420@163.com&quot;)); //设置发件人邮箱地址        message.setRecipient(Message.RecipientType.TO, new InternetAddress(&quot;carleviets0420@163.com&quot;));  //设置收件人邮箱地址        //message.setRecipient(RecipientType.CC, new InternetAddress(&quot;xxx@163.com&quot;));//设置抄送人        //message.setRecipient(RecipientType.BCC, new InternetAddress(&quot;xxx@163.com&quot;));// 设置密送人        message.setSubject(&quot;我的第一封带附件的html邮件&quot;);  //设置主题        message.setSentDate(new Date());    //设置头部信息中的发件时间        Multipart multipart=new MimeMultipart();        //发送html邮件        BodyPart bodyPart1=new MimeBodyPart();        StringBuilder stringBuilder=new StringBuilder();        stringBuilder.append(&quot;&lt;html&gt;&lt;body&gt;&lt;a href=&#39;http://www.baidu.com&#39;&gt;狗日的百度&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&quot;);        bodyPart1.setContent(stringBuilder.toString(), &quot;text/html;charset=UTF-8&quot;);        multipart.addBodyPart(bodyPart1);        //发送带附件的邮件        BodyPart bodyPart2=new MimeBodyPart();        FileDataSource fileDataSource=new FileDataSource(new File(&quot;C:\\Users\\Administrator\\Desktop\\timg.jpg&quot;));        //设置附件        bodyPart2.setDataHandler(new DataHandler(fileDataSource));        //设置文件名——MimeUtility用于对文字进行Base64编码        bodyPart2.setFileName(MimeUtility.encodeText(&quot;高圆圆.jpg&quot;));        multipart.addBodyPart(bodyPart2);        message.setContent(multipart);        //===============发送邮件===============        Transport.send(message);    }}</code></pre><p>下面是实现邮箱认证的代码：</p><pre><code>package com.carleviets.auth;import javax.mail.Authenticator;import javax.mail.PasswordAuthentication;public class MyAuthenticator extends Authenticator {    private String username;    //邮箱名称    private String password;    //邮箱授权码    public MyAuthenticator(String username, String password) {        this.username = username;        this.password = password;    }    //重写Authenticator抽象类中的getPasswordAuthentication方法    @Override    protected PasswordAuthentication getPasswordAuthentication() {        return new PasswordAuthentication(username, password);    }}</code></pre><h3 id="四、JDK邮件发送代码的封装"><a href="#四、JDK邮件发送代码的封装" class="headerlink" title="四、JDK邮件发送代码的封装"></a>四、JDK邮件发送代码的封装</h3><p>如下是一个邮件发送信息类的简单封装，可以看出该类是一个简单的JavaBean：</p><pre><code>package com.carleviets.po.vo;import java.util.List;/** * 邮件发送信息类的简单封装 */public class MailSenderInfo {    private String serverHost;          //服务器主机    private String serverPort;          //服务器端口    private String fromAddress;         //发件人的邮箱地址    private List&lt;String&gt; toAddress;     //收件人邮箱地址    private String userName;            //邮件服务器用户名    private String userPwd;             //邮件服务器密码    private String subject;             //邮件主题    private String content;             //邮件内容    private String flag=&quot;true&quot;;          //邮件服务器认证属性    private List&lt;String&gt; attachFileNames;   //附件文件名    //===============getters and setters===============    ...}</code></pre><p>邮件发送具体类的实现如下:</p><pre><code>package com.carleviets.service;import com.carleviets.auth.MyAuthenticator;import com.carleviets.po.vo.MailSenderInfo;import javax.activation.DataHandler;import javax.activation.FileDataSource;import javax.mail.*;import javax.mail.internet.*;import java.io.File;import java.io.UnsupportedEncodingException;import java.util.Date;import java.util.List;import java.util.Properties;/** * 简单封装邮件发送器，实现邮件的发送 */public class MailSender {    public void sendHtmlMail(MailSenderInfo mailSendInfo){        Message message=null;        Session session=null;        try{            MyAuthenticator authenticator=new MyAuthenticator(mailSendInfo.getUserName(), mailSendInfo.getUserPwd());            //===============定义邮箱服务器配置================            Properties properties=new Properties();            //163   邮件服务器地址            properties.put(&quot;mail.smtp.host&quot;, mailSendInfo.getServerHost());            //163   邮件服务器端口            properties.put(&quot;mail.smtp.port&quot;, mailSendInfo.getServerPort());            //163   邮件服务器认证属性            properties.put(&quot;mail.smtp.auth&quot;, mailSendInfo.getFlag());            //===============创建Session对象，添加配置和授权===============            session=Session.getInstance(properties, authenticator);            //===============设置收件人、发件人和邮件信息===============            message=new MimeMessage(session);            Address from=new InternetAddress(mailSendInfo.getFromAddress());            message.setFrom(from);            message.setSentDate(new Date());            if(mailSendInfo.getToAddress()!=null &amp;&amp; mailSendInfo.getToAddress().size()&gt;0){                Address[] addresses=new Address[mailSendInfo.getToAddress().size()];                for (int i=0;i&lt;mailSendInfo.getToAddress().size();i++){                    Address address=new InternetAddress(mailSendInfo.getToAddress().get(i));                    addresses[i]=address;                }                message.setRecipients(Message.RecipientType.TO, addresses); //设置收件人地址                message.setSubject(mailSendInfo.getSubject());                Multipart multipart=new MimeMultipart();                BodyPart bodyPart=new MimeBodyPart();                bodyPart.setContent(mailSendInfo.getContent(), &quot;text/html;charset=utf-8&quot;);                multipart.addBodyPart(bodyPart);                //附件添加                List&lt;String&gt; files=mailSendInfo.getAttachFileNames();                if(files!=null&amp;&amp; files.size()&gt;0){                    for(int i=0;i&lt;files.size();i++){                        File tempFile=new File(files.get(i));                        if(tempFile.exists()){                            BodyPart temp=new MimeBodyPart();                            temp.setDataHandler(new DataHandler(new FileDataSource(tempFile)));                            temp.setFileName(MimeUtility.encodeText(tempFile.getName()));   //设置文件名                            multipart.addBodyPart(temp);    //添加附件                        }                    }                }                //设置邮件内容                message.setContent(multipart);                //===============发送邮件===============                Transport.send(message);            }        } catch (AddressException e) {            e.printStackTrace();        } catch (MessagingException e) {            e.printStackTrace();        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        }    }}</code></pre><p>测试代码很简单，这里略去。</p><h3 id="五、使用spring来实现邮件的发送"><a href="#五、使用spring来实现邮件的发送" class="headerlink" title="五、使用spring来实现邮件的发送"></a>五、使用spring来实现邮件的发送</h3><h4 id="5-1-maven坐标依赖"><a href="#5-1-maven坐标依赖" class="headerlink" title="5.1 maven坐标依赖"></a>5.1 maven坐标依赖</h4><pre><code>&lt;!--junit测试依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;junit&lt;/groupId&gt;  &lt;artifactId&gt;junit&lt;/artifactId&gt;  &lt;version&gt;4.12&lt;/version&gt;  &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--spring-test测试--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-test&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring核心依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring 上下文环境支持--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--java mail邮件发送--&gt;&lt;dependency&gt;  &lt;groupId&gt;javax.mail&lt;/groupId&gt;  &lt;artifactId&gt;mail&lt;/artifactId&gt;  &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="5-2-spring-xml具体配置"><a href="#5-2-spring-xml具体配置" class="headerlink" title="5.2 spring.xml具体配置"></a>5.2 spring.xml具体配置</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--配置JavaMailSenderImpl bean--&gt;    &lt;bean id=&quot;mailSender&quot; class=&quot;org.springframework.mail.javamail.JavaMailSenderImpl&quot;&gt;        &lt;property name=&quot;host&quot; value=&quot;smtp.163.com&quot;/&gt;        &lt;property name=&quot;port&quot; value=&quot;25&quot;/&gt;        &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;carleviets0420@163.com&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;carleviets0318&quot;/&gt;        &lt;property name=&quot;javaMailProperties&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;mail.smtp.auth&quot;&gt;true&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!--this is a template message that we can preload with a default state--&gt;    &lt;!--配置SimpleMailMessage bean--&gt;    &lt;bean id=&quot;templateMessage&quot; class=&quot;org.springframework.mail.SimpleMailMessage&quot;&gt;        &lt;property name=&quot;from&quot; value=&quot;carleviets0420@163.com&quot;/&gt;        &lt;property name=&quot;subject&quot; value=&quot;spring email&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置发送邮件的bean--&gt;    &lt;bean id=&quot;mailManager&quot; class=&quot;com.carleviets.springimpl.SimpleMailManager&quot;&gt;        &lt;property name=&quot;mailSender&quot; ref=&quot;mailSender&quot;/&gt;        &lt;property name=&quot;mailMessage&quot; ref=&quot;templateMessage&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h4 id="5-3定义邮件发送接口"><a href="#5-3定义邮件发送接口" class="headerlink" title="5.3定义邮件发送接口"></a>5.3定义邮件发送接口</h4><pre><code>package com.carleviets.springInterface;/** *  发送邮件接口的定义 */public interface MailManager {    void placeMail();}</code></pre><h4 id="5-4定义邮件发送接口"><a href="#5-4定义邮件发送接口" class="headerlink" title="5.4定义邮件发送接口"></a>5.4定义邮件发送接口</h4><pre><code>package com.carleviets.springimpl;import com.carleviets.springInterface.MailManager;import org.springframework.mail.MailException;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSenderImpl;/** * 发送邮件的简单实现类——在发送邮件的方法中实现发送邮件的代码 */public class SimpleMailManager implements MailManager {    @Autowired    private JavaMailSenderImpl mailSender;    @Autowired    private SimpleMailMessage mailMessage;    @Override    public void placeMail() {        mailMessage.setTo(&quot;carleviets0420@163.com&quot;);        mailMessage.setText(&quot;江火似流萤...&quot;);        try{            mailSender.send(message);        }catch (MailException ex){            System.err.println(ex.getMessage());        }    }}</code></pre><p>普通邮件测试代码如下：</p><pre><code>@Testpublic void test(){    mailManager.placeMail();}</code></pre><h4 id="5-5使用spring发送带附件的邮件"><a href="#5-5使用spring发送带附件的邮件" class="headerlink" title="5.5使用spring发送带附件的邮件"></a>5.5使用spring发送带附件的邮件</h4><p>使用spring发送带附件的邮件步骤和普通邮件一样，只是需要借助MimeMessageHelper辅助类来设置消息的属性。具体测试代码如下：</p><pre><code>/** * 测试通过spring发送带有附件的邮件 * @throws MessagingException */@Testpublic void test() throws MessagingException {    ApplicationContext applicationContext=            new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);    JavaMailSender mailSender= (JavaMailSender) applicationContext.getBean(&quot;mailSender&quot;);    MimeMessage message=mailSender.createMimeMessage();    message.setSubject(&quot;spring mail file&quot;);    //创建带有附件的消息帮助类    MimeMessageHelper helper=new MimeMessageHelper(message, true, &quot;utf-8&quot;);    helper.setTo(new InternetAddress(&quot;carleviets0420@163.com&quot;));    //设置接收人    helper.setText(&quot;Thank you for ordering!&quot;);    helper.setFrom(&quot;carleviets0420@163.com&quot;);    helper.addAttachment(&quot;timg.jpg&quot;, new File(&quot;C:\\Users\\Administrator\\Desktop\\timg.jpg&quot;));    mailSender.send(message);}</code></pre><p>至此，我们就实现了通过JDK的方式和通过Spring Mail的方式来实现邮件的发送。</p>]]></content>
      
      
      <categories>
          
          <category> Java Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 邮件发送 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用工具类总结</title>
      <link href="/2019/01/13/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/13/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1-1、AssertUtil"><a href="#1-1、AssertUtil" class="headerlink" title="1.1、AssertUtil"></a>1.1、AssertUtil</h3><p>该实用工具类主要通过断言的思想，在相应的条件成立下，通过抛出异常的方式来阻止代码的继续执行，可以在很多情况下将需要好几行的代码浓缩为只有一行代码，并且可以配合全局异常处理器的使用来将异常处理集中到处理器中。具体如下:</p><pre><code>package com.carleviets.crm.utils;import com.carleviets.crm.exceptions.LoginException;import com.carleviets.crm.exceptions.ParamsException;public class AssertUtil {    public static void isTrue(Boolean flag, String msg){        if(flag){            throw new ParamsException(msg);        }    }    public static void isTrue(Boolean flag, Integer code, String msg){        if(flag){            throw new ParamsException(code, msg);        }    }    public static void isNotLogin(Boolean flag, String msg) {        if(flag){            throw new LoginException(msg);        }    }}</code></pre><h3 id="1-2、JsonUtil"><a href="#1-2、JsonUtil" class="headerlink" title="1.2、JsonUtil"></a>1.2、JsonUtil</h3><p>该实用工具类主要用于将java对象以JSON字符串的形式响应给客户端，具体代码如下：</p><pre><code>package com.carleviets.crm.utils;import com.alibaba.fastjson.JSON;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class JsonUtil {    /**     * 将对象转换为json字符串并发送到前台     * @param object     * @param response     */    public static void toJson(Object object, HttpServletResponse response){        try {            //将对象转换为json字符串            String jsonStr= JSON.toJSONString(object);            //设置响应类型及编码            response.setContentType(&quot;application/json;charset=utf-8&quot;);            //得到输出流            PrintWriter out=response.getWriter();            out.write(jsonStr);            out.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><h3 id="1-3、MD5Util"><a href="#1-3、MD5Util" class="headerlink" title="1.3、MD5Util"></a>1.3、MD5Util</h3><p>该实用工具类主要用于对字符串进行MD5加密，具体代码如下:</p><pre><code>package com.carleviets.crm.utils;import org.apache.commons.codec.binary.Base64;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class MD5Util {    public static String encode(String str){        String value=&quot;&quot;;        try {            //得到MD5加密的算法程序            MessageDigest messageDigest=MessageDigest.getInstance(&quot;MD5&quot;);            //对字符串进行MD5加密，返回byte数组            byte[] bytes=messageDigest.digest(str.getBytes());            //使用Base64对byte数组进行编码            value=Base64.encodeBase64String(bytes);        } catch (NoSuchAlgorithmException e) {            e.printStackTrace();        }        return value;    }    public static void main(String[] args) {        System.out.println(encode(&quot;12345&quot;));    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用工具类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM整合依赖及配置总结</title>
      <link href="/2019/01/13/SSM%E6%95%B4%E5%90%88%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/13/SSM%E6%95%B4%E5%90%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、所需引入的maven依赖"><a href="#一、所需引入的maven依赖" class="headerlink" title="一、所需引入的maven依赖"></a>一、所需引入的maven依赖</h2><h3 id="1-1测试依赖"><a href="#1-1测试依赖" class="headerlink" title="1.1测试依赖"></a>1.1测试依赖</h3><pre><code>&lt;!--junit测试依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;junit&lt;/groupId&gt;  &lt;artifactId&gt;junit&lt;/artifactId&gt;  &lt;version&gt;4.12&lt;/version&gt;  &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--spring测试依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-test&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-2-spring核心依赖"><a href="#1-2-spring核心依赖" class="headerlink" title="1.2 spring核心依赖"></a>1.2 spring核心依赖</h3>   <!--spring上下文依赖--><pre><code>&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectj切面代理--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;  &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;  &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-3-数据库相关"><a href="#1-3-数据库相关" class="headerlink" title="1.3 数据库相关"></a>1.3 数据库相关</h3><pre><code>&lt;!--spring jdbc--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring 事务管理--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--c3p0连接池--&gt;&lt;dependency&gt;  &lt;groupId&gt;com.mchange&lt;/groupId&gt;  &lt;artifactId&gt;c3p0&lt;/artifactId&gt;  &lt;version&gt;0.9.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis核心依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;  &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis与spring整合依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;  &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql数据库驱动包--&gt;&lt;dependency&gt;  &lt;groupId&gt;mysql&lt;/groupId&gt;  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  &lt;version&gt;8.0.11&lt;/version&gt;&lt;/dependency&gt;    &lt;!--mybatis分页插件--&gt;&lt;dependency&gt;  &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;  &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;  &lt;version&gt;4.1.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-4-日志打印"><a href="#1-4-日志打印" class="headerlink" title="1.4 日志打印"></a>1.4 日志打印</h3><pre><code>&lt;!--日志打印相关jar--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;  &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;  &lt;version&gt;1.7.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;  &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;  &lt;version&gt;1.7.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-5-spring-mvc依赖"><a href="#1-5-spring-mvc依赖" class="headerlink" title="1.5 spring-mvc依赖"></a>1.5 spring-mvc依赖</h3><pre><code>&lt;!--spring web--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-web&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring webmvc--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring mvc上下文支持 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--web servlet--&gt;&lt;dependency&gt;  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;  &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;  &lt;version&gt;3.0.1&lt;/version&gt;  &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;</code></pre><h3 id="1-6-json支持"><a href="#1-6-json支持" class="headerlink" title="1.6 json支持"></a>1.6 json支持</h3><pre><code>&lt;!--json依赖jar--&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;  &lt;version&gt;2.9.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;  &lt;version&gt;2.9.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;  &lt;version&gt;2.9.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--阿里巴巴 fastjson --&gt;&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-7-Apache-commons文件上传支持"><a href="#1-7-Apache-commons文件上传支持" class="headerlink" title="1.7 Apache-commons文件上传支持"></a>1.7 Apache-commons文件上传支持</h3><pre><code>&lt;!--commons文件上传--&gt;&lt;dependency&gt;  &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;  &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;  &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-8其他工具包"><a href="#1-8其他工具包" class="headerlink" title="1.8其他工具包"></a>1.8其他工具包</h3><pre><code>&lt;!-- commons-lang3实用工具类 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;  &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;  &lt;version&gt;3.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Base64编码解码支持 --&gt;&lt;dependency&gt;  &lt;groupId&gt;commons-codec&lt;/groupId&gt;  &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;  &lt;version&gt;1.10&lt;/version&gt;&lt;/dependency&gt;&lt;!-- freemarker视图模板 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.freemarker&lt;/groupId&gt;  &lt;artifactId&gt;freemarker&lt;/artifactId&gt;  &lt;version&gt;2.3.23&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>###1.9其他配置###</p><pre><code>&lt;!--指定资源访问路径，默认情况下为src/main/resources目录--&gt;&lt;resources&gt;  &lt;resource&gt;    &lt;directory&gt;src/main/resources/${env}&lt;/directory&gt;  &lt;/resource&gt;  &lt;resource&gt;    &lt;directory&gt;src/main/java&lt;/directory&gt;    &lt;includes&gt;      &lt;include&gt;**/*.xml&lt;/include&gt;      &lt;include&gt;**/*.properties&lt;/include&gt;      &lt;include&gt;**/*.tld&lt;/include&gt;    &lt;/includes&gt;    &lt;filtering&gt;false&lt;/filtering&gt;  &lt;/resource&gt;&lt;/resources&lt;plugins&gt;  &lt;!--如果用到了Base64编码，需要指定编译的虚拟机--&gt;  &lt;plugin&gt;    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;    &lt;configuration&gt;      &lt;source&gt;1.8&lt;/source&gt;      &lt;target&gt;1.8&lt;/target&gt;      &lt;encoding&gt;utf-8&lt;/encoding&gt;      &lt;compilerArguments&gt;        &lt;bootclasspath&gt;${java.home}/lib/rt.jar&lt;/bootclasspath&gt;      &lt;/compilerArguments&gt;    &lt;/configuration&gt;  &lt;/plugin&gt;  &lt;!--jetty服务器插件--&gt;  &lt;plugin&gt;    &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;    &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;    &lt;version&gt;6.1.25&lt;/version&gt;    &lt;configuration&gt;      &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt;      &lt;contextPath&gt;/crm&lt;/contextPath&gt;      &lt;webDefaultXml&gt;src/main/resources/${env}/webdefault.xml&lt;/webDefaultXml&gt;    &lt;/configuration&gt;  &lt;/plugin&gt;  &lt;!--mybatis代码自动生成插件--&gt;  &lt;plugin&gt;      &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;      &lt;version&gt;1.3.2&lt;/version&gt;      &lt;configuration&gt;        &lt;configurationFile&gt;src/main/resources/${env}/generatorConfig.xml&lt;/configurationFile&gt;        &lt;verbose&gt;true&lt;/verbose&gt;        &lt;overwrite&gt;true&lt;/overwrite&gt;      &lt;/configuration&gt;  &lt;/plugin&gt;&lt;/plugins&gt;&lt;!--配置不同的环境打包--&gt;&lt;profiles&gt;    &lt;!--默认开发环境--&gt;    &lt;profile&gt;      &lt;id&gt;dev&lt;/id&gt;      &lt;properties&gt;        &lt;env&gt;dev&lt;/env&gt;      &lt;/properties&gt;      &lt;!--此处指定哪个环境激活打包时就打哪个环境下的包--&gt;      &lt;activation&gt;        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;      &lt;/activation&gt;    &lt;/profile&gt;    &lt;!--测试环境--&gt;    &lt;profile&gt;      &lt;id&gt;test&lt;/id&gt;      &lt;properties&gt;        &lt;env&gt;test&lt;/env&gt;      &lt;/properties&gt;    &lt;/profile&gt;    &lt;!--生产环境--&gt;    &lt;profile&gt;      &lt;id&gt;product&lt;/id&gt;      &lt;properties&gt;        &lt;env&gt;product&lt;/env&gt;      &lt;/properties&gt;    &lt;/profile&gt;&lt;/profiles&gt;</code></pre><h2 id="二、配置文件总结"><a href="#二、配置文件总结" class="headerlink" title="二、配置文件总结"></a>二、配置文件总结</h2><h3 id="2-1-web-xml配置文件"><a href="#2-1-web-xml配置文件" class="headerlink" title="2.1 web.xml配置文件"></a>2.1 web.xml配置文件</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt;  &lt;!--配置ContextLoaderListener监听的上下文参数--&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;!--配置ContextLoaderListener上下文监听器--&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;!--配置字符过滤器--&gt;  &lt;filter&gt;    &lt;description&gt;char encoding filter&lt;/description&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;utf-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  &lt;!--配置spring-mvc前端控制器--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:servlet-context.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;!--注意次数映射路径不能为&quot;/*&quot;--&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><h3 id="2-2-spring-xml-配置文件"><a href="#2-2-spring-xml-配置文件" class="headerlink" title="2.2 spring.xml 配置文件"></a>2.2 spring.xml 配置文件</h3><p>该配置文件主要用于管理除了Controller层之外所有其它层的bean,配置如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:task=&quot;http://www.springframework.org/schema/task&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/task        http://www.springframework.org/schema/task/spring-task.xsd&quot;&gt;    &lt;!--开启组件扫描，通过注解的形式排除掉controller包--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets.crm&quot;&gt;        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;    &lt;/context:component-scan&gt;    &lt;!--指定数据库配置文件所在位置--&gt;    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;    &lt;!--配置c3p0数据源--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt;        &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置spring事务管理器并注入数据源--&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置事务通知--&gt;    &lt;tx:advice id=&quot;transactionInterceptor&quot; transaction-manager=&quot;transactionManager&quot;&gt;        &lt;tx:attributes&gt;            &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;load*&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;del*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!--通过aop切面配置事务管理--&gt;    &lt;aop:config&gt;        &lt;aop:pointcut id=&quot;servicePointCut&quot; expression=&quot;execution(* com.carleviets.crm.service..*.*(..))&quot;/&gt;        &lt;aop:advisor advice-ref=&quot;transactionInterceptor&quot; pointcut-ref=&quot;servicePointCut&quot;/&gt;    &lt;/aop:config&gt;    &lt;!--配置mybatis sqlSessionFactory bean--&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis.xml&quot;/&gt;        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/carleviets/crm/mapper/*.xml&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置mybatis包扫描器--&gt;    &lt;bean id=&quot;scannerConfigurer&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;!-- 扫描com.carleviets.crm.dao这个包以及它的子包下的所有映射接口类 --&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.carleviets.crm.dao&quot;/&gt;        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;    &lt;/bean&gt;    &lt;!--启用定时任务的注解驱动--&gt;    &lt;task:annotation-driven/&gt;&lt;/beans&gt;</code></pre><h3 id="2-2-servlet-context-xml-配置文件"><a href="#2-2-servlet-context-xml-配置文件" class="headerlink" title="2.2 servlet-context.xml 配置文件"></a>2.2 servlet-context.xml 配置文件</h3><p>该配置文件用于配置spring-mvc,即管理所谓的Controller层的bean，配置如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!--开启组件扫描,并且只扫描controller包--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets.crm.controller&quot;/&gt;    &lt;!--开启aspectj自动代理，由于controller层调用service层,service层dao层，故在此文件配置的aspectj自动代理可以代理其它层--&gt;    &lt;aop:aspectj-autoproxy/&gt;    &lt;!--配置freemarker配置--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;        &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/views/&quot;/&gt;        &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置freemarker视图解析器--&gt;    &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;&quot;/&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot;/&gt;        &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=utf-8&quot;/&gt;    &lt;/bean&gt;    &lt;!--mvc注解驱动并添加对响应json的支持, 可不配，内部自动提供--&gt;    &lt;mvc:annotation-driven&gt;        &lt;mvc:message-converters&gt;            &lt;!--返回信息为字符串时处理--&gt;            &lt;bean id=&quot;stringHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;/&gt;            &lt;!--将对象转化为json字符串--&gt;            &lt;bean id=&quot;jackson2HttpMessageConverter&quot; class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;/&gt;        &lt;/mvc:message-converters&gt;    &lt;/mvc:annotation-driven&gt;    &lt;!--配置对静态资源的放行处理 方式一--&gt;    &lt;!--&lt;mvc:default-servlet-handler/&gt;--&gt;    &lt;!--配置对静态资源的放行处理 方式二--&gt;    &lt;mvc:resources mapping=&quot;/statics/**&quot; location=&quot;/statics/&quot;/&gt;    &lt;!--配置拦截器--&gt;    &lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;            &lt;!--拦截所有路径--&gt;            &lt;mvc:mapping path=&quot;/**&quot;/&gt;            &lt;!--静态资源放行--&gt;            &lt;mvc:exclude-mapping path=&quot;/statics/**&quot;/&gt;            &lt;!--登录页面放行--&gt;            &lt;mvc:exclude-mapping path=&quot;/index&quot;/&gt;            &lt;!--登录操作放行--&gt;            &lt;mvc:exclude-mapping path=&quot;/user/login&quot;/&gt;            &lt;!--配置拦截器bean--&gt;            &lt;bean class=&quot;com.carleviets.crm.interceptor.LoginInterceptor&quot;/&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;&lt;/beans&gt;</code></pre><h3 id="2-3-mybatis-xml-配置文件"><a href="#2-3-mybatis-xml-配置文件" class="headerlink" title="2.3 mybatis.xml 配置文件"></a>2.3 mybatis.xml 配置文件</h3><p>该配置文件用于配置mybatis的别名扫描和分页插件配置，如果不需要别名和分页可不配置此文件。具体配置如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--配置mybatis别名包扫描--&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;com.carleviets.crm.po&quot;/&gt;    &lt;/typeAliases&gt;    &lt;!--配置mybatis分页插件--&gt;    &lt;plugins&gt;        &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt;            &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;            &lt;!-- 该参数默认为false --&gt;            &lt;!-- 设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用 --&gt;            &lt;!-- 和startPage中的pageNum效果一样 --&gt;            &lt;property name=&quot;offsetAsPageNum&quot; value=&quot;true&quot;/&gt;            &lt;!-- 该参数默认为false --&gt;            &lt;!-- 设置为true时，使用RowBounds分页会进行count查询 --&gt;            &lt;property name=&quot;rowBoundsWithCount&quot; value=&quot;true&quot;/&gt;            &lt;!-- 设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果 --&gt;            &lt;!-- （相当于没有执行分页查询，但是返回结果仍然是Page类型） --&gt;            &lt;property name=&quot;pageSizeZero&quot; value=&quot;true&quot;/&gt;            &lt;!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 --&gt;            &lt;!-- 启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;pages会查询最后一页 --&gt;            &lt;!-- 禁用合理化时，如果pageNum&lt;1或pageNum&gt;pages会返回空数据 --&gt;            &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt;            &lt;!-- 3.5.0版本可用 - 为了支持startPage(Object params)方法 --&gt;            &lt;!-- 增加了一个`params`参数来配置参数映射，用于从Map或ServletRequest中取值 --&gt;            &lt;!-- 可以配置pageNum,pageSize,count,pageSizeZero,reasonable,不配置映射的用默认值 --&gt;            &lt;property name=&quot;params&quot; value=&quot;pageNum=start;pageSize=limit;pageSizeZero=zero;reasonable=heli;count=contsql&quot;/&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/configuration&gt;</code></pre><h3 id="2-4-generatorConfig-xml-配置文件"><a href="#2-4-generatorConfig-xml-配置文件" class="headerlink" title="2.4 generatorConfig.xml 配置文件"></a>2.4 generatorConfig.xml 配置文件</h3><p>该配置文件用于mybatis代码的逆向生成，要使用mybatis代码自动生成的功能需要在pom.xml中配置mybatis代码自动生成插件，插件的引入如下:</p><pre><code>&lt;!--mybatis代码自动生成插件--&gt;  &lt;plugin&gt;      &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;      &lt;version&gt;1.3.2&lt;/version&gt;      &lt;configuration&gt;        &lt;configurationFile&gt;src/main/resources/${env}/generatorConfig.xml&lt;/configurationFile&gt;        &lt;verbose&gt;true&lt;/verbose&gt;        &lt;overwrite&gt;true&lt;/overwrite&gt;      &lt;/configuration&gt;  &lt;/plugin&gt;</code></pre><p>generatorConfig.xml 配置文件的具体配置如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;!--数据库驱动，此处的路径为maven仓库下mysql数据库驱动所对应的路径--&gt;    &lt;classPathEntry location=&quot;D:/apache-maven-3.6.0/Repositories/mysql/mysql-connector-java/8.0.11/mysql-connector-java-8.0.11.jar&quot;/&gt;    &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;    &lt;!--生成的代码中不需要注释--&gt;    &lt;commentGenerator&gt;        &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;        &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;    &lt;/commentGenerator&gt;    &lt;!--数据库链接地址、账号和密码--&gt;    &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/project?useSSL=false&amp;amp;serverTimezone=GMT%2B8&quot; userId=&quot;root&quot; password=&quot;12345&quot;&gt;    &lt;/jdbcConnection&gt;    &lt;javaTypeResolver&gt;        &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;    &lt;/javaTypeResolver&gt;    &lt;!--生成Model类存放位置，此处路径为项目下src/main/java的绝对路径--&gt;    &lt;javaModelGenerator targetPackage=&quot;com.carleviets.crm.po&quot; targetProject=&quot;C:/Users/Administrator/IdeaProjects/crm_2/src/main/java&quot;&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;    &lt;/javaModelGenerator&gt;    &lt;!--生成映射文件存放位置，此处路径为项目下src/main/java的绝对路径--&gt;    &lt;sqlMapGenerator targetPackage=&quot;com.carleviets.crm.mapper&quot; targetProject=&quot;C:/Users/Administrator/IdeaProjects/crm_2/src/main/java&quot;&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;    &lt;/sqlMapGenerator&gt;    &lt;!--生成Dao类存放位置，此处路径为项目下src/main/java的绝对路径--&gt;    &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.carleviets.crm.dao&quot; targetProject=&quot;C:/Users/Administrator/IdeaProjects/crm_2/src/main/java&quot;&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;    &lt;/javaClientGenerator&gt;    &lt;!--指定需要生成代码、映射文件、Mapper接口的表--&gt;    &lt;table tableName=&quot;t_customer&quot; domainObjectName=&quot;Customer&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><h3 id="2-5-其他配置文件"><a href="#2-5-其他配置文件" class="headerlink" title="2.5 其他配置文件"></a>2.5 其他配置文件</h3><p>数据库属性文件db.properties:</p><pre><code>jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/crm?useSSL=false&amp;serverTimezone=GMT%2B8jdbc.username=rootjdbc.password=12345</code></pre><p>日志打印文件log4j.properties：</p><pre><code>log4j.rootLogger=DEBUG, Console  #Consolelog4j.appender.Console=org.apache.log4j.ConsoleAppender  log4j.appender.Console.layout=org.apache.log4j.PatternLayout  log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n  log4j.logger.java.sql.ResultSet=INFO  log4j.logger.org.apache=INFO  log4j.logger.java.sql.Connection=DEBUG  log4j.logger.java.sql.Statement=DEBUG  log4j.logger.java.sql.PreparedStatement=DEBUG </code></pre>]]></content>
      
      
      <categories>
          
          <category> SSM整合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven依赖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM整合时高可用代码总结</title>
      <link href="/2019/01/13/SSM%E6%95%B4%E5%90%88%E6%97%B6%E9%AB%98%E5%8F%AF%E7%94%A8%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/13/SSM%E6%95%B4%E5%90%88%E6%97%B6%E9%AB%98%E5%8F%AF%E7%94%A8%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1、BaseDAO"><a href="#1、BaseDAO" class="headerlink" title="1、BaseDAO"></a>1、BaseDAO</h3><p>baseDAO是一个高可用的接口，里面集成了添加、查询、修改、删除等方法，在ssm集成的时候，任何继承了该接口的mapper接口就拥有了对应的操作响应数据的方法，可以在很大程度上减少代码的重复，其具体如下：</p><pre><code>package com.carleviets.crm.base;import org.springframework.dao.DataAccessException;import java.util.List;import java.util.Map;public interface BaseDAO&lt;T&gt; {    /**     * 添加记录     * @param entity     * @return     * @throws DataAccessException     */    Integer save(T entity)throws DataAccessException;    /**     * 批量添加记录     * @param entities     * @return     * @throws DataAccessException     */    Integer saveBatch(List&lt;T&gt; entities) throws DataAccessException;    /**     * 通过id查询     * @param id     * @return     * @throws DataAccessException     */    T queryById(Integer id) throws DataAccessException;    /**     * 参数化查询     * @param baseQuery     * @return     * @throws DataAccessException     */    List&lt;T&gt; queryByParams(BaseQuery baseQuery) throws DataAccessException;    /**     * 更新单条记录     * @param entity     * @return     * @throws DataAccessException     */    Integer update(T entity) throws DataAccessException;    /**     * 批量更新     * @param map     * @return     * @throws DataAccessException     */    Integer updateBatch(Map&lt;String, Object&gt; map) throws DataAccessException;    /**     * 通过id删除单条记录     * @param id     * @return     * @throws DataAccessException     */    Integer delete(Integer id) throws DataAccessException;    /**     * 批量删除记录     * @param ids     * @return     * @throws DataAccessException     */    Integer deleteBatch(Integer[] ids) throws DataAccessException;}</code></pre><h3 id="2、BaseService"><a href="#2、BaseService" class="headerlink" title="2、BaseService"></a>2、BaseService</h3><p>该实用工具类对查询，更新、删除、分页查询等常用的操作进行了封装，Service层只需要继承该实用工具类，就可以省去大量的重复代码，具体如下:</p><pre><code>package com.carleviets.crm.base;import com.carleviets.crm.utils.AssertUtil;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.dao.DataAccessException;import java.util.HashMap;import java.util.List;import java.util.Map;public class BaseService&lt;T&gt; {    @Autowired    private BaseDAO&lt;T&gt; baseDAO;    /**     * 添加单条记录     * @param entity     * @return     * @throws DataAccessException     */    public Integer save(T entity) throws DataAccessException{        return baseDAO.save(entity);    }    /**     * 批量添加记录     * @param entities     * @return     * @throws DataAccessException     */    public Integer saveBatch(List&lt;T&gt; entities) throws DataAccessException{        return baseDAO.saveBatch(entities);    }    /**     * 通过id查询     * @param id     * @return     * @throws DataAccessException     */    public T queryById(Integer id) throws DataAccessException{        AssertUtil.isTrue(id==null||id&lt;0, &quot;带查询的记录不存在&quot;);        return baseDAO.queryById(id);    }    /**     * 参数化查询     * @param baseQuery     * @return     * @throws DataAccessException     */    public PageInfo&lt;T&gt; queryByParams(BaseQuery baseQuery) throws DataAccessException{        PageHelper.startPage(baseQuery.getPageNum(), baseQuery.getPageSize());        List&lt;T&gt; entities = baseDAO.queryByParams(baseQuery);        return new PageInfo&lt;T&gt;(entities);    }    /**     * 参数化分页查询     * @param baseQuery     * @return     * @throws DataAccessException     */    public Map&lt;String, Object&gt; queryForPage(BaseQuery baseQuery) throws DataAccessException{        PageHelper.startPage(baseQuery.getPageNum(), baseQuery.getPageSize());        List&lt;T&gt; entities=baseDAO.queryByParams(baseQuery);        PageInfo&lt;T&gt; pageInfo=new PageInfo&lt;T&gt;(entities);        Map&lt;String, Object&gt; map=new HashMap&lt;&gt;();        map.put(&quot;total&quot;, pageInfo.getTotal());        map.put(&quot;rows&quot;, pageInfo.getList());        return map;    }    /**     * 更新单条记录     * @param entity     * @return     * @throws DataAccessException     */    public Integer update(T entity) throws DataAccessException{        return baseDAO.update(entity);    }    /**     * 批量更新记录     * @param map     * @return     * @throws DataAccessException     */    public Integer updateBatch(Map&lt;String, Object&gt; map) throws DataAccessException{        return baseDAO.updateBatch(map);    }    /**     * 删除单条记录     * @param id     * @return     * @throws DataAccessException     */    public Integer delete(Integer id) throws DataAccessException{        AssertUtil.isTrue(id==null||id&lt;=0||queryById(id)==null, &quot;待删除的记录不存在&quot;);        return baseDAO.delete(id);    }    /**     * 批量删除记录     * @param ids     * @return     * @throws DataAccessException     */    public Integer deleteBatch(Integer[] ids) throws DataAccessException{        AssertUtil.isTrue(ids==null||ids.length==0, &quot;请选择待删除的记录&quot;);        return baseDAO.deleteBatch(ids);    }}</code></pre><h3 id="3、BaseController"><a href="#3、BaseController" class="headerlink" title="3、BaseController"></a>3、BaseController</h3><p>该实用工具类封装了对于成功操作时返回ResultInfo对象的方法，并且通过@ModelAttribute注解可以在继承该实用工具类的每一个控制器方法执行前统一在request作用域中添加了上下文路径，省去了大量的重复代码：</p><pre><code>package com.carleviets.crm.base;import com.carleviets.crm.po.vo.ResultInfo;import org.springframework.web.bind.annotation.ModelAttribute;import javax.servlet.http.HttpServletRequest;public class BaseController {    public ResultInfo success(Integer code, String msg, Object result){        ResultInfo resultInfo=new ResultInfo();        resultInfo.setCode(code);        resultInfo.setMsg(msg);        resultInfo.setResult(result);        return resultInfo;    }    public ResultInfo success(Integer code, String msg){        ResultInfo resultInfo=new ResultInfo();        resultInfo.setCode(code);        resultInfo.setMsg(msg);        return resultInfo;    }    //此注解标注的方法会在每个Controller的方法执行之前执行    @ModelAttribute    public void preHandle(HttpServletRequest request){        request.setAttribute(&quot;ctx&quot;, request.getContextPath());    }}</code></pre><h3 id="3、BaseQuery"><a href="#3、BaseQuery" class="headerlink" title="3、BaseQuery"></a>3、BaseQuery</h3><p>这个不用多说，所有的参数查询前台都需要传递pageNum和pageSize这两个参数，但是对于具体的情况，可以具有其他不同的参数，该实用工具类就是对pageNum和pageSize这两个参数进行简单封装的JavaBean，所有的参数查询都可以继承该实用工具类：</p><pre><code>package com.carleviets.crm.base;public class BaseQuery {    private Integer pageNum;    private Integer pageSize;    public Integer getPageNum() {        return pageNum;    }    public void setPageNum(Integer pageNum) {        this.pageNum = pageNum;    }    public Integer getPageSize() {        return pageSize;    }    public void setPageSize(Integer pageSize) {        this.pageSize = pageSize;    }}</code></pre><h3 id="3、GlobalExceptionHandler全局异常处理器"><a href="#3、GlobalExceptionHandler全局异常处理器" class="headerlink" title="3、GlobalExceptionHandler全局异常处理器"></a>3、GlobalExceptionHandler全局异常处理器</h3><p>全局异常处理器是spring-mvc中异常集中处理的地方。配置全局异常处理器后，Controller中只需要关注代码正常执行的情况，而异常发生时由全局异常处理器来进行统一的处理，并且根据前台需要的是普通视图还是JSON字符串进行不同的响应，具体代码如下：</p><pre><code>package com.carleviets.crm.exceptions;import com.carleviets.crm.po.vo.ResultInfo;import com.carleviets.crm.utils.JsonUtil;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.lang.reflect.Method;@Componentpublic class GlobalExceptionResolver implements HandlerExceptionResolver {    /**     * @param request     * @param response     * @param target    调用的方法     * @param ex     * @return     */    @Override    public ModelAndView resolveException(HttpServletRequest request,                                         HttpServletResponse response,                                         Object target,                                         Exception ex) {        ModelAndView modelAndView=createDefaultModelAndView(request);        if(ex instanceof LoginException){            LoginException e= (LoginException) ex;            modelAndView.addObject(&quot;errorMsg&quot;, e.getMsg());        }        //如果目标方法是处理器方法的实例        if(target instanceof HandlerMethod){            HandlerMethod handlerMethod= (HandlerMethod) target;            Method method=handlerMethod.getMethod();            //@ResponseBody注解区分前台是需要json数据还是视图            ResponseBody annotation = method.getAnnotation(ResponseBody.class);            if(annotation==null){                //普通页面请求                if(ex instanceof ParamsException){                    ParamsException e= (ParamsException) ex;                    modelAndView.addObject(&quot;errorMsg&quot;, e.getMsg());                }else{                    modelAndView.addObject(&quot;errorMsg&quot;, &quot;系统繁忙&quot;);                }                return modelAndView;            }else{                //前台需要json数据                ResultInfo resultInfo=new ResultInfo();                if(ex instanceof ParamsException){                    ParamsException e= (ParamsException) ex;                    resultInfo.setCode(e.getCode());                    resultInfo.setMsg(e.getMsg());                }else{                    resultInfo.setCode(417);                    resultInfo.setMsg(&quot;系统繁忙&quot;);                }                //将resultInfo转化为json数据发送到前台                JsonUtil.toJson(resultInfo, response);            }        }        return null;    }    private ModelAndView createDefaultModelAndView(HttpServletRequest request) {        ModelAndView modelAndView=new ModelAndView();        modelAndView.setViewName(&quot;error&quot;);  //设置视图名称        modelAndView.addObject(&quot;ctx&quot;, request.getContextPath());        return modelAndView;    }}</code></pre><h3 id="4、spring-mvc中拦截器实现对特定请求的拦截"><a href="#4、spring-mvc中拦截器实现对特定请求的拦截" class="headerlink" title="4、spring-mvc中拦截器实现对特定请求的拦截"></a>4、spring-mvc中拦截器实现对特定请求的拦截</h3><p>在spring-mvc中，可以通过拦截器实现对特定请求的拦截，如：拦截用户登录等。下面是一个拦截用户登录的代码：</p><pre><code>package com.carleviets.crm.interceptor;import com.carleviets.crm.service.UserService;import com.carleviets.crm.utils.AssertUtil;import com.carleviets.crm.utils.LoginUserUtil;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class LoginInterceptor extends HandlerInterceptorAdapter {    @Autowired    private UserService userService;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        //从cookie中获取到userId        Integer userId= LoginUserUtil.releaseUserIdFromCookie(request);        AssertUtil.isNotLogin(userId==null||userService.queryById(userId)==null, &quot;用户未登录&quot;);        return true;    //true为放行，false为拦截    }}</code></pre><p>除了编写拦截器外，还需要在servlet-context.xml中显示配置拦截器的拦截路径，放行的资源和放行的操作等，这种方式粒度较粗，对应的配置如下：</p><pre><code>&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt;    &lt;mvc:interceptor&gt;        &lt;!--拦截所有路径--&gt;        &lt;mvc:mapping path=&quot;/**&quot;/&gt;        &lt;!--静态资源放行--&gt;        &lt;mvc:exclude-mapping path=&quot;/statics/**&quot;/&gt;        &lt;!--登录页面放行--&gt;        &lt;mvc:exclude-mapping path=&quot;/index&quot;/&gt;        &lt;!--登录操作放行--&gt;        &lt;mvc:exclude-mapping path=&quot;/user/login&quot;/&gt;        &lt;!--配置拦截器bean--&gt;        &lt;bean class=&quot;com.carleviets.crm.interceptor.LoginInterceptor&quot;/&gt;    &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;</code></pre><p>除了这种方式外，还可以通过spring中的AOP实现拦截操作。</p><h3 id="4、通过AOP代理实现拦截请求的操作"><a href="#4、通过AOP代理实现拦截请求的操作" class="headerlink" title="4、通过AOP代理实现拦截请求的操作"></a>4、通过AOP代理实现拦截请求的操作</h3><p>在spring中，可以通过前置通知和环绕通知来实现对特定请求的拦截。下面是基于特定的注解和环绕通知来实现没有对应权限的用户的拦截代码：</p><pre><code>package com.carleviets.crm.aop;import com.carleviets.crm.annotations.RequestPermission;import com.carleviets.crm.constants.CrmConstants;import com.carleviets.crm.utils.AssertUtil;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import javax.servlet.http.HttpSession;import java.lang.reflect.Method;import java.util.List;@Component@Aspectpublic class PermissionAdapter {    @Autowired    private HttpSession httpSession;    //声明切点     @Pointcut(&quot;@annotation(com.carleviets.crm.annotations.RequestPermission)&quot;)    public void cut(){}    //声明环绕通知    @Around(&quot;cut()&quot;)    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {        //通过连接点拿到方法签名        MethodSignature methodSignature= (MethodSignature) proceedingJoinPoint.getSignature();        //通过方法签名获取到该方法        Method method=methodSignature.getMethod();        //通过方法获取到特定的注解        RequestPermission annotation=method.getAnnotation(RequestPermission.class);        //通过注解获取到权限码值        String aclValue=annotation.aclValue();        //判断会话中储存的权限列表中是否包含该权限码        List&lt;String&gt; permissions= (List&lt;String&gt;) httpSession.getAttribute(CrmConstants.USER_PERMISSIONS);        AssertUtil.isTrue(permissions==null||!permissions.contains(aclValue), &quot;没有权限&quot;);        return proceedingJoinPoint.proceed();    }}</code></pre><p>其中，注解的定义如下：</p><pre><code>package com.carleviets.crm.annotations;import java.lang.annotation.*;@Target({ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface RequestPermission {    String aclValue() default &quot;&quot;;}</code></pre><p>控制器中的方法，@RequestPermission注解中的value值为需要访问控制器中该方法的权限码值，具体代码如下：</p><pre><code>@RequestPermission(aclValue = &quot;101001&quot;)@RequestMapping(&quot;/querySaleChancesByParams&quot;)public @ResponseBody Map&lt;String, Object&gt; querySaleChancesByParams(SaleChanceQuery saleChanceQuery,                                                                  @RequestParam(defaultValue = &quot;1&quot;) Integer page,                                                                  @RequestParam(defaultValue = &quot;10&quot;) Integer rows){    saleChanceQuery.setPageNum(page);    saleChanceQuery.setPageSize(rows);    return saleChanceService.queryForPage(saleChanceQuery);}</code></pre><p>通过AOP这种方式实现对特定请求的拦截，不需要在servlet-context.xml中进行任何的配置，并且控制的粒度更细，也是本人推荐使用的一种方式。</p>]]></content>
      
      
      <categories>
          
          <category> SSM整合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用工具类 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
