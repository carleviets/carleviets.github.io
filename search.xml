<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring mvc中的全局异常处理</title>
      <link href="/2019/01/16/Spring%20mvc%E4%B8%AD%E7%9A%84%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2019/01/16/Spring%20mvc%E4%B8%AD%E7%9A%84%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-mvc中的全局异常处理"><a href="#Spring-mvc中的全局异常处理" class="headerlink" title="Spring mvc中的全局异常处理"></a>Spring mvc中的全局异常处理</h1><p>在spring mvc中，对全局异常处理的支持有以下三种方式:</p><pre><code>1、使用Spring mvc提供的简单异常处理器 SimpleMappingExceptionResolver；2、实现Spring的异常处理接口 HandlerExceptionResolver 自定义自己的异常处理器;3、使用@ExceptionHandler 注解实现异常处理；4、控制器通知和@ExceptionHandler注解结合使用</code></pre><h2 id="一、使用SimpleMappingExceptionResolver进行异常处理"><a href="#一、使用SimpleMappingExceptionResolver进行异常处理" class="headerlink" title="一、使用SimpleMappingExceptionResolver进行异常处理"></a>一、使用SimpleMappingExceptionResolver进行异常处理</h2><p>使用Spring中的自带的SimpleMappingExceptionResolver类进行异常处理，具有集成简单、扩展性好、对已有代码没有侵入性等优点，但该方法仅能获取到异常信息，若在出现异常时，对需要获取除异常以外的数据的情况不适用。要使用SimpleMappingExceptionResolver，需要配置bean:</p><pre><code>&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;    &lt;!-- 为所有的异常定义默认的异常处理页面，exceptionMappings未定义的异常使用本默认配置 --&gt;    &lt;property name=&quot;defaultErrorView&quot; value=&quot;error&quot;/&gt;    &lt;!-- 定义异常处理页面用来获取异常信息的变量名，默认名为exception --&gt;    &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;/&gt;    &lt;!--定义需要特殊处理的异常，用类名或完全路径名作为key，异常页文件名作为值，将不同的异常映射到不同的页面上。--&gt;    &lt;property name=&quot;exceptionMappings&quot;&gt;        &lt;props&gt;            &lt;prop key=&quot;com.carleviets.exception.BusinessException&quot;&gt;business_error&lt;/prop&gt;            &lt;prop key=&quot;com.carleviets.exception.ParamsException&quot;&gt;params_error&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p>一个典型的异常显示界面如下：</p><pre><code>&lt;html&gt; &lt;head&gt;&lt;title&gt;Exception!&lt;/title&gt;&lt;/head&gt; &lt;body&gt; 　　&lt;% Exception e = (Exception)request.getAttribute(&quot;ex&quot;); %&gt; 　　&lt;H2&gt;Exception: &lt;%= e.getMessage();%&gt;&lt;/H2&gt; 　　&lt;P/&gt; 　　&lt;% e.printStackTrace(new java.io.PrintWriter(out)); %&gt; &lt;/body&gt; &lt;/html&gt; </code></pre><p>exception 是在 SimpleMappingExceptionResolver 被存放到 request 中的，具体可以查看源代码。</p><h2 id="二、实现-HandlerExceptionResolver-接口"><a href="#二、实现-HandlerExceptionResolver-接口" class="headerlink" title="二、实现 HandlerExceptionResolver 接口"></a>二、实现 HandlerExceptionResolver 接口</h2><p>使用这种方式只需要实现 resolveException 方法，该方法返回一个 ModelAndView 对象，在方法内部对异常的类型进行判断，然后返回合适的 ModelAndView 对象，如果该方法返回 null，则 Spring 会继续寻找其他的实现了 HandlerExceptionResolver 接口的 Bean。换句话说，Spring 会搜索所有注册在其环境中的实现了 HandlerExceptionResolver 接口的 Bean，逐个执行，直到返回了一个 ModelAndView 对象。</p><pre><code>package com.carleviets.exceptions.handler;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.HashMap;import java.util.Map;public class MyExceptionHandler implements HandlerExceptionResolver {    /**     *     * @param request     * @param response     * @param target   被调用的方法     * @param ex       用来接收异常的局部变量名     * @return     */    @Override    public ModelAndView resolveException(HttpServletRequest request,                                         HttpServletResponse response, Object target, Exception ex) {        //此处定义的Map实际上就是Spring mvc中的Model(Model的内部实现就是一个Map)        Map&lt;String,Object&gt; map=new HashMap&lt;String, Object&gt;();        map.put(&quot;ex&quot;, ex);        if(ex instanceof ParamsException){            return new ModelAndView(&quot;error_param&quot;, map);        }        if(ex instanceof BusinessException){            return new ModelAndView(&quot;error_business&quot;, map);        }        return new ModelAndView(&quot;error&quot;, map);    }}</code></pre><p>要注意，实现HandlerExceptionResolver接口的类必须声明到 Spring 配置文件中，或者使用 @Component 标签，让 Spring 管理它。</p><h2 id="三、使用-ExceptionHandler-注解实现异常处理"><a href="#三、使用-ExceptionHandler-注解实现异常处理" class="headerlink" title="三、使用 @ExceptionHandler 注解实现异常处理"></a>三、使用 @ExceptionHandler 注解实现异常处理</h2><p>该方法需要定义在某个 Controller 内部，表示能够处理同一个控制器中所有处理器方法抛出的相应异常。@ExceptionHandler 中可以添加一个或多个异常的类型，如果为空的话则认为可以触发所有的异常类型错误。</p><pre><code>package com.carleviets.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.ExceptionHandler;import javax.servlet.http.HttpServletRequest;import java.io.IOException;@Controllerpublic class  BaseController {    @ExceptionHandler(value={ParamsException.class,BusinessException.class, IOException.class})    public String exp(HttpServletRequest request, Exception ex) {        request.setAttribute(&quot;ex&quot;, ex);        if(ex instanceof ParamsException){            return &quot;error_param&quot;;        }        if(ex instanceof BusinessException){            return &quot;error_business&quot;;        }        return &quot;error&quot;;    }} </code></pre><p>上面我们写了一个BaseController,所有继承了该类的控制器就可以实现相应异常的处理。但这种方式对代码具有侵入性，考虑到Java具有单继承多实现的特点，这种方式不推荐使用。</p><h2 id="四、使用控制器通知"><a href="#四、使用控制器通知" class="headerlink" title="四、使用控制器通知"></a>四、使用控制器通知</h2><p>控制器通知是Spring 3.2引入的一个新特性，通俗来讲，控制器通知（controller advice）是任意带有@ControllerAdvice注解的类，这个类会包含一个或多个如下类型的方法：</p><pre><code>@ExceptionHandler 注解标注的方法；@InitBinder 注解标注的方法；@ModelAttribute 注解标注的方法</code></pre><p>在带有@ControllerAdvice注解的类中，以上所述的这些方法会运用到整个应用程序所有控制器中带有@RequestMapping注解的方法上。下面是Spring中ControllerAdvice的源码:</p><pre><code>@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface ControllerAdvice {    @AliasFor(&quot;basePackages&quot;)    String[] value() default {};    @AliasFor(&quot;value&quot;)    String[] basePackages() default {};    Class&lt;?&gt;[] basePackageClasses() default {};    Class&lt;?&gt;[] assignableTypes() default {};    Class&lt;? extends Annotation&gt;[] annotations() default {};}</code></pre><p>@ControllerAdvice注解本身已经使用了@Component，因此@ControllerAdvice注解所标注的类将会自动被组件扫描获取到，就像带有@Component注解的类一样。控制器通知最为实用的一个场景就是将所有的@ExceptionHandler方法收集到一个类中，这样所有控制器的异常就能在一个地方进行一致的处理。如下:</p><pre><code>package com.carleviets.exceptions.handler;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;//定义控制器通知@ControllerAdvicepublic class GlobalExceptionHandler {    //定义异常处理方法    @ExceptionHandler(BusinessException.class)    public String businessExceptionHandle(){        return &quot;error_business&quot;;    }    //定义异常处理方法    @ExceptionHandler(ParamsException.class)    public String businessExceptionHandle(){        return &quot;params_business&quot;;    }}</code></pre><h2 id="五、将具体的异常映射为HTTP状态码"><a href="#五、将具体的异常映射为HTTP状态码" class="headerlink" title="五、将具体的异常映射为HTTP状态码"></a>五、将具体的异常映射为HTTP状态码</h2><p>在默认情况下， Spring会将自身的一些异常自动转换为合适的状态码。但是我们也可以通过@ResponseStatus将具体的异常隐射为具体的HTTP状态码。</p><pre><code>package com.carleviets.exceptions;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.ResponseStatus;@ResponseStatus(value = HttpStatus.NOT_FOUND, reason = &quot;文档不存在&quot;)public class DocumentNotFoundException extends RuntimeException {}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring定时任务的实现</title>
      <link href="/2019/01/14/Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2019/01/14/Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、通过xml的方式配置定时任务"><a href="#一、通过xml的方式配置定时任务" class="headerlink" title="一、通过xml的方式配置定时任务"></a>一、通过xml的方式配置定时任务</h2><p>以下是通过XML实现定时任务的具体Java代码:</p><pre><code>package com.carleviets;import org.springframework.stereotype.Component;@Componentpublic class TaskJob {    public void job01(){        System.out.println(&quot;job01...&quot;);    }    public void job02(){        System.out.println(&quot;job02...&quot;);    }}</code></pre><p>以下是使用XML配置定时任务时spring.xml的具体配置:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;   xmlns:task=&quot;http://www.springframework.org/schema/task&quot;   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd   http://www.springframework.org/schema/task   http://www.springframework.org/schema/task/spring-task.xsd&quot;&gt;    &lt;!--启动Spring组件扫描--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets&quot;/&gt;    &lt;!--XML的方式配置定时任务--&gt;    &lt;task:scheduled-tasks&gt;        &lt;task:scheduled ref=&quot;taskJob&quot; method=&quot;job01&quot; cron=&quot;0/5 * * * * ? &quot;/&gt;        &lt;task:scheduled ref=&quot;taskJob&quot; method=&quot;job02&quot; cron=&quot;0/2 * * * * ? &quot; /&gt;    &lt;/task:scheduled-tasks&gt;&lt;/beans&gt;</code></pre><h2 id="二、通过注解的方式配置定时任务"><a href="#二、通过注解的方式配置定时任务" class="headerlink" title="二、通过注解的方式配置定时任务"></a>二、通过注解的方式配置定时任务</h2><p>以下是通过注解的方式实现定时任务的具体Java代码：</p><pre><code>package com.carleviets;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;@Componentpublic class TaskJob {    @Scheduled(cron = &quot;0/5 * * * * ? &quot;)    public void job01(){        System.out.println(&quot;job03...&quot;);    }    @Scheduled(cron = &quot;0/2 * * * * ? &quot;)    public void job02(){        System.out.println(&quot;job04...&quot;);    }}</code></pre><p>以下是使用注解配置定时任务时spring.xml的具体配置:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;   xmlns:task=&quot;http://www.springframework.org/schema/task&quot;   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd   http://www.springframework.org/schema/task   http://www.springframework.org/schema/task/spring-task.xsd&quot;&gt;    &lt;!--启动Spring组件扫描--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets&quot;/&gt;      &lt;!--引入定时任务的注解驱动--&gt;       &lt;task:annotation-driven/&gt;&lt;/beans&gt;</code></pre><h2 id="三、分析总结"><a href="#三、分析总结" class="headerlink" title="三、分析总结"></a>三、分析总结</h2><p>不管是用过XML的方式还是通过注解的方式配置定时任务，都应该先引入spring-task的命名空间:</p><pre><code>xmlns:task=&quot;http://www.springframework.org/schema/taskhttp://www.springframework.org/schema/taskhttp://www.springframework.org/schema/task/spring-task.xsd</code></pre><p>其次，根据不同的情况来给定时任务的代码使用Cron表达式，具体Cron表达式的生成可参照: <a href="http://cron.qqe2.com/" target="_blank" rel="noopener">http://cron.qqe2.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Spring中的作用域问题</title>
      <link href="/2019/01/13/%E5%85%B3%E4%BA%8ESpring%E4%B8%ADbean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2019/01/13/%E5%85%B3%E4%BA%8ESpring%E4%B8%ADbean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="一、bean的四种作用域"><a href="#一、bean的四种作用域" class="headerlink" title="一、bean的四种作用域"></a>一、bean的四种作用域</h2><p>Spring定义了多种作用域，可以基于这些作用域创建bean，包括:</p><pre><code>单例（Singleton）：在整个应用中，只创建bean的一个实例。原型（Prototype）：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。会话（Session）：在Web应用中，为每个会话创建一个bean实例。请求（Rquest）：在Web应用中，为每个请求创建一个bean实例 </code></pre><p>在默认情况下， Spring应用上下文中所有bean都是作为以单例（singleton）的形式创建的。也就是说，不管给定的一个bean被注入到其他bean多少次，每次所注入的都是同一个实例。在大多数情况下，单例bean是很理想的方案。但是在某些情况下，你所使用的类是易变的（mutable），它们会保持一些状态，因此重用是不安全的。在这种情况下，将class声明为单例的bean就不是什么好主意了。</p><h2 id="二、使用其他作用域的bean"><a href="#二、使用其他作用域的bean" class="headerlink" title="二、使用其他作用域的bean"></a>二、使用其他作用域的bean</h2><p>要声明bean为其他作用域，可以使用@Scope注解，以下是用过@Scope注解和@Component注解一起使用，声明了一个原型作用域的bean：</p><pre><code>@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class Notepad{...}</code></pre><p>这里，使用ConfigurableBeanFactory类的<code>SCOPE_PROTOTYPE</code>常量设置了原型作用域。你当然也可以使用@Scope(“prototype”)，但是使用<code>SCOPE_PROTOTYPE</code>常量更加安全并且不易出错。</p><p>同样，@Scope注解也可以和@Bean注解一起使用:</p><pre><code>@Bean@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public Notepad notepad(){    return new Notepad();}</code></pre><p>同样，可以使用scope属性通过XML的方式配置其他作用域的bean:</p><pre><code>&lt;bean id=&quot;notepad&quot; class=&quot;com.carleviets.Notepad&quot; scope=&quot;prototype&quot;/&gt;</code></pre><h2 id="三、使用会话和请求作用域"><a href="#三、使用会话和请求作用域" class="headerlink" title="三、使用会话和请求作用域"></a>三、使用会话和请求作用域</h2><p>在典型的电子商务应用中，可能会有一个bean代表用户的购物车。如果购物车是单例的话，那么将会导致所有的用户都会向同一个购物车中添加商品。另一方面，如果购物车是原型作用域的，那么在应用中某一个地方往购物车中添加商品，在应用的另外一个地方可能就不可用了。就购物车bean来说，会话作用域是最为合适的，因为它与给定的用户关联性最大。</p><pre><code>@Component@Scope(value=WebApplicationContext.SCOPE_SESSION, proxyMode=ScopedProxyMode.INTERFACES)public class ShoppingCart{...}</code></pre><p>注意,@Scope同时还有一个proxyMode属性，它被设置成了ScopedProxyMode.INTERFACES。这个属性解决了将会话或请求作用域的bean注入到单例bean中所遇到的问题。例如，如下的StoreService bean表示在线商店提供的服务:</p><pre><code>@Componentpublic class StoreService{    private ShoppingCart shoppingCart;    @Autowired    public void setShoppingCart(ShoppingCart shoppingCart){        this.shoppingCart=shoppingCart;    }    ...}</code></pre><p>因为StoreService是一个单例的bean，会在Spring应用上下文加载的时候创建。当它创建的时候， Spring会试图将ShoppingCart bean注入到setShoppingCart()方法中。但是ShoppingCart bean是会话作用域的，此时并不存在。直到某个用户进入系统，创建了会话之后，才会出现ShoppingCart实例。</p><p>如果使用了proxyMode=ScopedProxyMode.INTERFACES的话，Spring并不会将实际的ShoppingCart bean注入到StoreService中，而是会注入一个到ShoppingCart bean的代理，如图所示。这个代理会暴露与ShoppingCart相同的方法，所以StoreService会认为它就是一个购物车。但是，当StoreService调用ShoppingCart的方法时，代理会对其进行懒解析并将调用委托给会话作用域内真正的ShoppingCart bean。</p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fz6igknkjlj30r00dy78f.jpg" alt="avatar"></p><p>这是使用的是Spring基于接口的代理，但如果ShoppingCart是一个具体的类的话，Spring就没有办法创建基于接口的代理了。此时，它必须使用CGLib来生成基于类的代理。所以，如果bean类型是具体类的话，我们必须要将proxyMode属性设置为ScopedProxyMode.TARGET_CLASS，以此来表明要以生成目标类扩展的方式创建代理。</p><p>尽管这里主要关注了会话作用域，但是请求作用域的bean会面临相同的装配问题。因此，请求作用域的bean应该也以作用域代理的方式进行注入。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>邮件的发送实现</title>
      <link href="/2019/01/13/%E4%BD%BF%E7%94%A8JDK%E5%92%8C%E4%BD%BF%E7%94%A8Spring%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E7%9A%84%E5%8F%91%E9%80%81/"/>
      <url>/2019/01/13/%E4%BD%BF%E7%94%A8JDK%E5%92%8C%E4%BD%BF%E7%94%A8Spring%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E7%9A%84%E5%8F%91%E9%80%81/</url>
      
        <content type="html"><![CDATA[<h3 id="一、邮件发送相关的协议"><a href="#一、邮件发送相关的协议" class="headerlink" title="一、邮件发送相关的协议"></a>一、邮件发送相关的协议</h3><pre><code>SMTP： 简单邮件传输协议（Simple Mail Transfer Protocol），该协议定义了邮件发送的机制。POP3：邮局协议（Post Office Protocol），目前用的是版本3，也称POP3。POP3协议定义了接收电子邮件的标准。IMAP： 互联网消息协议(Internet Message Access Protocol)，是更高级的用于接收消息的协议，作为POP3的替代。MIME： 代表多用途因特网邮件扩展标准（Multipurpose Internet Mail Extensions） 。 它不是邮件传输协议。 但对传输内容的消息、       附件及其它的内容定义了格式。</code></pre><h3 id="二、JavaMail中的关键属性"><a href="#二、JavaMail中的关键属性" class="headerlink" title="二、JavaMail中的关键属性"></a>二、JavaMail中的关键属性</h3><pre><code>属性名                                   属性类型                             说明mail.smtp.host                              String                 SMTP服务器地址， 如smtp.sina.com.cnmail.smtp.port                           int                     SMTP服务器端口号，默认为 25mail.smtp.auth                              boolean                 SMTP服务器是否需要用户认证，默认为 falsemail.smtp.user                              String                 SMTP默认的登陆用户名mail.smtp.from                              String                 默认的邮件发送源地址mail.smtp.socketFactory.class             String                 socket工厂类类名， 通过设置该属性可以覆盖提供者默认的实现，                                                                必须实现 javax.NET.SocketFactory接口mail.smtp.socketFactory.port              int                       指定 socket 工厂类所用的端口号，如果没有规定， 则使用默认的端口号mail.smtp.socketFactory.fallback          boolean                 设置为 true时，当使用指定的socket类创建socket失败后，将使用                                                                Java.net.Socket 创建 socket， 默认为 truemail.smtp.timeout                          int                     I/O连接超时时间， 单位为毫秒，默认为永不超时</code></pre><h3 id="三、JavaMail中的关键对象"><a href="#三、JavaMail中的关键对象" class="headerlink" title="三、JavaMail中的关键对象"></a>三、JavaMail中的关键对象</h3><h4 id="3-1-Session对象"><a href="#3-1-Session对象" class="headerlink" title="3.1 Session对象"></a>3.1 Session对象</h4><p>创建 Session 对象时，并没有对应的物理连接， 它只不过是一对配置信息的集合。 Session 的主要作用包括两个方面：</p><pre><code>1） 接收各种配置属性信息：通过 Properties 对象设置的属性信息；2） 初始化JavaMail环境：根据JavaMail的配置文件，初始化JavaMail环境，以便通过Session对象创建其他重要类的实例。</code></pre><h4 id="3-2-Transport对象和Store对象"><a href="#3-2-Transport对象和Store对象" class="headerlink" title="3.2 Transport对象和Store对象"></a>3.2 Transport对象和Store对象</h4><p>Transport对象对应着邮件的发送，而Store对象对应着邮件的接收。</p><h4 id="3-3-Message对象"><a href="#3-3-Message对象" class="headerlink" title="3.3 Message对象"></a>3.3 Message对象</h4><p>Message对象即为用户发送的邮件，由于Messa类是一个抽象类，多数情况下使用其子类为javax.mail.internet.MimeMessage。MimeMessage是个能理解MIME类型和头的电子邮件消息。</p><h4 id="3-4-Address对象"><a href="#3-4-Address对象" class="headerlink" title="3.4 Address对象"></a>3.4 Address对象</h4><p>Address对象是邮件发送的地址，和Message一样，Address也是个抽象类。您用的是javax.mail.internet.InternetAddress类。</p><h4 id="3-5-Authenticator对象"><a href="#3-5-Authenticator对象" class="headerlink" title="3.5 Authenticator对象"></a>3.5 Authenticator对象</h4><p>JavaMail API利用Authenticator通过用户名和密码访问受保护的资源。对于JavaMail API来说，这些资源就是邮件服务器。</p><p>要使用 Authenticator，先创建一个抽象类的子类，并从getPasswordAuthentication()方法中返回PasswordAuthentication实例。 创建完<br>成后，您必需向session注册Authenticator。然后，在需要认证的时候，就会通知Authenticator。</p><h3 id="三、使用JDK实现邮件的发送功能"><a href="#三、使用JDK实现邮件的发送功能" class="headerlink" title="三、使用JDK实现邮件的发送功能"></a>三、使用JDK实现邮件的发送功能</h3><p>下面是通过JDK的方式实现邮件发送功能的代码：</p><pre><code>package com.carleviets.jdk;import com.carleviets.auth.MyAuthenticator;import javax.activation.DataHandler;import javax.activation.FileDataSource;import javax.mail.*;import javax.mail.internet.*;import java.io.File;import java.io.UnsupportedEncodingException;import java.util.Date;import java.util.Properties;/** *  通过JDK的方式发送邮件 */public class SendMail {    /**     * 发送一封带附件的html邮件     *  1、设置配置信息     *  2、创建Session对象，添加配置和授权     *  3、设置收件人、发件人和邮件信息     *  4、发送邮件     */    public void test() throws MessagingException, UnsupportedEncodingException {        //===============设置配置信息===============        //定义邮箱服务器配置        Properties properties=new Properties();        //163   邮件服务器地址        properties.put(&quot;mail.smtp.host&quot;, &quot;smtp.163.com&quot;);        //163   邮件服务器端口        properties.put(&quot;mail.smtp.port&quot;, &quot;25&quot;);        //163   邮件服务器认证属性        properties.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;);        //===============创建Session会话，添加配置和授权===============        Session session=Session.getInstance(properties,                new MyAuthenticator(&quot;carleviets0420@163.com&quot;, &quot;carleviets0318&quot;));        //===============设置收件人、发件人和邮件信息===============        Message message=new MimeMessage(session);        message.setFrom(new InternetAddress(&quot;carleviets0420@163.com&quot;)); //设置发件人邮箱地址        message.setRecipient(Message.RecipientType.TO, new InternetAddress(&quot;carleviets0420@163.com&quot;));  //设置收件人邮箱地址        //message.setRecipient(RecipientType.CC, new InternetAddress(&quot;xxx@163.com&quot;));//设置抄送人        //message.setRecipient(RecipientType.BCC, new InternetAddress(&quot;xxx@163.com&quot;));// 设置密送人        message.setSubject(&quot;我的第一封带附件的html邮件&quot;);  //设置主题        message.setSentDate(new Date());    //设置头部信息中的发件时间        Multipart multipart=new MimeMultipart();        //发送html邮件        BodyPart bodyPart1=new MimeBodyPart();        StringBuilder stringBuilder=new StringBuilder();        stringBuilder.append(&quot;&lt;html&gt;&lt;body&gt;&lt;a href=&#39;http://www.baidu.com&#39;&gt;狗日的百度&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&quot;);        bodyPart1.setContent(stringBuilder.toString(), &quot;text/html;charset=UTF-8&quot;);        multipart.addBodyPart(bodyPart1);        //发送带附件的邮件        BodyPart bodyPart2=new MimeBodyPart();        FileDataSource fileDataSource=new FileDataSource(new File(&quot;C:\\Users\\Administrator\\Desktop\\timg.jpg&quot;));        //设置附件        bodyPart2.setDataHandler(new DataHandler(fileDataSource));        //设置文件名——MimeUtility用于对文字进行Base64编码        bodyPart2.setFileName(MimeUtility.encodeText(&quot;高圆圆.jpg&quot;));        multipart.addBodyPart(bodyPart2);        message.setContent(multipart);        //===============发送邮件===============        Transport.send(message);    }}</code></pre><p>下面是实现邮箱认证的代码：</p><pre><code>package com.carleviets.auth;import javax.mail.Authenticator;import javax.mail.PasswordAuthentication;public class MyAuthenticator extends Authenticator {    private String username;    //邮箱名称    private String password;    //邮箱授权码    public MyAuthenticator(String username, String password) {        this.username = username;        this.password = password;    }    //重写Authenticator抽象类中的getPasswordAuthentication方法    @Override    protected PasswordAuthentication getPasswordAuthentication() {        return new PasswordAuthentication(username, password);    }}</code></pre><h3 id="四、JDK邮件发送代码的封装"><a href="#四、JDK邮件发送代码的封装" class="headerlink" title="四、JDK邮件发送代码的封装"></a>四、JDK邮件发送代码的封装</h3><p>如下是一个邮件发送信息类的简单封装，可以看出该类是一个简单的JavaBean：</p><pre><code>package com.carleviets.po.vo;import java.util.List;/** * 邮件发送信息类的简单封装 */public class MailSenderInfo {    private String serverHost;          //服务器主机    private String serverPort;          //服务器端口    private String fromAddress;         //发件人的邮箱地址    private List&lt;String&gt; toAddress;     //收件人邮箱地址    private String userName;            //邮件服务器用户名    private String userPwd;             //邮件服务器密码    private String subject;             //邮件主题    private String content;             //邮件内容    private String flag=&quot;true&quot;;          //邮件服务器认证属性    private List&lt;String&gt; attachFileNames;   //附件文件名    //===============getters and setters===============    ...}</code></pre><p>邮件发送具体类的实现如下:</p><pre><code>package com.carleviets.service;import com.carleviets.auth.MyAuthenticator;import com.carleviets.po.vo.MailSenderInfo;import javax.activation.DataHandler;import javax.activation.FileDataSource;import javax.mail.*;import javax.mail.internet.*;import java.io.File;import java.io.UnsupportedEncodingException;import java.util.Date;import java.util.List;import java.util.Properties;/** * 简单封装邮件发送器，实现邮件的发送 */public class MailSender {    public void sendHtmlMail(MailSenderInfo mailSendInfo){        Message message=null;        Session session=null;        try{            MyAuthenticator authenticator=new MyAuthenticator(mailSendInfo.getUserName(), mailSendInfo.getUserPwd());            //===============定义邮箱服务器配置================            Properties properties=new Properties();            //163   邮件服务器地址            properties.put(&quot;mail.smtp.host&quot;, mailSendInfo.getServerHost());            //163   邮件服务器端口            properties.put(&quot;mail.smtp.port&quot;, mailSendInfo.getServerPort());            //163   邮件服务器认证属性            properties.put(&quot;mail.smtp.auth&quot;, mailSendInfo.getFlag());            //===============创建Session对象，添加配置和授权===============            session=Session.getInstance(properties, authenticator);            //===============设置收件人、发件人和邮件信息===============            message=new MimeMessage(session);            Address from=new InternetAddress(mailSendInfo.getFromAddress());            message.setFrom(from);            message.setSentDate(new Date());            if(mailSendInfo.getToAddress()!=null &amp;&amp; mailSendInfo.getToAddress().size()&gt;0){                Address[] addresses=new Address[mailSendInfo.getToAddress().size()];                for (int i=0;i&lt;mailSendInfo.getToAddress().size();i++){                    Address address=new InternetAddress(mailSendInfo.getToAddress().get(i));                    addresses[i]=address;                }                message.setRecipients(Message.RecipientType.TO, addresses); //设置收件人地址                message.setSubject(mailSendInfo.getSubject());                Multipart multipart=new MimeMultipart();                BodyPart bodyPart=new MimeBodyPart();                bodyPart.setContent(mailSendInfo.getContent(), &quot;text/html;charset=utf-8&quot;);                multipart.addBodyPart(bodyPart);                //附件添加                List&lt;String&gt; files=mailSendInfo.getAttachFileNames();                if(files!=null&amp;&amp; files.size()&gt;0){                    for(int i=0;i&lt;files.size();i++){                        File tempFile=new File(files.get(i));                        if(tempFile.exists()){                            BodyPart temp=new MimeBodyPart();                            temp.setDataHandler(new DataHandler(new FileDataSource(tempFile)));                            temp.setFileName(MimeUtility.encodeText(tempFile.getName()));   //设置文件名                            multipart.addBodyPart(temp);    //添加附件                        }                    }                }                //设置邮件内容                message.setContent(multipart);                //===============发送邮件===============                Transport.send(message);            }        } catch (AddressException e) {            e.printStackTrace();        } catch (MessagingException e) {            e.printStackTrace();        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        }    }}</code></pre><p>测试代码很简单，这里略去。</p><h3 id="五、使用spring来实现邮件的发送"><a href="#五、使用spring来实现邮件的发送" class="headerlink" title="五、使用spring来实现邮件的发送"></a>五、使用spring来实现邮件的发送</h3><h4 id="5-1-maven坐标依赖"><a href="#5-1-maven坐标依赖" class="headerlink" title="5.1 maven坐标依赖"></a>5.1 maven坐标依赖</h4><pre><code>&lt;!--junit测试依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;junit&lt;/groupId&gt;  &lt;artifactId&gt;junit&lt;/artifactId&gt;  &lt;version&gt;4.12&lt;/version&gt;  &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--spring-test测试--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-test&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring核心依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring 上下文环境支持--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--java mail邮件发送--&gt;&lt;dependency&gt;  &lt;groupId&gt;javax.mail&lt;/groupId&gt;  &lt;artifactId&gt;mail&lt;/artifactId&gt;  &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="5-2-spring-xml具体配置"><a href="#5-2-spring-xml具体配置" class="headerlink" title="5.2 spring.xml具体配置"></a>5.2 spring.xml具体配置</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--配置JavaMailSenderImpl bean--&gt;    &lt;bean id=&quot;mailSender&quot; class=&quot;org.springframework.mail.javamail.JavaMailSenderImpl&quot;&gt;        &lt;property name=&quot;host&quot; value=&quot;smtp.163.com&quot;/&gt;        &lt;property name=&quot;port&quot; value=&quot;25&quot;/&gt;        &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;carleviets0420@163.com&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;carleviets0318&quot;/&gt;        &lt;property name=&quot;javaMailProperties&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;mail.smtp.auth&quot;&gt;true&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!--this is a template message that we can preload with a default state--&gt;    &lt;!--配置SimpleMailMessage bean--&gt;    &lt;bean id=&quot;templateMessage&quot; class=&quot;org.springframework.mail.SimpleMailMessage&quot;&gt;        &lt;property name=&quot;from&quot; value=&quot;carleviets0420@163.com&quot;/&gt;        &lt;property name=&quot;subject&quot; value=&quot;spring email&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置发送邮件的bean--&gt;    &lt;bean id=&quot;mailManager&quot; class=&quot;com.carleviets.springimpl.SimpleMailManager&quot;&gt;        &lt;property name=&quot;mailSender&quot; ref=&quot;mailSender&quot;/&gt;        &lt;property name=&quot;mailMessage&quot; ref=&quot;templateMessage&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h4 id="5-3定义邮件发送接口"><a href="#5-3定义邮件发送接口" class="headerlink" title="5.3定义邮件发送接口"></a>5.3定义邮件发送接口</h4><pre><code>package com.carleviets.springInterface;/** *  发送邮件接口的定义 */public interface MailManager {    void placeMail();}</code></pre><h4 id="5-4定义邮件发送接口"><a href="#5-4定义邮件发送接口" class="headerlink" title="5.4定义邮件发送接口"></a>5.4定义邮件发送接口</h4><pre><code>package com.carleviets.springimpl;import com.carleviets.springInterface.MailManager;import org.springframework.mail.MailException;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSenderImpl;/** * 发送邮件的简单实现类——在发送邮件的方法中实现发送邮件的代码 */public class SimpleMailManager implements MailManager {    @Autowired    private JavaMailSenderImpl mailSender;    @Autowired    private SimpleMailMessage mailMessage;    @Override    public void placeMail() {        mailMessage.setTo(&quot;carleviets0420@163.com&quot;);        mailMessage.setText(&quot;江火似流萤...&quot;);        try{            mailSender.send(message);        }catch (MailException ex){            System.err.println(ex.getMessage());        }    }}</code></pre><p>普通邮件测试代码如下：</p><pre><code>@Testpublic void test(){    mailManager.placeMail();}</code></pre><h4 id="5-5使用spring发送带附件的邮件"><a href="#5-5使用spring发送带附件的邮件" class="headerlink" title="5.5使用spring发送带附件的邮件"></a>5.5使用spring发送带附件的邮件</h4><p>使用spring发送带附件的邮件步骤和普通邮件一样，只是需要借助MimeMessageHelper辅助类来设置消息的属性。具体测试代码如下：</p><pre><code>/** * 测试通过spring发送带有附件的邮件 * @throws MessagingException */@Testpublic void test() throws MessagingException {    ApplicationContext applicationContext=            new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);    JavaMailSender mailSender= (JavaMailSender) applicationContext.getBean(&quot;mailSender&quot;);    MimeMessage message=mailSender.createMimeMessage();    message.setSubject(&quot;spring mail file&quot;);    //创建带有附件的消息帮助类    MimeMessageHelper helper=new MimeMessageHelper(message, true, &quot;utf-8&quot;);    helper.setTo(new InternetAddress(&quot;carleviets0420@163.com&quot;));    //设置接收人    helper.setText(&quot;Thank you for ordering!&quot;);    helper.setFrom(&quot;carleviets0420@163.com&quot;);    helper.addAttachment(&quot;timg.jpg&quot;, new File(&quot;C:\\Users\\Administrator\\Desktop\\timg.jpg&quot;));    mailSender.send(message);}</code></pre><p>至此，我们就实现了通过JDK的方式和通过Spring Mail的方式来实现邮件的发送。</p>]]></content>
      
      
      <categories>
          
          <category> java Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 邮件发送 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用工具类总结</title>
      <link href="/2019/01/13/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/13/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1-1、AssertUtil"><a href="#1-1、AssertUtil" class="headerlink" title="1.1、AssertUtil"></a>1.1、AssertUtil</h3><p>该实用工具类主要通过断言的思想，在相应的条件成立下，通过抛出异常的方式来阻止代码的继续执行，可以在很多情况下将需要好几行的代码浓缩为只有一行代码，并且可以配合全局异常处理器的使用来将异常处理集中到处理器中。具体如下:</p><pre><code>package com.carleviets.crm.utils;import com.carleviets.crm.exceptions.LoginException;import com.carleviets.crm.exceptions.ParamsException;public class AssertUtil {    public static void isTrue(Boolean flag, String msg){        if(flag){            throw new ParamsException(msg);        }    }    public static void isTrue(Boolean flag, Integer code, String msg){        if(flag){            throw new ParamsException(code, msg);        }    }    public static void isNotLogin(Boolean flag, String msg) {        if(flag){            throw new LoginException(msg);        }    }}</code></pre><h3 id="1-2、JsonUtil"><a href="#1-2、JsonUtil" class="headerlink" title="1.2、JsonUtil"></a>1.2、JsonUtil</h3><p>该实用工具类主要用于将java对象以JSON字符串的形式响应给客户端，具体代码如下：</p><pre><code>package com.carleviets.crm.utils;import com.alibaba.fastjson.JSON;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class JsonUtil {    /**     * 将对象转换为json字符串并发送到前台     * @param object     * @param response     */    public static void toJson(Object object, HttpServletResponse response){        try {            //将对象转换为json字符串            String jsonStr= JSON.toJSONString(object);            //设置响应类型及编码            response.setContentType(&quot;application/json;charset=utf-8&quot;);            //得到输出流            PrintWriter out=response.getWriter();            out.write(jsonStr);            out.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><h3 id="1-3、MD5Util"><a href="#1-3、MD5Util" class="headerlink" title="1.3、MD5Util"></a>1.3、MD5Util</h3><p>该实用工具类主要用于对字符串进行MD5加密，具体代码如下:</p><pre><code>package com.carleviets.crm.utils;import org.apache.commons.codec.binary.Base64;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class MD5Util {    public static String encode(String str){        String value=&quot;&quot;;        try {            //得到MD5加密的算法程序            MessageDigest messageDigest=MessageDigest.getInstance(&quot;MD5&quot;);            //对字符串进行MD5加密，返回byte数组            byte[] bytes=messageDigest.digest(str.getBytes());            //使用Base64对byte数组进行编码            value=Base64.encodeBase64String(bytes);        } catch (NoSuchAlgorithmException e) {            e.printStackTrace();        }        return value;    }    public static void main(String[] args) {        System.out.println(encode(&quot;12345&quot;));    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用工具类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM整合依赖及配置总结</title>
      <link href="/2019/01/13/SSM%E6%95%B4%E5%90%88%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/13/SSM%E6%95%B4%E5%90%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、所需引入的maven依赖"><a href="#一、所需引入的maven依赖" class="headerlink" title="一、所需引入的maven依赖"></a>一、所需引入的maven依赖</h2><h3 id="1-1测试依赖"><a href="#1-1测试依赖" class="headerlink" title="1.1测试依赖"></a>1.1测试依赖</h3><pre><code>&lt;!--junit测试依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;junit&lt;/groupId&gt;  &lt;artifactId&gt;junit&lt;/artifactId&gt;  &lt;version&gt;4.12&lt;/version&gt;  &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--spring测试依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-test&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-2-spring核心依赖"><a href="#1-2-spring核心依赖" class="headerlink" title="1.2 spring核心依赖"></a>1.2 spring核心依赖</h3>   <!--spring上下文依赖--><pre><code>&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectj切面代理--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;  &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;  &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-3-数据库相关"><a href="#1-3-数据库相关" class="headerlink" title="1.3 数据库相关"></a>1.3 数据库相关</h3><pre><code>&lt;!--spring jdbc--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring 事务管理--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--c3p0连接池--&gt;&lt;dependency&gt;  &lt;groupId&gt;com.mchange&lt;/groupId&gt;  &lt;artifactId&gt;c3p0&lt;/artifactId&gt;  &lt;version&gt;0.9.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis核心依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;  &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis与spring整合依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;  &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql数据库驱动包--&gt;&lt;dependency&gt;  &lt;groupId&gt;mysql&lt;/groupId&gt;  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  &lt;version&gt;8.0.11&lt;/version&gt;&lt;/dependency&gt;    &lt;!--mybatis分页插件--&gt;&lt;dependency&gt;  &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;  &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;  &lt;version&gt;4.1.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-4-日志打印"><a href="#1-4-日志打印" class="headerlink" title="1.4 日志打印"></a>1.4 日志打印</h3><pre><code>&lt;!--日志打印相关jar--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;  &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;  &lt;version&gt;1.7.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;  &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;  &lt;version&gt;1.7.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-5-spring-mvc依赖"><a href="#1-5-spring-mvc依赖" class="headerlink" title="1.5 spring-mvc依赖"></a>1.5 spring-mvc依赖</h3><pre><code>&lt;!--spring web--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-web&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring webmvc--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring mvc上下文支持 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--web servlet--&gt;&lt;dependency&gt;  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;  &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;  &lt;version&gt;3.0.1&lt;/version&gt;  &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;</code></pre><h3 id="1-6-json支持"><a href="#1-6-json支持" class="headerlink" title="1.6 json支持"></a>1.6 json支持</h3><pre><code>&lt;!--json依赖jar--&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;  &lt;version&gt;2.9.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;  &lt;version&gt;2.9.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;  &lt;version&gt;2.9.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--阿里巴巴 fastjson --&gt;&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-7-Apache-commons文件上传支持"><a href="#1-7-Apache-commons文件上传支持" class="headerlink" title="1.7 Apache-commons文件上传支持"></a>1.7 Apache-commons文件上传支持</h3><pre><code>&lt;!--commons文件上传--&gt;&lt;dependency&gt;  &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;  &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;  &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-8其他工具包"><a href="#1-8其他工具包" class="headerlink" title="1.8其他工具包"></a>1.8其他工具包</h3><pre><code>&lt;!-- commons-lang3实用工具类 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;  &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;  &lt;version&gt;3.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Base64编码解码支持 --&gt;&lt;dependency&gt;  &lt;groupId&gt;commons-codec&lt;/groupId&gt;  &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;  &lt;version&gt;1.10&lt;/version&gt;&lt;/dependency&gt;&lt;!-- freemarker视图模板 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.freemarker&lt;/groupId&gt;  &lt;artifactId&gt;freemarker&lt;/artifactId&gt;  &lt;version&gt;2.3.23&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>###1.9其他配置###</p><pre><code>&lt;!--指定资源访问路径，默认情况下为src/main/resources目录--&gt;&lt;resources&gt;  &lt;resource&gt;    &lt;directory&gt;src/main/resources/${env}&lt;/directory&gt;  &lt;/resource&gt;  &lt;resource&gt;    &lt;directory&gt;src/main/java&lt;/directory&gt;    &lt;includes&gt;      &lt;include&gt;**/*.xml&lt;/include&gt;      &lt;include&gt;**/*.properties&lt;/include&gt;      &lt;include&gt;**/*.tld&lt;/include&gt;    &lt;/includes&gt;    &lt;filtering&gt;false&lt;/filtering&gt;  &lt;/resource&gt;&lt;/resources&lt;plugins&gt;  &lt;!--如果用到了Base64编码，需要指定编译的虚拟机--&gt;  &lt;plugin&gt;    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;    &lt;configuration&gt;      &lt;source&gt;1.8&lt;/source&gt;      &lt;target&gt;1.8&lt;/target&gt;      &lt;encoding&gt;utf-8&lt;/encoding&gt;      &lt;compilerArguments&gt;        &lt;bootclasspath&gt;${java.home}/lib/rt.jar&lt;/bootclasspath&gt;      &lt;/compilerArguments&gt;    &lt;/configuration&gt;  &lt;/plugin&gt;  &lt;!--jetty服务器插件--&gt;  &lt;plugin&gt;    &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;    &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;    &lt;version&gt;6.1.25&lt;/version&gt;    &lt;configuration&gt;      &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt;      &lt;contextPath&gt;/crm&lt;/contextPath&gt;      &lt;webDefaultXml&gt;src/main/resources/${env}/webdefault.xml&lt;/webDefaultXml&gt;    &lt;/configuration&gt;  &lt;/plugin&gt;  &lt;!--mybatis代码自动生成插件--&gt;  &lt;plugin&gt;      &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;      &lt;version&gt;1.3.2&lt;/version&gt;      &lt;configuration&gt;        &lt;configurationFile&gt;src/main/resources/${env}/generatorConfig.xml&lt;/configurationFile&gt;        &lt;verbose&gt;true&lt;/verbose&gt;        &lt;overwrite&gt;true&lt;/overwrite&gt;      &lt;/configuration&gt;  &lt;/plugin&gt;&lt;/plugins&gt;&lt;!--配置不同的环境打包--&gt;&lt;profiles&gt;    &lt;!--默认开发环境--&gt;    &lt;profile&gt;      &lt;id&gt;dev&lt;/id&gt;      &lt;properties&gt;        &lt;env&gt;dev&lt;/env&gt;      &lt;/properties&gt;      &lt;!--此处指定哪个环境激活打包时就打哪个环境下的包--&gt;      &lt;activation&gt;        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;      &lt;/activation&gt;    &lt;/profile&gt;    &lt;!--测试环境--&gt;    &lt;profile&gt;      &lt;id&gt;test&lt;/id&gt;      &lt;properties&gt;        &lt;env&gt;test&lt;/env&gt;      &lt;/properties&gt;    &lt;/profile&gt;    &lt;!--生产环境--&gt;    &lt;profile&gt;      &lt;id&gt;product&lt;/id&gt;      &lt;properties&gt;        &lt;env&gt;product&lt;/env&gt;      &lt;/properties&gt;    &lt;/profile&gt;&lt;/profiles&gt;</code></pre><h2 id="二、配置文件总结"><a href="#二、配置文件总结" class="headerlink" title="二、配置文件总结"></a>二、配置文件总结</h2><h3 id="2-1-web-xml配置文件"><a href="#2-1-web-xml配置文件" class="headerlink" title="2.1 web.xml配置文件"></a>2.1 web.xml配置文件</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt;  &lt;!--配置ContextLoaderListener监听的上下文参数--&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;!--配置ContextLoaderListener上下文监听器--&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;!--配置字符过滤器--&gt;  &lt;filter&gt;    &lt;description&gt;char encoding filter&lt;/description&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;utf-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  &lt;!--配置spring-mvc前端控制器--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:servlet-context.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;!--注意次数映射路径不能为&quot;/*&quot;--&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><h3 id="2-2-spring-xml-配置文件"><a href="#2-2-spring-xml-配置文件" class="headerlink" title="2.2 spring.xml 配置文件"></a>2.2 spring.xml 配置文件</h3><p>该配置文件主要用于管理除了Controller层之外所有其它层的bean,配置如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:task=&quot;http://www.springframework.org/schema/task&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/task        http://www.springframework.org/schema/task/spring-task.xsd&quot;&gt;    &lt;!--开启组件扫描，通过注解的形式排除掉controller包--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets.crm&quot;&gt;        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;    &lt;/context:component-scan&gt;    &lt;!--指定数据库配置文件所在位置--&gt;    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;    &lt;!--配置c3p0数据源--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt;        &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置spring事务管理器并注入数据源--&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置事务通知--&gt;    &lt;tx:advice id=&quot;transactionInterceptor&quot; transaction-manager=&quot;transactionManager&quot;&gt;        &lt;tx:attributes&gt;            &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;load*&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;del*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!--通过aop切面配置事务管理--&gt;    &lt;aop:config&gt;        &lt;aop:pointcut id=&quot;servicePointCut&quot; expression=&quot;execution(* com.carleviets.crm.service..*.*(..))&quot;/&gt;        &lt;aop:advisor advice-ref=&quot;transactionInterceptor&quot; pointcut-ref=&quot;servicePointCut&quot;/&gt;    &lt;/aop:config&gt;    &lt;!--配置mybatis sqlSessionFactory bean--&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis.xml&quot;/&gt;        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/carleviets/crm/mapper/*.xml&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置mybatis包扫描器--&gt;    &lt;bean id=&quot;scannerConfigurer&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;!-- 扫描com.carleviets.crm.dao这个包以及它的子包下的所有映射接口类 --&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.carleviets.crm.dao&quot;/&gt;        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;    &lt;/bean&gt;    &lt;!--启用定时任务的注解驱动--&gt;    &lt;task:annotation-driven/&gt;&lt;/beans&gt;</code></pre><h3 id="2-2-servlet-context-xml-配置文件"><a href="#2-2-servlet-context-xml-配置文件" class="headerlink" title="2.2 servlet-context.xml 配置文件"></a>2.2 servlet-context.xml 配置文件</h3><p>该配置文件用于配置spring-mvc,即管理所谓的Controller层的bean，配置如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!--开启组件扫描,并且只扫描controller包--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets.crm.controller&quot;/&gt;    &lt;!--开启aspectj自动代理，由于controller层调用service层,service层dao层，故在此文件配置的aspectj自动代理可以代理其它层--&gt;    &lt;aop:aspectj-autoproxy/&gt;    &lt;!--配置freemarker配置--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;        &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/views/&quot;/&gt;        &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置freemarker视图解析器--&gt;    &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;&quot;/&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot;/&gt;        &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=utf-8&quot;/&gt;    &lt;/bean&gt;    &lt;!--mvc注解驱动并添加对响应json的支持, 可不配，内部自动提供--&gt;    &lt;mvc:annotation-driven&gt;        &lt;mvc:message-converters&gt;            &lt;!--返回信息为字符串时处理--&gt;            &lt;bean id=&quot;stringHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;/&gt;            &lt;!--将对象转化为json字符串--&gt;            &lt;bean id=&quot;jackson2HttpMessageConverter&quot; class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;/&gt;        &lt;/mvc:message-converters&gt;    &lt;/mvc:annotation-driven&gt;    &lt;!--配置对静态资源的放行处理 方式一--&gt;    &lt;!--&lt;mvc:default-servlet-handler/&gt;--&gt;    &lt;!--配置对静态资源的放行处理 方式二--&gt;    &lt;mvc:resources mapping=&quot;/statics/**&quot; location=&quot;/statics/&quot;/&gt;    &lt;!--配置拦截器--&gt;    &lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;            &lt;!--拦截所有路径--&gt;            &lt;mvc:mapping path=&quot;/**&quot;/&gt;            &lt;!--静态资源放行--&gt;            &lt;mvc:exclude-mapping path=&quot;/statics/**&quot;/&gt;            &lt;!--登录页面放行--&gt;            &lt;mvc:exclude-mapping path=&quot;/index&quot;/&gt;            &lt;!--登录操作放行--&gt;            &lt;mvc:exclude-mapping path=&quot;/user/login&quot;/&gt;            &lt;!--配置拦截器bean--&gt;            &lt;bean class=&quot;com.carleviets.crm.interceptor.LoginInterceptor&quot;/&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;&lt;/beans&gt;</code></pre><h3 id="2-3-mybatis-xml-配置文件"><a href="#2-3-mybatis-xml-配置文件" class="headerlink" title="2.3 mybatis.xml 配置文件"></a>2.3 mybatis.xml 配置文件</h3><p>该配置文件用于配置mybatis的别名扫描和分页插件配置，如果不需要别名和分页可不配置此文件。具体配置如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--配置mybatis别名包扫描--&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;com.carleviets.crm.po&quot;/&gt;    &lt;/typeAliases&gt;    &lt;!--配置mybatis分页插件--&gt;    &lt;plugins&gt;        &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt;            &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;            &lt;!-- 该参数默认为false --&gt;            &lt;!-- 设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用 --&gt;            &lt;!-- 和startPage中的pageNum效果一样 --&gt;            &lt;property name=&quot;offsetAsPageNum&quot; value=&quot;true&quot;/&gt;            &lt;!-- 该参数默认为false --&gt;            &lt;!-- 设置为true时，使用RowBounds分页会进行count查询 --&gt;            &lt;property name=&quot;rowBoundsWithCount&quot; value=&quot;true&quot;/&gt;            &lt;!-- 设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果 --&gt;            &lt;!-- （相当于没有执行分页查询，但是返回结果仍然是Page类型） --&gt;            &lt;property name=&quot;pageSizeZero&quot; value=&quot;true&quot;/&gt;            &lt;!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 --&gt;            &lt;!-- 启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;pages会查询最后一页 --&gt;            &lt;!-- 禁用合理化时，如果pageNum&lt;1或pageNum&gt;pages会返回空数据 --&gt;            &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt;            &lt;!-- 3.5.0版本可用 - 为了支持startPage(Object params)方法 --&gt;            &lt;!-- 增加了一个`params`参数来配置参数映射，用于从Map或ServletRequest中取值 --&gt;            &lt;!-- 可以配置pageNum,pageSize,count,pageSizeZero,reasonable,不配置映射的用默认值 --&gt;            &lt;property name=&quot;params&quot; value=&quot;pageNum=start;pageSize=limit;pageSizeZero=zero;reasonable=heli;count=contsql&quot;/&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/configuration&gt;</code></pre><h3 id="2-4-generatorConfig-xml-配置文件"><a href="#2-4-generatorConfig-xml-配置文件" class="headerlink" title="2.4 generatorConfig.xml 配置文件"></a>2.4 generatorConfig.xml 配置文件</h3><p>该配置文件用于mybatis代码的逆向生成，要使用mybatis代码自动生成的功能需要在pom.xml中配置mybatis代码自动生成插件，插件的引入如下:</p><pre><code>&lt;!--mybatis代码自动生成插件--&gt;  &lt;plugin&gt;      &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;      &lt;version&gt;1.3.2&lt;/version&gt;      &lt;configuration&gt;        &lt;configurationFile&gt;src/main/resources/${env}/generatorConfig.xml&lt;/configurationFile&gt;        &lt;verbose&gt;true&lt;/verbose&gt;        &lt;overwrite&gt;true&lt;/overwrite&gt;      &lt;/configuration&gt;  &lt;/plugin&gt;</code></pre><p>generatorConfig.xml 配置文件的具体配置如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;!--数据库驱动，此处的路径为maven仓库下mysql数据库驱动所对应的路径--&gt;    &lt;classPathEntry location=&quot;D:/apache-maven-3.6.0/Repositories/mysql/mysql-connector-java/8.0.11/mysql-connector-java-8.0.11.jar&quot;/&gt;    &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;    &lt;!--生成的代码中不需要注释--&gt;    &lt;commentGenerator&gt;        &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;        &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;    &lt;/commentGenerator&gt;    &lt;!--数据库链接地址、账号和密码--&gt;    &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/project?useSSL=false&amp;amp;serverTimezone=GMT%2B8&quot; userId=&quot;root&quot; password=&quot;12345&quot;&gt;    &lt;/jdbcConnection&gt;    &lt;javaTypeResolver&gt;        &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;    &lt;/javaTypeResolver&gt;    &lt;!--生成Model类存放位置，此处路径为项目下src/main/java的绝对路径--&gt;    &lt;javaModelGenerator targetPackage=&quot;com.carleviets.crm.po&quot; targetProject=&quot;C:/Users/Administrator/IdeaProjects/crm_2/src/main/java&quot;&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;    &lt;/javaModelGenerator&gt;    &lt;!--生成映射文件存放位置，此处路径为项目下src/main/java的绝对路径--&gt;    &lt;sqlMapGenerator targetPackage=&quot;com.carleviets.crm.mapper&quot; targetProject=&quot;C:/Users/Administrator/IdeaProjects/crm_2/src/main/java&quot;&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;    &lt;/sqlMapGenerator&gt;    &lt;!--生成Dao类存放位置，此处路径为项目下src/main/java的绝对路径--&gt;    &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.carleviets.crm.dao&quot; targetProject=&quot;C:/Users/Administrator/IdeaProjects/crm_2/src/main/java&quot;&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;    &lt;/javaClientGenerator&gt;    &lt;!--指定需要生成代码、映射文件、Mapper接口的表--&gt;    &lt;table tableName=&quot;t_customer&quot; domainObjectName=&quot;Customer&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><h3 id="2-5-其他配置文件"><a href="#2-5-其他配置文件" class="headerlink" title="2.5 其他配置文件"></a>2.5 其他配置文件</h3><p>数据库属性文件db.properties:</p><pre><code>jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/crm?useSSL=false&amp;serverTimezone=GMT%2B8jdbc.username=rootjdbc.password=12345</code></pre><p>日志打印文件log4j.properties：</p><pre><code>log4j.rootLogger=DEBUG, Console  #Consolelog4j.appender.Console=org.apache.log4j.ConsoleAppender  log4j.appender.Console.layout=org.apache.log4j.PatternLayout  log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n  log4j.logger.java.sql.ResultSet=INFO  log4j.logger.org.apache=INFO  log4j.logger.java.sql.Connection=DEBUG  log4j.logger.java.sql.Statement=DEBUG  log4j.logger.java.sql.PreparedStatement=DEBUG </code></pre>]]></content>
      
      
      <categories>
          
          <category> SSM整合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM整合 </tag>
            
            <tag> Maven依赖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM整合时高可用代码总结</title>
      <link href="/2019/01/13/SSM%E6%95%B4%E5%90%88%E6%97%B6%E9%AB%98%E5%8F%AF%E7%94%A8%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/13/SSM%E6%95%B4%E5%90%88%E6%97%B6%E9%AB%98%E5%8F%AF%E7%94%A8%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1、BaseDAO"><a href="#1、BaseDAO" class="headerlink" title="1、BaseDAO"></a>1、BaseDAO</h3><p>baseDAO是一个高可用的接口，里面集成了添加、查询、修改、删除等方法，在ssm集成的时候，任何继承了该接口的mapper接口就拥有了对应的操作响应数据的方法，可以在很大程度上减少代码的重复，其具体如下：</p><pre><code>package com.carleviets.crm.base;import org.springframework.dao.DataAccessException;import java.util.List;import java.util.Map;public interface BaseDAO&lt;T&gt; {    /**     * 添加记录     * @param entity     * @return     * @throws DataAccessException     */    Integer save(T entity)throws DataAccessException;    /**     * 批量添加记录     * @param entities     * @return     * @throws DataAccessException     */    Integer saveBatch(List&lt;T&gt; entities) throws DataAccessException;    /**     * 通过id查询     * @param id     * @return     * @throws DataAccessException     */    T queryById(Integer id) throws DataAccessException;    /**     * 参数化查询     * @param baseQuery     * @return     * @throws DataAccessException     */    List&lt;T&gt; queryByParams(BaseQuery baseQuery) throws DataAccessException;    /**     * 更新单条记录     * @param entity     * @return     * @throws DataAccessException     */    Integer update(T entity) throws DataAccessException;    /**     * 批量更新     * @param map     * @return     * @throws DataAccessException     */    Integer updateBatch(Map&lt;String, Object&gt; map) throws DataAccessException;    /**     * 通过id删除单条记录     * @param id     * @return     * @throws DataAccessException     */    Integer delete(Integer id) throws DataAccessException;    /**     * 批量删除记录     * @param ids     * @return     * @throws DataAccessException     */    Integer deleteBatch(Integer[] ids) throws DataAccessException;}</code></pre><h3 id="2、BaseService"><a href="#2、BaseService" class="headerlink" title="2、BaseService"></a>2、BaseService</h3><p>该实用工具类对查询，更新、删除、分页查询等常用的操作进行了封装，Service层只需要继承该实用工具类，就可以省去大量的重复代码，具体如下:</p><pre><code>package com.carleviets.crm.base;import com.carleviets.crm.utils.AssertUtil;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.dao.DataAccessException;import java.util.HashMap;import java.util.List;import java.util.Map;public class BaseService&lt;T&gt; {    @Autowired    private BaseDAO&lt;T&gt; baseDAO;    /**     * 添加单条记录     * @param entity     * @return     * @throws DataAccessException     */    public Integer save(T entity) throws DataAccessException{        return baseDAO.save(entity);    }    /**     * 批量添加记录     * @param entities     * @return     * @throws DataAccessException     */    public Integer saveBatch(List&lt;T&gt; entities) throws DataAccessException{        return baseDAO.saveBatch(entities);    }    /**     * 通过id查询     * @param id     * @return     * @throws DataAccessException     */    public T queryById(Integer id) throws DataAccessException{        AssertUtil.isTrue(id==null||id&lt;0, &quot;带查询的记录不存在&quot;);        return baseDAO.queryById(id);    }    /**     * 参数化查询     * @param baseQuery     * @return     * @throws DataAccessException     */    public PageInfo&lt;T&gt; queryByParams(BaseQuery baseQuery) throws DataAccessException{        PageHelper.startPage(baseQuery.getPageNum(), baseQuery.getPageSize());        List&lt;T&gt; entities = baseDAO.queryByParams(baseQuery);        return new PageInfo&lt;T&gt;(entities);    }    /**     * 参数化分页查询     * @param baseQuery     * @return     * @throws DataAccessException     */    public Map&lt;String, Object&gt; queryForPage(BaseQuery baseQuery) throws DataAccessException{        PageHelper.startPage(baseQuery.getPageNum(), baseQuery.getPageSize());        List&lt;T&gt; entities=baseDAO.queryByParams(baseQuery);        PageInfo&lt;T&gt; pageInfo=new PageInfo&lt;T&gt;(entities);        Map&lt;String, Object&gt; map=new HashMap&lt;&gt;();        map.put(&quot;total&quot;, pageInfo.getTotal());        map.put(&quot;rows&quot;, pageInfo.getList());        return map;    }    /**     * 更新单条记录     * @param entity     * @return     * @throws DataAccessException     */    public Integer update(T entity) throws DataAccessException{        return baseDAO.update(entity);    }    /**     * 批量更新记录     * @param map     * @return     * @throws DataAccessException     */    public Integer updateBatch(Map&lt;String, Object&gt; map) throws DataAccessException{        return baseDAO.updateBatch(map);    }    /**     * 删除单条记录     * @param id     * @return     * @throws DataAccessException     */    public Integer delete(Integer id) throws DataAccessException{        AssertUtil.isTrue(id==null||id&lt;=0||queryById(id)==null, &quot;待删除的记录不存在&quot;);        return baseDAO.delete(id);    }    /**     * 批量删除记录     * @param ids     * @return     * @throws DataAccessException     */    public Integer deleteBatch(Integer[] ids) throws DataAccessException{        AssertUtil.isTrue(ids==null||ids.length==0, &quot;请选择待删除的记录&quot;);        return baseDAO.deleteBatch(ids);    }}</code></pre><h3 id="3、BaseController"><a href="#3、BaseController" class="headerlink" title="3、BaseController"></a>3、BaseController</h3><p>该实用工具类封装了对于成功操作时返回ResultInfo对象的方法，并且通过@ModelAttribute注解可以在继承该实用工具类的每一个控制器方法执行前统一在request作用域中添加了上下文路径，省去了大量的重复代码：</p><pre><code>package com.carleviets.crm.base;import com.carleviets.crm.po.vo.ResultInfo;import org.springframework.web.bind.annotation.ModelAttribute;import javax.servlet.http.HttpServletRequest;public class BaseController {    public ResultInfo success(Integer code, String msg, Object result){        ResultInfo resultInfo=new ResultInfo();        resultInfo.setCode(code);        resultInfo.setMsg(msg);        resultInfo.setResult(result);        return resultInfo;    }    public ResultInfo success(Integer code, String msg){        ResultInfo resultInfo=new ResultInfo();        resultInfo.setCode(code);        resultInfo.setMsg(msg);        return resultInfo;    }    //此注解标注的方法会在每个Controller的方法执行之前执行    @ModelAttribute    public void preHandle(HttpServletRequest request){        request.setAttribute(&quot;ctx&quot;, request.getContextPath());    }}</code></pre><h3 id="3、BaseQuery"><a href="#3、BaseQuery" class="headerlink" title="3、BaseQuery"></a>3、BaseQuery</h3><p>这个不用多说，所有的参数查询前台都需要传递pageNum和pageSize这两个参数，但是对于具体的情况，可以具有其他不同的参数，该实用工具类就是对pageNum和pageSize这两个参数进行简单封装的JavaBean，所有的参数查询都可以继承该实用工具类：</p><pre><code>package com.carleviets.crm.base;public class BaseQuery {    private Integer pageNum;    private Integer pageSize;    public Integer getPageNum() {        return pageNum;    }    public void setPageNum(Integer pageNum) {        this.pageNum = pageNum;    }    public Integer getPageSize() {        return pageSize;    }    public void setPageSize(Integer pageSize) {        this.pageSize = pageSize;    }}</code></pre><h3 id="3、GlobalExceptionHandler全局异常处理器"><a href="#3、GlobalExceptionHandler全局异常处理器" class="headerlink" title="3、GlobalExceptionHandler全局异常处理器"></a>3、GlobalExceptionHandler全局异常处理器</h3><p>全局异常处理器是spring-mvc中异常集中处理的地方。配置全局异常处理器后，Controller中只需要关注代码正常执行的情况，而异常发生时由全局异常处理器来进行统一的处理，并且根据前台需要的是普通视图还是JSON字符串进行不同的响应，具体代码如下：</p><pre><code>package com.carleviets.crm.exceptions;import com.carleviets.crm.po.vo.ResultInfo;import com.carleviets.crm.utils.JsonUtil;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.lang.reflect.Method;@Componentpublic class GlobalExceptionResolver implements HandlerExceptionResolver {    /**     * @param request     * @param response     * @param target    调用的方法     * @param ex     * @return     */    @Override    public ModelAndView resolveException(HttpServletRequest request,                                         HttpServletResponse response,                                         Object target,                                         Exception ex) {        ModelAndView modelAndView=createDefaultModelAndView(request);        if(ex instanceof LoginException){            LoginException e= (LoginException) ex;            modelAndView.addObject(&quot;errorMsg&quot;, e.getMsg());        }        //如果目标方法是处理器方法的实例        if(target instanceof HandlerMethod){            HandlerMethod handlerMethod= (HandlerMethod) target;            Method method=handlerMethod.getMethod();            //@ResponseBody注解区分前台是需要json数据还是视图            ResponseBody annotation = method.getAnnotation(ResponseBody.class);            if(annotation==null){                //普通页面请求                if(ex instanceof ParamsException){                    ParamsException e= (ParamsException) ex;                    modelAndView.addObject(&quot;errorMsg&quot;, e.getMsg());                }else{                    modelAndView.addObject(&quot;errorMsg&quot;, &quot;系统繁忙&quot;);                }                return modelAndView;            }else{                //前台需要json数据                ResultInfo resultInfo=new ResultInfo();                if(ex instanceof ParamsException){                    ParamsException e= (ParamsException) ex;                    resultInfo.setCode(e.getCode());                    resultInfo.setMsg(e.getMsg());                }else{                    resultInfo.setCode(417);                    resultInfo.setMsg(&quot;系统繁忙&quot;);                }                //将resultInfo转化为json数据发送到前台                JsonUtil.toJson(resultInfo, response);            }        }        return null;    }    private ModelAndView createDefaultModelAndView(HttpServletRequest request) {        ModelAndView modelAndView=new ModelAndView();        modelAndView.setViewName(&quot;error&quot;);  //设置视图名称        modelAndView.addObject(&quot;ctx&quot;, request.getContextPath());        return modelAndView;    }}</code></pre><h3 id="4、spring-mvc中拦截器实现对特定请求的拦截"><a href="#4、spring-mvc中拦截器实现对特定请求的拦截" class="headerlink" title="4、spring-mvc中拦截器实现对特定请求的拦截"></a>4、spring-mvc中拦截器实现对特定请求的拦截</h3><p>在spring-mvc中，可以通过拦截器实现对特定请求的拦截，如：拦截用户登录等。下面是一个拦截用户登录的代码：</p><pre><code>package com.carleviets.crm.interceptor;import com.carleviets.crm.service.UserService;import com.carleviets.crm.utils.AssertUtil;import com.carleviets.crm.utils.LoginUserUtil;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class LoginInterceptor extends HandlerInterceptorAdapter {    @Autowired    private UserService userService;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        //从cookie中获取到userId        Integer userId= LoginUserUtil.releaseUserIdFromCookie(request);        AssertUtil.isNotLogin(userId==null||userService.queryById(userId)==null, &quot;用户未登录&quot;);        return true;    //true为放行，false为拦截    }}</code></pre><p>除了编写拦截器外，还需要在servlet-context.xml中显示配置拦截器的拦截路径，放行的资源和放行的操作等，这种方式粒度较粗，对应的配置如下：</p><pre><code>&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt;    &lt;mvc:interceptor&gt;        &lt;!--拦截所有路径--&gt;        &lt;mvc:mapping path=&quot;/**&quot;/&gt;        &lt;!--静态资源放行--&gt;        &lt;mvc:exclude-mapping path=&quot;/statics/**&quot;/&gt;        &lt;!--登录页面放行--&gt;        &lt;mvc:exclude-mapping path=&quot;/index&quot;/&gt;        &lt;!--登录操作放行--&gt;        &lt;mvc:exclude-mapping path=&quot;/user/login&quot;/&gt;        &lt;!--配置拦截器bean--&gt;        &lt;bean class=&quot;com.carleviets.crm.interceptor.LoginInterceptor&quot;/&gt;    &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;</code></pre><p>除了这种方式外，还可以通过spring中的AOP实现拦截操作。</p><h3 id="4、通过AOP代理实现拦截请求的操作"><a href="#4、通过AOP代理实现拦截请求的操作" class="headerlink" title="4、通过AOP代理实现拦截请求的操作"></a>4、通过AOP代理实现拦截请求的操作</h3><p>在spring中，可以通过前置通知和环绕通知来实现对特定请求的拦截。下面是基于特定的注解和环绕通知来实现没有对应权限的用户的拦截代码：</p><pre><code>package com.carleviets.crm.aop;import com.carleviets.crm.annotations.RequestPermission;import com.carleviets.crm.constants.CrmConstants;import com.carleviets.crm.utils.AssertUtil;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import javax.servlet.http.HttpSession;import java.lang.reflect.Method;import java.util.List;@Component@Aspectpublic class PermissionAdapter {    @Autowired    private HttpSession httpSession;    //声明切点     @Pointcut(&quot;@annotation(com.carleviets.crm.annotations.RequestPermission)&quot;)    public void cut(){}    //声明环绕通知    @Around(&quot;cut()&quot;)    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {        //通过连接点拿到方法签名        MethodSignature methodSignature= (MethodSignature) proceedingJoinPoint.getSignature();        //通过方法签名获取到该方法        Method method=methodSignature.getMethod();        //通过方法获取到特定的注解        RequestPermission annotation=method.getAnnotation(RequestPermission.class);        //通过注解获取到权限码值        String aclValue=annotation.aclValue();        //判断会话中储存的权限列表中是否包含该权限码        List&lt;String&gt; permissions= (List&lt;String&gt;) httpSession.getAttribute(CrmConstants.USER_PERMISSIONS);        AssertUtil.isTrue(permissions==null||!permissions.contains(aclValue), &quot;没有权限&quot;);        return proceedingJoinPoint.proceed();    }}</code></pre><p>其中，注解的定义如下：</p><pre><code>package com.carleviets.crm.annotations;import java.lang.annotation.*;@Target({ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface RequestPermission {    String aclValue() default &quot;&quot;;}</code></pre><p>控制器中的方法，@RequestPermission注解中的value值为需要访问控制器中该方法的权限码值，具体代码如下：</p><pre><code>@RequestPermission(aclValue = &quot;101001&quot;)@RequestMapping(&quot;/querySaleChancesByParams&quot;)public @ResponseBody Map&lt;String, Object&gt; querySaleChancesByParams(SaleChanceQuery saleChanceQuery,                                                                  @RequestParam(defaultValue = &quot;1&quot;) Integer page,                                                                  @RequestParam(defaultValue = &quot;10&quot;) Integer rows){    saleChanceQuery.setPageNum(page);    saleChanceQuery.setPageSize(rows);    return saleChanceService.queryForPage(saleChanceQuery);}</code></pre><p>通过AOP这种方式实现对特定请求的拦截，不需要在servlet-context.xml中进行任何的配置，并且控制的粒度更细，也是本人推荐使用的一种方式。</p>]]></content>
      
      
      <categories>
          
          <category> SSM整合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用工具类 </tag>
            
            <tag> SSM整合 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
