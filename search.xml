<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring aop 简单总结</title>
      <link href="/2019/01/19/Spring%20aop%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/19/Spring%20aop%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关于Spring-aop"><a href="#一、关于Spring-aop" class="headerlink" title="一、关于Spring aop"></a>一、关于Spring aop</h2><h4 id="1、简单介绍"><a href="#1、简单介绍" class="headerlink" title="1、简单介绍"></a>1、简单介绍</h4><p>在软件开发中，散布于应用中多处的功能被称为横切关注点（crosscutting concern）。通常来讲，这些横切关注点从概念上是与应用的业务逻辑相分离的（但是往往会直接嵌入到应用的业务逻辑之中）。简而言之，横切关注点可以被描述为影响应用多处的功能。</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fz9w687qgaj30km0cowj1.jpg" alt=""></p><p>AOP,即面向切面编程（Aspect Oriented Programing），相较OOP而言，AOP 关注的不再是程序代码中某个类或某些方法，而 aop 考虑的更多的是一种面到面的切入，即层与层之间的一种切入，所以称之为切面。</p><h4 id="2、应用场景"><a href="#2、应用场景" class="headerlink" title="2、应用场景"></a>2、应用场景</h4><p>AOP主要应用于日志、安全、事务管理性能统计等方面，实现公共功能代码的复用。</p><h4 id="3、AOP带来的好处"><a href="#3、AOP带来的好处" class="headerlink" title="3、AOP带来的好处"></a>3、AOP带来的好处</h4><p>(1) 降低模块与模块之间的耦合度，提高业务代码的聚合度，即所谓的高内聚低耦合（DI有助于应用对象之间的解耦，而AOP可以实现横切关注点与它们所影响的对象之间的解耦）。</p><p>(2) 提高了代码的复用性。</p><p>(3) 提高系统的扩展性。</p><h2 id="二、AOP基本概念"><a href="#二、AOP基本概念" class="headerlink" title="二、AOP基本概念"></a>二、AOP基本概念</h2><h4 id="1、通知（Advice"><a href="#1、通知（Advice" class="headerlink" title="1、通知（Advice)"></a>1、通知（Advice)</h4><p>在AOP术语中，切面的工作被称为通知。通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。Spring切面可以应用5种类型的通知：</p><pre><code>前置通知（Before）：在目标方法被调用之前调用通知功能；后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；返回通知（After-returning）：在目标方法成功执行之后调用通知；异常通知（After-throwing）：在目标方法抛出异常后调用通知；环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</code></pre><h4 id="2、连接点（Join-point）"><a href="#2、连接点（Join-point）" class="headerlink" title="2、连接点（Join point）"></a>2、连接点（Join point）</h4><p>连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。<br><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fz9wn10ky6j30mn0g7tbx.jpg" alt=""></p><h4 id="3、-切点（Poincut）"><a href="#3、-切点（Poincut）" class="headerlink" title="3、 切点（Poincut）"></a>3、 切点（Poincut）</h4><p>如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处”。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p><h4 id="4、切面（Aspect）"><a href="#4、切面（Aspect）" class="headerlink" title="4、切面（Aspect）"></a>4、切面（Aspect）</h4><p>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——它是什么，在何时和何处完成其功能。切点定义了要拦截哪些类的哪些方法， 通知则定义了拦截过方法后要做什么，切面则是横切关注点的抽象，与类相似，类是对物体特征的抽象，切面则是横切关注点抽象。</p><h4 id="5、引入（Introduction）"><a href="#5、引入（Introduction）" class="headerlink" title="5、引入（Introduction）"></a>5、引入（Introduction）</h4><p>在不修改原有应用程序代码的情况下，在程序运行期为类动态添加方法或者字段的过程称为引入。</p><p>####6、织入（Weaving）</p><p>织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多个点可以进行织入，包括编译期、类加载期和运行期，但是Spring的AOP只支持在运行期织入。</p><h2 id="三、Spring-对AOP的支持"><a href="#三、Spring-对AOP的支持" class="headerlink" title="三、Spring 对AOP的支持"></a>三、Spring 对AOP的支持</h2><h4 id="1、Spring在运行时通知对象"><a href="#1、Spring在运行时通知对象" class="headerlink" title="1、Spring在运行时通知对象"></a>1、Spring在运行时通知对象</h4><p>Spring AOP是基于动态代理的，通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。如图所示，代理类封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fz9y9bib6nj30q20ds0ul.jpg" alt=""></p><p>直到应用需要被代理的bean时，Spring才创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入Spring AOP的切面。</p><h4 id="2、Spring只支持方法级别的连接点"><a href="#2、Spring只支持方法级别的连接点" class="headerlink" title="2、Spring只支持方法级别的连接点"></a>2、Spring只支持方法级别的连接点</h4><p>因为Spring基于动态代理，所以Spring只支持方法连接点。这与一些其他的AOP框架是不同的，例如AspectJ和JBoss，除了方法切点，它们还提供了字段和构造器接入点。 Spring缺少对字段连接点的支持，无法让我们创建细粒度的通知，例如拦截对象字段的修改。而且它不支持构造器连接点，我们就无法在bean创建时应用通知，但是方法拦截可以满足绝大部分的需求。</p><h2 id="四、切点表达式语言"><a href="#四、切点表达式语言" class="headerlink" title="四、切点表达式语言"></a>四、切点表达式语言</h2><p>在Spring AOP中，要使用AspectJ的切点表达式语言来定义切点，但是，Spring仅支持AspectJ切点指示器（pointcut designator）的一个子集。如下：</p><pre><code>AspectJ指示器                                             描　　述 arg()                                         限制连接点匹配参数为指定类型的执行方法 @args()                                    限制连接点匹配参数由指定注解标注的执行方法 execution()                                 用于匹配是连接点的执行方法 this()                                     限制连接点匹配AOP代理的bean引用为指定类型的类 target                                     限制连接点匹配目标对象为指定类型的类 @target()                                    限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解 within()                                     限制连接点匹配指定的类型 @within()                                    限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方法定义在由指定的注解所标注的类里） @annotation                                 限定匹配带有指定注解的连接点 bean()                                        允许我们在切点表达式中使用bean的ID来匹配特定的bean</code></pre><p>注意，只有execution指示器是实际执行匹配的，而其他的指示器都是用来限制匹配的。如下是一个式例声明：</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fz9yx6ksutj30lg08mgnb.jpg" alt=""></p><h2 id="五、具体使用"><a href="#五、具体使用" class="headerlink" title="五、具体使用"></a>五、具体使用</h2><h4 id="1、配置文件"><a href="#1、配置文件" class="headerlink" title="1、配置文件"></a>1、配置文件</h4><p>要想使用Spring aop,首先需要在pom.xml中引入如下的坐标依赖:</p><pre><code> &lt;!--spring 核心依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring-aop面向切面--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectj代理--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;  &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;  &lt;version&gt;1.8.9&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>其次，需要在spring.xml开启组件扫描和AspectJ自动代理:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!--组件扫描--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets&quot;/&gt;    &lt;!--aspectj自动代理--&gt;    &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt;</code></pre><h4 id="2、使用AOP"><a href="#2、使用AOP" class="headerlink" title="2、使用AOP"></a>2、使用AOP</h4><p>例如，对于演出而言，观众是很重要的一个关注点，但就演出本身而言，它并不是演出的核心功能，在演出前观众需要就坐和把手机调到静音，演出很精彩的话观众可能会鼓掌，演出没有达到预期的话观众可能就需要退款了，如下是通过java的方式将观众配置为一个切面：</p><pre><code>package com.carleviets.aop;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;@Component@Aspectpublic class Audience {    @Pointcut(&quot;execution(* com.carleviets.concert.Perfermance.perform(..))&quot;)    public void performance(){}    @Before(&quot;performance()&quot;)    public void silenceCellPhones(){        System.out.println(&quot;将手机调到静音...&quot;);    }    @Before(&quot;performance()&quot;)    public void takeSeats(){        System.out.println(&quot;就坐...&quot;);    }    @AfterReturning(&quot;performance()&quot;)    public void applause(){        System.out.println(&quot;鼓掌...&quot;);    }    @AfterThrowing(&quot;performance()&quot;)    public void demandRefund(){        System.out.println(&quot;需要退款...&quot;);    }}</code></pre><p>注意上面定义的perfermance()方法本身的内容并不重要，该方法本身只是一个标识，供@Pointcut注解依附以便声明切点。同时也需要注意上面使用AspectJ注解声明了通知的方法。</p><p>同样，我们也可以通过xml的方式进行切面配置, 首先，去掉注解后的Audience类是一个普通的POJO类:</p><pre><code>package com.carleviets.aop;import org.springframework.stereotype.Component;@Componentpublic class Audience {    public void silenceCellPhones(){        System.out.println(&quot;将手机调到静音...&quot;);    }    public void takeSeats(){        System.out.println(&quot;就坐...&quot;);    }    public void applause(){        System.out.println(&quot;鼓掌...&quot;);    }    public void demandRefund(){        System.out.println(&quot;需要退款...&quot;);    }}</code></pre><p>在spring.xml中，需要添加如下配置：</p><pre><code>&lt;aop:config&gt;    &lt;!--声明切面--&gt;    &lt;aop:aspect ref=&quot;audience&quot;&gt;        &lt;!--声明切点--&gt;        &lt;aop:pointcut id=&quot;perfermance&quot; expression=&quot;execution(* com.carleviets.concert.Perfermance.perform(..))&quot;/&gt;        &lt;!--声明前置通知--&gt;        &lt;aop:before pointcut-ref=&quot;perfermance&quot; method=&quot;silenceCellPhones&quot;/&gt;        &lt;aop:before pointcut-ref=&quot;perfermance&quot; method=&quot;takeSeats&quot;/&gt;        &lt;!--声明返回通知--&gt;        &lt;aop:after-returning pointcut-ref=&quot;perfermance&quot; method=&quot;applause&quot;/&gt;        &lt;!--声明异常通知--&gt;        &lt;aop:after-throwing pointcut-ref=&quot;perfermance&quot; method=&quot;demandRefund&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><p>这样，我们就通过Java配置的方式和通过xml的方式完成了一个切面的配置。</p><h4 id="3、使用环绕通知"><a href="#3、使用环绕通知" class="headerlink" title="3、使用环绕通知"></a>3、使用环绕通知</h4><p>在所有的通知中，环绕通知是功能最为强大的类型。它能够让你所编写的逻辑将被通知的目标方法完全包装起来。实际上就像在一个通知方法中同时编写前置通知和后置通知。同样以上述的表演为例，环绕通知的Java配置如下:</p><pre><code>package com.carleviets.aop;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;@Component@Aspectpublic class Audience {    @Pointcut(&quot;execution(* com.carleviets.concert.Perfermance.perform(..))&quot;)    public void performance(){}    @Around(&quot;performance()&quot;)    public Object watchPerfermance(ProceedingJoinPoint proceedingJoinPoint){        Object result=null;        try {            //在演出开始前把手机调到静音和就坐            System.out.println(&quot;将手机调到静音...&quot;);            System.out.println(&quot;就坐...&quot;);            //调用被拦截的方法，如果方法有返回值需要在最后通过return返回结果            result=proceedingJoinPoint.proceed();            //演出成功，鼓掌            System.out.println(&quot;鼓掌...&quot;);        } catch (Throwable throwable) {            throwable.printStackTrace();            //演出不符合预期            System.out.println(&quot;需要退款...&quot;);        }        return result;    }}</code></pre><p>在上面的配置中需要注意的是ProceedingJoinPoint对象的proceed方法的调用，当然你也可以不调用proceed()方法，这样的话会阻塞对被通知方法的访问，同样，你也可以在通知中对它进行多次调用。同样，如果用xml来配置环绕通知的话，此时，具体Java类的代码如下:</p><pre><code>package com.carleviets.aop;import org.aspectj.lang.ProceedingJoinPoint;import org.springframework.stereotype.Component;@Componentpublic class Audience {    public Object watchPerfermance(ProceedingJoinPoint proceedingJoinPoint){        Object result=null;        try {            //在演出开始前把手机调到静音和就坐            System.out.println(&quot;将手机调到静音...&quot;);            System.out.println(&quot;就坐...&quot;);            //调用被拦截的方法，如果方法有返回值需要在最后通过return返回结果            result=proceedingJoinPoint.proceed();            //演出成功，鼓掌            System.out.println(&quot;鼓掌...&quot;);        } catch (Throwable throwable) {            throwable.printStackTrace();            //演出不符合预期            System.out.println(&quot;需要退款...&quot;);        }        return result;    }}</code></pre><p>具体的xml配置如下:</p><pre><code>&lt;aop:config&gt;    &lt;!--声明切面--&gt;    &lt;aop:aspect ref=&quot;audience&quot;&gt;        &lt;!--声明切点--&gt;        &lt;aop:pointcut id=&quot;perfermance&quot; expression=&quot;execution(* com.carleviets.concert.Perfermance.perform(..))&quot;/&gt;        &lt;!--配置环绕通知--&gt;        &lt;aop:around method=&quot;watchPerfermance&quot; pointcut-ref=&quot;perfermance&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><h4 id="4、处理通知中的参数"><a href="#4、处理通知中的参数" class="headerlink" title="4、处理通知中的参数"></a>4、处理通知中的参数</h4><p>上面的通知方法中都没有参数，但是，如果要往通知中传入参数，该怎么办?下面是一个记录音乐CD播放的磁道计数的Java切面代码:</p><pre><code>package com.carleviets.aop;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;import java.util.HashMap;import java.util.Map;@Component@Aspectpublic class TrackCounter {    //定义一个Map,键为歌曲在磁道中的位置，值为磁道中对应歌曲所对应的播放次数计数值    private Map&lt;Integer, Integer&gt; tracks=new HashMap&lt;&gt;();    @Pointcut(&quot;execution(* com.carleviets.soundsystem.CD.playTrack(int )) &amp;&amp; args(trackNumber))&quot;)    public void trackPlayed(int trackNumber){}    @Before(&quot;trackPlayed(trackNumber)&quot;)    public void trackCount(int trackNumber){        int currentCount=getPlayCount(trackNumber);        tracks.put(trackNumber, currentCount++);    }    /**     * 如果该trackNumber之前存在播放记录，则返回之前的播放次数，否则返回0     * @param trackNumber     * @return     */    private int getPlayCount(int trackNumber) {        return tracks.containsKey(trackNumber) ? tracks.get(trackNumber) : 0;    }}</code></pre><p>切点表达式的具体解释如下图所示:</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fzc4m51xibj30ot095406.jpg" alt=""></p><p>上述代码如果采用xml来配置的话，Java类如下:</p><pre><code>package com.carleviets.aop;import org.aspectj.lang.annotation.Aspect;import org.springframework.stereotype.Component;import java.util.HashMap;import java.util.Map;@Componentpublic class TrackCounter {    //定义一个Map,键为歌曲在磁道中的位置，值为磁道中对应歌曲所对应的播放次数计数值    private Map&lt;Integer, Integer&gt; tracks=new HashMap&lt;&gt;();    public void trackCount(int trackNumber){        int currentCount=getPlayCount(trackNumber);        tracks.put(trackNumber, currentCount++);    }    /**     * 如果该trackNumber之前存在播放记录，则返回之前的播放次数，否则返回0     * @param trackNumber     * @return     */    private int getPlayCount(int trackNumber) {        return tracks.containsKey(trackNumber) ? tracks.get(trackNumber) : 0;    }}</code></pre><p>spring.xml的具体配置如下:</p><pre><code>&lt;aop:config&gt;    &lt;!--声明切面--&gt;    &lt;aop:aspect ref=&quot;trackCounter&quot;&gt;        &lt;!--声明切点--&gt;        &lt;aop:pointcut id=&quot;trackPlayed&quot; expression=&quot;execution(* com.carleviets.soundsystem.CD.playTrack(int)) and args(trackNumber)))&quot;/&gt;        &lt;!--声明前置通知--&gt;        &lt;aop:before method=&quot;trackCount&quot; pointcut-ref=&quot;trackPlayed&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><h4 id="1、代理模式实现三要素"><a href="#1、代理模式实现三要素" class="headerlink" title="1、代理模式实现三要素"></a>1、代理模式实现三要素</h4><pre><code>（1）接口定义（2）目标对象 与代理对象必须实现统一接口（3）代理对象持有目标对象的引用 增强目标对象行为</code></pre><h4 id="2、代理模式实现分类以及对应区别"><a href="#2、代理模式实现分类以及对应区别" class="headerlink" title="2、代理模式实现分类以及对应区别"></a>2、代理模式实现分类以及对应区别</h4><pre><code>（1）静态代理：手动为目标对象制作代理对象，即在程序编译阶段完成代理对象的创建（2）动态代理：在程序运行期动态创建目标对象对应代理对象。    jdk 动态代理：被代理目标对象必须实现某一或某一组接口 实现方式 通过回调创建代理对象。    cglib 动态代理：被代理目标对象可以不必实现接口，继承的方式实现。    动态代理相比较静态代理，提高开发效率，可以批量化创建代理，提高代码复用率。</code></pre><h4 id="3、Aop-理解"><a href="#3、Aop-理解" class="headerlink" title="3、Aop 理解"></a>3、Aop 理解</h4><pre><code>(1)面向切面，相比oop, aop关注的是代码中的层或面(2) 解耦，提高系统扩展性(3) 提高代码复用</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代理模式总结</title>
      <link href="/2019/01/16/Java%E4%BB%A3%E7%90%86%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/16/Java%E4%BB%A3%E7%90%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、代理模式介绍"><a href="#一、代理模式介绍" class="headerlink" title="一、代理模式介绍"></a>一、代理模式介绍</h2><p>代理(Proxy)是一种设计模式,提供了对目标对象另外的一种访问方式:即通过代理对象访问目标对象。这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。用图表示如下:</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fz8jpxbn9xj30lb06gq36.jpg" alt=""></p><p>代理模式分为静态代理和动态代理。代理模式的设计有两个重要的原则:</p><pre><code>1、 代理类与委托类具有相似的行为（共同）2、 代理类增强委托类的行为</code></pre><h2 id="二、静态代理"><a href="#二、静态代理" class="headerlink" title="二、静态代理"></a>二、静态代理</h2><p>为某个对象提供一个代理，代理角色固定，以控制对这个对象的访问。代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象替代。 代理类负责请求的预处理、 过滤、 将请求分派给委托类处理、 以及委托类执行完请求后的后续处理。</p><p>代理接口的定义如下:</p><pre><code>package com.carleviets;/** * 代理接口的定义 */public interface Marry {    void toMarry();}</code></pre><p>目标类的定义如下:</p><pre><code>package com.carleviets.demo;import com.carleviets.Marry;/** * 目标类的具体实现 */public class Person implements Marry {    @Override    public void toMarry() {        System.out.println(&quot;即将结婚了...&quot;);    }}</code></pre><p>代理类的定义如下:</p><pre><code>package com.carleviets.demo;import com.carleviets.Marry;/** * 代理类的具体实现 */public class Company implements Marry {    //代理的对象，委托类    private Person target;         public Company(Person target) {        this.target = target;    }    public void before(){        System.out.println(&quot;布置婚礼现场...&quot;);    }    public void after(){        System.out.println(&quot;进入人生第二阶段，好嗨哟...&quot;);    }    @Override    public void toMarry() {        before();        target.toMarry();   //真实行为        after();    }}</code></pre><p>测试代码:</p><pre><code>package com.carleviets.demo;import org.junit.Test;public class CompanyTest {    @Test    public void test(){        Person person=new Person();        //构造代理角色的同时传入真实角色        Company company=new Company(person);        company.toMarry();    }}</code></pre><p>静态代理的总结：<br><br>1.可以做到在不修改目标对象的功能前提下,对目标功能扩展。<br><br>2、缺点:因为静态代理对于代理的角色是固定的,并且代理对象需要与目标对象实现相同的接口,所以会有很多的代理类。同时,一旦接口增加方法,目标对象与代理对象都需要维护，这使得静态代理就无法满足生产上的需要，于是就催生了动态代理的思想。</p><h2 id="三、JDK动态代理"><a href="#三、JDK动态代理" class="headerlink" title="三、JDK动态代理"></a>三、JDK动态代理</h2><p>JDK动态代理具有如下的特点:</p><pre><code>1.代理对象,不需要实现接口2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)</code></pre><p>要使用JDK中的代理，我们首先需要了解JDK中的代理接口:</p><p>1、java.lang.reflect.Proxy：这是Java动态代理机制的主类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象。其中Proxy代理类中具有如下常用的核心方法:</p><pre><code>// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器static InvocationHandler getInvocationHandler(Object proxy) // 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象static Class getProxyClass(ClassLoader loader, Class[] interfaces) // 方法 3：该方法用于判断指定类对象是否是一个动态代理类static boolean isProxyClass(Class cl) // 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)</code></pre><p>2、java.lang.reflect.InvocationHandler：这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。该类具有如下的核心方法:</p><pre><code>// 该方法负责集中处理动态代理类上的所有方法调用。第一个参数既是代理类实例，第二个参数是被调用的方法对象// 第三个方法是调用参数。调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行Object invoke(Object proxy, Method method, Object[] args)</code></pre><p>每次生成动态代理类对象时都需要指定一个实现了该接口的调用处理器对象（参见 Proxy 静态方法 4 的第三个参数）。</p><p>3、java.lang.ClassLoader：这是类装载器类，负责将类的字节码装载到Java虚拟机（JVM）中并为其定义类对象，然后该类才能被使用。Proxy 静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是由 JVM 在运行时动态生成的而非预存在于任何一个 .class 文件中。每次生成动态代理类对象时都需要指定一个类装载器对象（参见 Proxy 静态方法 4 的第一个参数）。</p><p>动态代理的底层原理比较负责，这里直接进入动态代理的使用,以下是InvocationHandler接口的具体实现:</p><pre><code>package com.carleviets.jdk;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * JDK动态代理 */public class JdkHandler implements InvocationHandler {    //目标类    private Object target;    public JdkHandler(Object target) {        this.target = target;    }    /**     * 程序运行期间动态创建代理角色     * @return     */    public Object getProxy(){        /**         * 获取代理对象：         *  1、类加载器         *  2、目标类   实现的接口   class         *  3、当前类         */        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this);    }    public void before(){        System.out.println(&quot;婚礼现场紧张布置中...&quot;);    }    public void after(){        System.out.println(&quot;恭喜你成功进入人生的第二阶段...&quot;);    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        before();        Object object=method.invoke(target, args);        after();        return object;    }}</code></pre><p>以下是JDK动态代理的具体测试代码:</p><pre><code>package com.carleviets.jdk;import com.carleviets.demo.Person;import org.junit.Test;public class JdkHandlerTest {    @Test    public void test() throws Throwable {        Person you=new Person();  //委托类        JdkHandler handler=new JdkHandler(you); //代理工厂        Object proxy=handler.getProxy();        handler.invoke(proxy, Person.class.getMethod(&quot;toMarry&quot;), null);    //执行    }}</code></pre><h2 id="四、Cglib动态代理"><a href="#四、Cglib动态代理" class="headerlink" title="四、Cglib动态代理"></a>四、Cglib动态代理</h2><p>Cglib（code generator library，代码生成库),是一个第三方提供的动态代理实现方案。与JDK动态代理相比:<br></p><pre><code>Proxy代理：委托类必须有接口，制作过程比较快，执行较慢。Cglib代理:委托类可以没有接口,使用继承的思维来实现相似性，制作代理过程相对较慢，执行快。 主要用于解决没有接口类的代理实现。</code></pre><p>使用Cglib来实现代理需要实现MethodInterceptor接口，具体实现如下:</p><pre><code>package com.carleviets.cglib;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class CglibInterceptor implements MethodInterceptor {    //被代理的目标对象    private Object target;    public CglibInterceptor(Object target) {        this.target = target;    }    //运行期动态创建代理类    public Object getProxy(){        Enhancer enhancer=new Enhancer();        //设置父类  class        enhancer.setSuperclass(target.getClass());        enhancer.setCallback(this);        return enhancer.create();    }    public void before(){        System.out.println(&quot;婚礼现场紧张布置中...&quot;);    }    public void after(){        System.out.println(&quot;进入人生第二阶段，好嗨哟...&quot;);    }    @Override    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {        before();   //增强真实角色行为        Object result=methodProxy.invoke(target, objects);        after();    //增强真实角色行为        return result;    }}</code></pre><p>具体的测试代码如下:</p><pre><code>package com.carleviets.cglib;import com.carleviets.demo.Person;import org.junit.Test;public class CglibInterceptorTest {    @Test    public void test(){        //创建目标对象        Person you=new Person();        CglibInterceptor cglibInterceptor=new CglibInterceptor(you);        //获取代理对象        Person proxy= (Person) cglibInterceptor.getProxy();        //调用代理对象的方法        proxy.toMarry();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RMI远程方法调用</title>
      <link href="/2019/01/16/%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/"/>
      <url>/2019/01/16/%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、RMI介绍"><a href="#一、RMI介绍" class="headerlink" title="一、RMI介绍"></a>一、RMI介绍</h2><p>Java远程方法调用 (Remote Method Invocation，RMI)是一种机制，能够让在某个Java虚拟机上的对象调用另一个Java虚拟机中的对象上的方法。JVM可以位于相同或不同计算机上，在多个JVM中，一个JVM可以调用存储在其它JVM的对象的方法。</p><p>RMI是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口， 它是客户机上运行的程序可以调用远程服务器上的对象，远程方法调用特性使 Java 编程人员能够在网络环境中分布操作。</p><p>Java RMI极大地依赖于接口，在需要创建一个远程对象的时候，程序员通过传递一个接口来隐藏底层的实现细节，客户端得到的远程对象句柄正好与本地的根代码连接，由后者负责透过网络通信。 这样一来，程序员只需关心如何通过自己的接口句柄发送消息。</p><p>RMI底层封装了Socket反射机制——java语言当中分布式的基础（实现 java 之间的互相访问）。RMI 本质就是使用代理类来封装 Socket 的通信细节！ </p><h2 id="二、RMI实现常用API"><a href="#二、RMI实现常用API" class="headerlink" title="二、RMI实现常用API"></a>二、RMI实现常用API</h2><p>1）Remote接口：每一个要暴露出去的java类，都需要实现 Remote 接口，并且所有的方法必须抛出 RemoteException。</p><p>2）UnicastRemoteObject类:服务端程序的实现方案之一就是继承这个类，无参构造器也要抛出 RemoteException。</p><p>3）LocateRegistry类:创建能在特定接口接受调用远程对象注册服务程序。</p><pre><code>    public static Registry createRegistry(int port) throws RemoteException</code></pre><p>4) Naming类：提供了存储和获得远程对象注册服务程序中的远程对象进行引用的方法</p><pre><code>    public static Remote lookup(String name) throws NotBoundException, MalformedURException, ReoteException    public static void bind(String name,Remote obj) throws AlreadyBoundException, MalforedURException, RemoteException</code></pre><h2 id="三、通过Java-RMI远程方法调用"><a href="#三、通过Java-RMI远程方法调用" class="headerlink" title="三、通过Java RMI远程方法调用"></a>三、通过Java RMI远程方法调用</h2><p>下面是使用Maven的多模块模拟远程方法调用的过程，首先先建一个父工程<code>rmi_par</code>,在<code>rmi_par</code>模块下建立如下子模块：</p><pre><code>rmi_api模块：远程方法调用的接口定义rmi_server模块:远程方法调用的具体服务实现rmi_client模块:调用远程方法的具体模块</code></pre><h3 id="1、服务的接口定义——rmi-api模块"><a href="#1、服务的接口定义——rmi-api模块" class="headerlink" title="1、服务的接口定义——rmi_api模块"></a>1、服务的接口定义——rmi_api模块</h3><p>以下是服务接口的定义:</p><pre><code>package com.carleviets.service;import java.rmi.Remote;import java.rmi.RemoteException;/** * 1、接口继承自Remote * 2、对外服务方法声明RemoteException异常 */public interface IHelloService extends Remote {    String sayHello(String msg) throws RemoteException;}</code></pre><h3 id="2、服务接口的具体实现和发布——rmi-server模块"><a href="#2、服务接口的具体实现和发布——rmi-server模块" class="headerlink" title="2、服务接口的具体实现和发布——rmi_server模块"></a>2、服务接口的具体实现和发布——rmi_server模块</h3><p>以下是服务端服务接口的具体实现:</p><pre><code>package com.carleviets.service.impl;import com.carleviets.service.IHelloService;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;/** * 1、继承 UnicastRemoteObject * 2、提供无参构造，对外声明 RemoteException */public class HelloServiceImpl extends UnicastRemoteObject implements IHelloService {    protected HelloServiceImpl() throws RemoteException {    }    @Override    public String sayHello(String msg) throws RemoteException {        System.out.println(&quot;服务器端接收到消息：&quot;+msg);        return &quot;hello:&quot;+msg;    }}</code></pre><p>现在，就可以把服务发布出去了，具体的发布代码如下：</p><pre><code>package com.carleviets.service.impl;import java.net.MalformedURLException;import java.rmi.AlreadyBoundException;import java.rmi.Naming;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;/** * 对外发布服务 */public class Publish {    public static void main(String[] args) throws RemoteException, AlreadyBoundException, MalformedURLException {        //注册端口        LocateRegistry.createRegistry(8888);        //对外发布RMI服务        Naming.bind(&quot;rmi://127.0.0.1:8888/hello&quot;, new HelloServiceImpl());    }}</code></pre><h3 id="3、服务的调用——rmi-client模块"><a href="#3、服务的调用——rmi-client模块" class="headerlink" title="3、服务的调用——rmi_client模块"></a>3、服务的调用——rmi_client模块</h3><pre><code>package com.carleviets;import com.carleviets.service.IHelloService;import org.junit.Test;import java.net.MalformedURLException;import java.rmi.Naming;import java.rmi.NotBoundException;import java.rmi.RemoteException;public class TestRMI {    @Test    public void test() throws RemoteException, NotBoundException, MalformedURLException {        IHelloService helloService= (IHelloService) Naming.lookup(&quot;rmi://127.0.0.1:8888/hello&quot;);        String hello=helloService.sayHello(&quot;I&#39;m a hero.&quot;);        System.out.println(hello);    }}</code></pre><p>注意，这里只是通过maven的多模块对RMI远程调用进行模拟测试，在具体的现实环境中，要通过RMI进行远程方法调用，需要服务器端和客户端实现相同的接口。</p><h2 id="四、通过Spring来实现远程方法调用"><a href="#四、通过Spring来实现远程方法调用" class="headerlink" title="四、通过Spring来实现远程方法调用"></a>四、通过Spring来实现远程方法调用</h2><p>使用Spring的RMI，提供的服务简单方便，不用继承特定的类，也不需要抛出异常。</p><h3 id="1、-服务的接口定义——rmi-api模块："><a href="#1、-服务的接口定义——rmi-api模块：" class="headerlink" title="1、 服务的接口定义——rmi_api模块："></a>1、 服务的接口定义——rmi_api模块：</h3><pre><code>package com.carleviets.service;import java.rmi.Remote;import java.rmi.RemoteException;/** * 1、接口继承自Remote * 2、对外服务方法声明RemoteException异常 */public interface IHelloService extends Remote {    String sayHello(String msg) throws RemoteException;}</code></pre><p>可以看出，在提供服务的接口这一块儿，没有任何变化。</p><h3 id="2、服务接口的具体实现和发布——spring-server模块"><a href="#2、服务接口的具体实现和发布——spring-server模块" class="headerlink" title="2、服务接口的具体实现和发布——spring_server模块"></a>2、服务接口的具体实现和发布——spring_server模块</h3><pre><code>package com.carleviets.service.impl;import com.carleviets.service.IHelloService;import org.springframework.stereotype.Service;import java.rmi.RemoteException;/** * 使用spring实现服务器端服务 */@Servicepublic class HelloServiceImpl implements IHelloService {    @Override    public String sayHello(String msg) throws RemoteException {        System.out.println(&quot;服务端收到消息：&quot;+msg);        return &quot;hello:&quot;+msg;    }}</code></pre><p>同时，需要将上述的服务实现的具体类在spring的配置文件中通过相应的配置发布出去，具体配置如下:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!--定义组件扫描的范围--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets&quot;/&gt;    &lt;!--加入rmi相关配置--&gt;    &lt;bean class=&quot;org.springframework.remoting.rmi.RmiServiceExporter&quot;&gt;        &lt;!--配置对外提供服务的名称--&gt;        &lt;property name=&quot;serviceName&quot; value=&quot;hello&quot;/&gt;        &lt;!--指定服务的具体实现bean--&gt;        &lt;property name=&quot;service&quot; ref=&quot;helloServiceImpl&quot;/&gt;        &lt;!--配置发布的服务接口--&gt;        &lt;property name=&quot;serviceInterface&quot; value=&quot;com.carleviets.service.IHelloService&quot;/&gt;        &lt;!--配置服务注册的端口号--&gt;        &lt;property name=&quot;registryPort&quot; value=&quot;1199&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>这样，spring容器在启动的时候，就会自动将服务注册到对应的rmi地址上:</p><pre><code>package com.carleviets.service.impl;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 测试spring实现RMI的服务器端 */public class HelloServiceImplTest {    public static void main(String[] args) {        //布置RMI服务只需要启动容器即可        new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);    }}</code></pre><h3 id="3、客户端服务的调用——spring-client模块"><a href="#3、客户端服务的调用——spring-client模块" class="headerlink" title="3、客户端服务的调用——spring_client模块"></a>3、客户端服务的调用——spring_client模块</h3><p>要使用以上通过spring发布的服务，首先需要在spring.xml配置RMI代理工厂bean：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--配置Rmi代理工厂bean--&gt;    &lt;bean class=&quot;org.springframework.remoting.rmi.RmiProxyFactoryBean&quot;&gt;        &lt;!--指定提供服务的地址、端口和服务名称--&gt;        &lt;property name=&quot;serviceUrl&quot; value=&quot;rmi://localhost:1199/hello&quot;/&gt;        &lt;!-- 指定使用服务的接口 --&gt;        &lt;property name=&quot;serviceInterface&quot; value=&quot;com.carleviets.service.IHelloService&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>这样，就可以使用具体的服务了，如下是调用远程服务的测试代码:</p><pre><code>package com.carleviets;import com.carleviets.service.IHelloService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.rmi.RemoteException;/** * Spring实现RMI的客户端 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = {&quot;classpath:spring.xml&quot;})public class TestSpringRmiClient {    @Autowired    private IHelloService helloService;    @Test    public void test() throws RemoteException {        String hello=helloService.sayHello(&quot;I&#39;m spring rmi.&quot;);        System.out.println(hello);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rmi远程方法调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring mvc中的全局异常处理</title>
      <link href="/2019/01/16/Spring%20mvc%E4%B8%AD%E7%9A%84%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2019/01/16/Spring%20mvc%E4%B8%AD%E7%9A%84%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-mvc中的全局异常处理"><a href="#Spring-mvc中的全局异常处理" class="headerlink" title="Spring mvc中的全局异常处理"></a>Spring mvc中的全局异常处理</h1><p>在spring mvc中，对全局异常处理的支持有以下三种方式:</p><pre><code>1、使用Spring mvc提供的简单异常处理器 SimpleMappingExceptionResolver；2、实现Spring的异常处理接口 HandlerExceptionResolver 自定义自己的异常处理器;3、使用@ExceptionHandler 注解实现异常处理；4、控制器通知和@ExceptionHandler注解结合使用</code></pre><h2 id="一、使用SimpleMappingExceptionResolver进行异常处理"><a href="#一、使用SimpleMappingExceptionResolver进行异常处理" class="headerlink" title="一、使用SimpleMappingExceptionResolver进行异常处理"></a>一、使用SimpleMappingExceptionResolver进行异常处理</h2><p>使用Spring中的自带的SimpleMappingExceptionResolver类进行异常处理，具有集成简单、扩展性好、对已有代码没有侵入性等优点，但该方法仅能获取到异常信息，若在出现异常时，对需要获取除异常以外的数据的情况不适用。要使用SimpleMappingExceptionResolver，需要配置bean:</p><pre><code>&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;    &lt;!-- 为所有的异常定义默认的异常处理页面，exceptionMappings未定义的异常使用本默认配置 --&gt;    &lt;property name=&quot;defaultErrorView&quot; value=&quot;error&quot;/&gt;    &lt;!-- 定义异常处理页面用来获取异常信息的变量名，默认名为exception --&gt;    &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;/&gt;    &lt;!--定义需要特殊处理的异常，用类名或完全路径名作为key，异常页文件名作为值，将不同的异常映射到不同的页面上。--&gt;    &lt;property name=&quot;exceptionMappings&quot;&gt;        &lt;props&gt;            &lt;prop key=&quot;com.carleviets.exception.BusinessException&quot;&gt;business_error&lt;/prop&gt;            &lt;prop key=&quot;com.carleviets.exception.ParamsException&quot;&gt;params_error&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p>一个典型的异常显示界面如下：</p><pre><code>&lt;html&gt; &lt;head&gt;&lt;title&gt;Exception!&lt;/title&gt;&lt;/head&gt; &lt;body&gt; 　　&lt;% Exception e = (Exception)request.getAttribute(&quot;ex&quot;); %&gt; 　　&lt;H2&gt;Exception: &lt;%= e.getMessage();%&gt;&lt;/H2&gt; 　　&lt;P/&gt; 　　&lt;% e.printStackTrace(new java.io.PrintWriter(out)); %&gt; &lt;/body&gt; &lt;/html&gt; </code></pre><p>exception 是在 SimpleMappingExceptionResolver 被存放到 request 中的，具体可以查看源代码。</p><h2 id="二、实现-HandlerExceptionResolver-接口"><a href="#二、实现-HandlerExceptionResolver-接口" class="headerlink" title="二、实现 HandlerExceptionResolver 接口"></a>二、实现 HandlerExceptionResolver 接口</h2><p>使用这种方式只需要实现 resolveException 方法，该方法返回一个 ModelAndView 对象，在方法内部对异常的类型进行判断，然后返回合适的 ModelAndView 对象，如果该方法返回 null，则 Spring 会继续寻找其他的实现了 HandlerExceptionResolver 接口的 Bean。换句话说，Spring 会搜索所有注册在其环境中的实现了 HandlerExceptionResolver 接口的 Bean，逐个执行，直到返回了一个 ModelAndView 对象。</p><pre><code>package com.carleviets.exceptions.handler;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.HashMap;import java.util.Map;public class MyExceptionHandler implements HandlerExceptionResolver {    /**     *     * @param request     * @param response     * @param target   被调用的方法     * @param ex       用来接收异常的局部变量名     * @return     */    @Override    public ModelAndView resolveException(HttpServletRequest request,                                         HttpServletResponse response, Object target, Exception ex) {        //此处定义的Map实际上就是Spring mvc中的Model(Model的内部实现就是一个Map)        Map&lt;String,Object&gt; map=new HashMap&lt;String, Object&gt;();        map.put(&quot;ex&quot;, ex);        if(ex instanceof ParamsException){            return new ModelAndView(&quot;error_param&quot;, map);        }        if(ex instanceof BusinessException){            return new ModelAndView(&quot;error_business&quot;, map);        }        return new ModelAndView(&quot;error&quot;, map);    }}</code></pre><p>要注意，实现HandlerExceptionResolver接口的类必须声明到 Spring 配置文件中，或者使用 @Component 标签，让 Spring 管理它。</p><h2 id="三、使用-ExceptionHandler-注解实现异常处理"><a href="#三、使用-ExceptionHandler-注解实现异常处理" class="headerlink" title="三、使用 @ExceptionHandler 注解实现异常处理"></a>三、使用 @ExceptionHandler 注解实现异常处理</h2><p>该方法需要定义在某个 Controller 内部，表示能够处理同一个控制器中所有处理器方法抛出的相应异常。@ExceptionHandler 中可以添加一个或多个异常的类型，如果为空的话则认为可以触发所有的异常类型错误。</p><pre><code>package com.carleviets.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.ExceptionHandler;import javax.servlet.http.HttpServletRequest;import java.io.IOException;@Controllerpublic class  BaseController {    @ExceptionHandler(value={ParamsException.class,BusinessException.class, IOException.class})    public String exp(HttpServletRequest request, Exception ex) {        request.setAttribute(&quot;ex&quot;, ex);        if(ex instanceof ParamsException){            return &quot;error_param&quot;;        }        if(ex instanceof BusinessException){            return &quot;error_business&quot;;        }        return &quot;error&quot;;    }} </code></pre><p>上面我们写了一个BaseController,所有继承了该类的控制器就可以实现相应异常的处理。但这种方式对代码具有侵入性，考虑到Java具有单继承多实现的特点，这种方式不推荐使用。</p><h2 id="四、使用控制器通知"><a href="#四、使用控制器通知" class="headerlink" title="四、使用控制器通知"></a>四、使用控制器通知</h2><p>控制器通知是Spring 3.2引入的一个新特性，通俗来讲，控制器通知（controller advice）是任意带有@ControllerAdvice注解的类，这个类会包含一个或多个如下类型的方法：</p><pre><code>@ExceptionHandler 注解标注的方法；@InitBinder 注解标注的方法；@ModelAttribute 注解标注的方法</code></pre><p>在带有@ControllerAdvice注解的类中，以上所述的这些方法会运用到整个应用程序所有控制器中带有@RequestMapping注解的方法上。下面是Spring中ControllerAdvice的源码:</p><pre><code>@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface ControllerAdvice {    @AliasFor(&quot;basePackages&quot;)    String[] value() default {};    @AliasFor(&quot;value&quot;)    String[] basePackages() default {};    Class&lt;?&gt;[] basePackageClasses() default {};    Class&lt;?&gt;[] assignableTypes() default {};    Class&lt;? extends Annotation&gt;[] annotations() default {};}</code></pre><p>@ControllerAdvice注解本身已经使用了@Component，因此@ControllerAdvice注解所标注的类将会自动被组件扫描获取到，就像带有@Component注解的类一样。控制器通知最为实用的一个场景就是将所有的@ExceptionHandler方法收集到一个类中，这样所有控制器的异常就能在一个地方进行一致的处理。如下:</p><pre><code>package com.carleviets.exceptions.handler;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;//定义控制器通知@ControllerAdvicepublic class GlobalExceptionHandler {    //定义异常处理方法    @ExceptionHandler(BusinessException.class)    public String businessExceptionHandle(){        return &quot;error_business&quot;;    }    //定义异常处理方法    @ExceptionHandler(ParamsException.class)    public String businessExceptionHandle(){        return &quot;params_business&quot;;    }}</code></pre><h2 id="五、将具体的异常映射为HTTP状态码"><a href="#五、将具体的异常映射为HTTP状态码" class="headerlink" title="五、将具体的异常映射为HTTP状态码"></a>五、将具体的异常映射为HTTP状态码</h2><p>在默认情况下， Spring会将自身的一些异常自动转换为合适的状态码。但是我们也可以通过@ResponseStatus将具体的异常隐射为具体的HTTP状态码。</p><pre><code>package com.carleviets.exceptions;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.ResponseStatus;@ResponseStatus(value = HttpStatus.NOT_FOUND, reason = &quot;文档不存在&quot;)public class DocumentNotFoundException extends RuntimeException {}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 全局异常处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring定时任务的实现</title>
      <link href="/2019/01/14/Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2019/01/14/Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、通过xml的方式配置定时任务"><a href="#一、通过xml的方式配置定时任务" class="headerlink" title="一、通过xml的方式配置定时任务"></a>一、通过xml的方式配置定时任务</h2><p>以下是通过XML实现定时任务的具体Java代码:</p><pre><code>package com.carleviets;import org.springframework.stereotype.Component;@Componentpublic class TaskJob {    public void job01(){        System.out.println(&quot;job01...&quot;);    }    public void job02(){        System.out.println(&quot;job02...&quot;);    }}</code></pre><p>以下是使用XML配置定时任务时spring.xml的具体配置:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;   xmlns:task=&quot;http://www.springframework.org/schema/task&quot;   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd   http://www.springframework.org/schema/task   http://www.springframework.org/schema/task/spring-task.xsd&quot;&gt;    &lt;!--启动Spring组件扫描--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets&quot;/&gt;    &lt;!--XML的方式配置定时任务--&gt;    &lt;task:scheduled-tasks&gt;        &lt;task:scheduled ref=&quot;taskJob&quot; method=&quot;job01&quot; cron=&quot;0/5 * * * * ? &quot;/&gt;        &lt;task:scheduled ref=&quot;taskJob&quot; method=&quot;job02&quot; cron=&quot;0/2 * * * * ? &quot; /&gt;    &lt;/task:scheduled-tasks&gt;&lt;/beans&gt;</code></pre><h2 id="二、通过注解的方式配置定时任务"><a href="#二、通过注解的方式配置定时任务" class="headerlink" title="二、通过注解的方式配置定时任务"></a>二、通过注解的方式配置定时任务</h2><p>以下是通过注解的方式实现定时任务的具体Java代码：</p><pre><code>package com.carleviets;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;@Componentpublic class TaskJob {    @Scheduled(cron = &quot;0/5 * * * * ? &quot;)    public void job01(){        System.out.println(&quot;job03...&quot;);    }    @Scheduled(cron = &quot;0/2 * * * * ? &quot;)    public void job02(){        System.out.println(&quot;job04...&quot;);    }}</code></pre><p>以下是使用注解配置定时任务时spring.xml的具体配置:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;   xmlns:task=&quot;http://www.springframework.org/schema/task&quot;   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd   http://www.springframework.org/schema/task   http://www.springframework.org/schema/task/spring-task.xsd&quot;&gt;    &lt;!--启动Spring组件扫描--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets&quot;/&gt;      &lt;!--引入定时任务的注解驱动--&gt;       &lt;task:annotation-driven/&gt;&lt;/beans&gt;</code></pre><h2 id="三、分析总结"><a href="#三、分析总结" class="headerlink" title="三、分析总结"></a>三、分析总结</h2><p>不管是用过XML的方式还是通过注解的方式配置定时任务，都应该先引入spring-task的命名空间:</p><pre><code>xmlns:task=&quot;http://www.springframework.org/schema/taskhttp://www.springframework.org/schema/taskhttp://www.springframework.org/schema/task/spring-task.xsd</code></pre><p>其次，根据不同的情况来给定时任务的代码使用Cron表达式，具体Cron表达式的生成可参照: <a href="http://cron.qqe2.com/" target="_blank" rel="noopener">http://cron.qqe2.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Spring中的作用域问题</title>
      <link href="/2019/01/13/%E5%85%B3%E4%BA%8ESpring%E4%B8%ADbean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2019/01/13/%E5%85%B3%E4%BA%8ESpring%E4%B8%ADbean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="一、bean的四种作用域"><a href="#一、bean的四种作用域" class="headerlink" title="一、bean的四种作用域"></a>一、bean的四种作用域</h2><p>Spring定义了多种作用域，可以基于这些作用域创建bean，包括:</p><pre><code>单例（Singleton）：在整个应用中，只创建bean的一个实例。原型（Prototype）：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。会话（Session）：在Web应用中，为每个会话创建一个bean实例。请求（Rquest）：在Web应用中，为每个请求创建一个bean实例 </code></pre><p>在默认情况下， Spring应用上下文中所有bean都是作为以单例（singleton）的形式创建的。也就是说，不管给定的一个bean被注入到其他bean多少次，每次所注入的都是同一个实例。在大多数情况下，单例bean是很理想的方案。但是在某些情况下，你所使用的类是易变的（mutable），它们会保持一些状态，因此重用是不安全的。在这种情况下，将class声明为单例的bean就不是什么好主意了。</p><h2 id="二、使用其他作用域的bean"><a href="#二、使用其他作用域的bean" class="headerlink" title="二、使用其他作用域的bean"></a>二、使用其他作用域的bean</h2><p>要声明bean为其他作用域，可以使用@Scope注解，以下是用过@Scope注解和@Component注解一起使用，声明了一个原型作用域的bean：</p><pre><code>@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class Notepad{...}</code></pre><p>这里，使用ConfigurableBeanFactory类的<code>SCOPE_PROTOTYPE</code>常量设置了原型作用域。你当然也可以使用@Scope(“prototype”)，但是使用<code>SCOPE_PROTOTYPE</code>常量更加安全并且不易出错。</p><p>同样，@Scope注解也可以和@Bean注解一起使用:</p><pre><code>@Bean@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public Notepad notepad(){    return new Notepad();}</code></pre><p>同样，可以使用scope属性通过XML的方式配置其他作用域的bean:</p><pre><code>&lt;bean id=&quot;notepad&quot; class=&quot;com.carleviets.Notepad&quot; scope=&quot;prototype&quot;/&gt;</code></pre><h2 id="三、使用会话和请求作用域"><a href="#三、使用会话和请求作用域" class="headerlink" title="三、使用会话和请求作用域"></a>三、使用会话和请求作用域</h2><p>在典型的电子商务应用中，可能会有一个bean代表用户的购物车。如果购物车是单例的话，那么将会导致所有的用户都会向同一个购物车中添加商品。另一方面，如果购物车是原型作用域的，那么在应用中某一个地方往购物车中添加商品，在应用的另外一个地方可能就不可用了。就购物车bean来说，会话作用域是最为合适的，因为它与给定的用户关联性最大。</p><pre><code>@Component@Scope(value=WebApplicationContext.SCOPE_SESSION, proxyMode=ScopedProxyMode.INTERFACES)public class ShoppingCart{...}</code></pre><p>注意,@Scope同时还有一个proxyMode属性，它被设置成了ScopedProxyMode.INTERFACES。这个属性解决了将会话或请求作用域的bean注入到单例bean中所遇到的问题。例如，如下的StoreService bean表示在线商店提供的服务:</p><pre><code>@Componentpublic class StoreService{    private ShoppingCart shoppingCart;    @Autowired    public void setShoppingCart(ShoppingCart shoppingCart){        this.shoppingCart=shoppingCart;    }    ...}</code></pre><p>因为StoreService是一个单例的bean，会在Spring应用上下文加载的时候创建。当它创建的时候， Spring会试图将ShoppingCart bean注入到setShoppingCart()方法中。但是ShoppingCart bean是会话作用域的，此时并不存在。直到某个用户进入系统，创建了会话之后，才会出现ShoppingCart实例。</p><p>如果使用了proxyMode=ScopedProxyMode.INTERFACES的话，Spring并不会将实际的ShoppingCart bean注入到StoreService中，而是会注入一个到ShoppingCart bean的代理，如图所示。这个代理会暴露与ShoppingCart相同的方法，所以StoreService会认为它就是一个购物车。但是，当StoreService调用ShoppingCart的方法时，代理会对其进行懒解析并将调用委托给会话作用域内真正的ShoppingCart bean。</p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fz6igknkjlj30r00dy78f.jpg" alt="avatar"></p><p>这是使用的是Spring基于接口的代理，但如果ShoppingCart是一个具体的类的话，Spring就没有办法创建基于接口的代理了。此时，它必须使用CGLib来生成基于类的代理。所以，如果bean类型是具体类的话，我们必须要将proxyMode属性设置为ScopedProxyMode.TARGET_CLASS，以此来表明要以生成目标类扩展的方式创建代理。</p><p>尽管这里主要关注了会话作用域，但是请求作用域的bean会面临相同的装配问题。因此，请求作用域的bean应该也以作用域代理的方式进行注入。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 四种作用域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>邮件发送实的现</title>
      <link href="/2019/01/13/%E4%BD%BF%E7%94%A8JDK%E5%92%8C%E4%BD%BF%E7%94%A8Spring%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E7%9A%84%E5%8F%91%E9%80%81/"/>
      <url>/2019/01/13/%E4%BD%BF%E7%94%A8JDK%E5%92%8C%E4%BD%BF%E7%94%A8Spring%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E7%9A%84%E5%8F%91%E9%80%81/</url>
      
        <content type="html"><![CDATA[<h3 id="一、邮件发送相关的协议"><a href="#一、邮件发送相关的协议" class="headerlink" title="一、邮件发送相关的协议"></a>一、邮件发送相关的协议</h3><pre><code>SMTP： 简单邮件传输协议（Simple Mail Transfer Protocol），该协议定义了邮件发送的机制。POP3：邮局协议（Post Office Protocol），目前用的是版本3，也称POP3。POP3协议定义了接收电子邮件的标准。IMAP： 互联网消息协议(Internet Message Access Protocol)，是更高级的用于接收消息的协议，作为POP3的替代。MIME： 代表多用途因特网邮件扩展标准（Multipurpose Internet Mail Extensions） 。 它不是邮件传输协议。 但对传输内容的消息、       附件及其它的内容定义了格式。</code></pre><h3 id="二、JavaMail中的关键属性"><a href="#二、JavaMail中的关键属性" class="headerlink" title="二、JavaMail中的关键属性"></a>二、JavaMail中的关键属性</h3><pre><code>属性名                                   属性类型                             说明mail.smtp.host                              String                 SMTP服务器地址， 如smtp.sina.com.cnmail.smtp.port                           int                     SMTP服务器端口号，默认为 25mail.smtp.auth                              boolean                 SMTP服务器是否需要用户认证，默认为 falsemail.smtp.user                              String                 SMTP默认的登陆用户名mail.smtp.from                              String                 默认的邮件发送源地址mail.smtp.socketFactory.class             String                 socket工厂类类名， 通过设置该属性可以覆盖提供者默认的实现，                                                                必须实现 javax.NET.SocketFactory接口mail.smtp.socketFactory.port              int                       指定 socket 工厂类所用的端口号，如果没有规定， 则使用默认的端口号mail.smtp.socketFactory.fallback          boolean                 设置为 true时，当使用指定的socket类创建socket失败后，将使用                                                                Java.net.Socket 创建 socket， 默认为 truemail.smtp.timeout                          int                     I/O连接超时时间， 单位为毫秒，默认为永不超时</code></pre><h3 id="三、JavaMail中的关键对象"><a href="#三、JavaMail中的关键对象" class="headerlink" title="三、JavaMail中的关键对象"></a>三、JavaMail中的关键对象</h3><h4 id="3-1-Session对象"><a href="#3-1-Session对象" class="headerlink" title="3.1 Session对象"></a>3.1 Session对象</h4><p>创建 Session 对象时，并没有对应的物理连接， 它只不过是一对配置信息的集合。 Session 的主要作用包括两个方面：</p><pre><code>1） 接收各种配置属性信息：通过 Properties 对象设置的属性信息；2） 初始化JavaMail环境：根据JavaMail的配置文件，初始化JavaMail环境，以便通过Session对象创建其他重要类的实例。</code></pre><h4 id="3-2-Transport对象和Store对象"><a href="#3-2-Transport对象和Store对象" class="headerlink" title="3.2 Transport对象和Store对象"></a>3.2 Transport对象和Store对象</h4><p>Transport对象对应着邮件的发送，而Store对象对应着邮件的接收。</p><h4 id="3-3-Message对象"><a href="#3-3-Message对象" class="headerlink" title="3.3 Message对象"></a>3.3 Message对象</h4><p>Message对象即为用户发送的邮件，由于Messa类是一个抽象类，多数情况下使用其子类为javax.mail.internet.MimeMessage。MimeMessage是个能理解MIME类型和头的电子邮件消息。</p><h4 id="3-4-Address对象"><a href="#3-4-Address对象" class="headerlink" title="3.4 Address对象"></a>3.4 Address对象</h4><p>Address对象是邮件发送的地址，和Message一样，Address也是个抽象类。您用的是javax.mail.internet.InternetAddress类。</p><h4 id="3-5-Authenticator对象"><a href="#3-5-Authenticator对象" class="headerlink" title="3.5 Authenticator对象"></a>3.5 Authenticator对象</h4><p>JavaMail API利用Authenticator通过用户名和密码访问受保护的资源。对于JavaMail API来说，这些资源就是邮件服务器。</p><p>要使用 Authenticator，先创建一个抽象类的子类，并从getPasswordAuthentication()方法中返回PasswordAuthentication实例。 创建完<br>成后，您必需向session注册Authenticator。然后，在需要认证的时候，就会通知Authenticator。</p><h3 id="三、使用JDK实现邮件的发送功能"><a href="#三、使用JDK实现邮件的发送功能" class="headerlink" title="三、使用JDK实现邮件的发送功能"></a>三、使用JDK实现邮件的发送功能</h3><p>下面是通过JDK的方式实现邮件发送功能的代码：</p><pre><code>package com.carleviets.jdk;import com.carleviets.auth.MyAuthenticator;import javax.activation.DataHandler;import javax.activation.FileDataSource;import javax.mail.*;import javax.mail.internet.*;import java.io.File;import java.io.UnsupportedEncodingException;import java.util.Date;import java.util.Properties;/** *  通过JDK的方式发送邮件 */public class SendMail {    /**     * 发送一封带附件的html邮件     *  1、设置配置信息     *  2、创建Session对象，添加配置和授权     *  3、设置收件人、发件人和邮件信息     *  4、发送邮件     */    public void test() throws MessagingException, UnsupportedEncodingException {        //===============设置配置信息===============        //定义邮箱服务器配置        Properties properties=new Properties();        //163   邮件服务器地址        properties.put(&quot;mail.smtp.host&quot;, &quot;smtp.163.com&quot;);        //163   邮件服务器端口        properties.put(&quot;mail.smtp.port&quot;, &quot;25&quot;);        //163   邮件服务器认证属性        properties.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;);        //===============创建Session会话，添加配置和授权===============        Session session=Session.getInstance(properties,                new MyAuthenticator(&quot;carleviets0420@163.com&quot;, &quot;carleviets0318&quot;));        //===============设置收件人、发件人和邮件信息===============        Message message=new MimeMessage(session);        message.setFrom(new InternetAddress(&quot;carleviets0420@163.com&quot;)); //设置发件人邮箱地址        message.setRecipient(Message.RecipientType.TO, new InternetAddress(&quot;carleviets0420@163.com&quot;));  //设置收件人邮箱地址        //message.setRecipient(RecipientType.CC, new InternetAddress(&quot;xxx@163.com&quot;));//设置抄送人        //message.setRecipient(RecipientType.BCC, new InternetAddress(&quot;xxx@163.com&quot;));// 设置密送人        message.setSubject(&quot;我的第一封带附件的html邮件&quot;);  //设置主题        message.setSentDate(new Date());    //设置头部信息中的发件时间        Multipart multipart=new MimeMultipart();        //发送html邮件        BodyPart bodyPart1=new MimeBodyPart();        StringBuilder stringBuilder=new StringBuilder();        stringBuilder.append(&quot;&lt;html&gt;&lt;body&gt;&lt;a href=&#39;http://www.baidu.com&#39;&gt;狗日的百度&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&quot;);        bodyPart1.setContent(stringBuilder.toString(), &quot;text/html;charset=UTF-8&quot;);        multipart.addBodyPart(bodyPart1);        //发送带附件的邮件        BodyPart bodyPart2=new MimeBodyPart();        FileDataSource fileDataSource=new FileDataSource(new File(&quot;C:\\Users\\Administrator\\Desktop\\timg.jpg&quot;));        //设置附件        bodyPart2.setDataHandler(new DataHandler(fileDataSource));        //设置文件名——MimeUtility用于对文字进行Base64编码        bodyPart2.setFileName(MimeUtility.encodeText(&quot;高圆圆.jpg&quot;));        multipart.addBodyPart(bodyPart2);        message.setContent(multipart);        //===============发送邮件===============        Transport.send(message);    }}</code></pre><p>下面是实现邮箱认证的代码：</p><pre><code>package com.carleviets.auth;import javax.mail.Authenticator;import javax.mail.PasswordAuthentication;public class MyAuthenticator extends Authenticator {    private String username;    //邮箱名称    private String password;    //邮箱授权码    public MyAuthenticator(String username, String password) {        this.username = username;        this.password = password;    }    //重写Authenticator抽象类中的getPasswordAuthentication方法    @Override    protected PasswordAuthentication getPasswordAuthentication() {        return new PasswordAuthentication(username, password);    }}</code></pre><h3 id="四、JDK邮件发送代码的封装"><a href="#四、JDK邮件发送代码的封装" class="headerlink" title="四、JDK邮件发送代码的封装"></a>四、JDK邮件发送代码的封装</h3><p>如下是一个邮件发送信息类的简单封装，可以看出该类是一个简单的JavaBean：</p><pre><code>package com.carleviets.po.vo;import java.util.List;/** * 邮件发送信息类的简单封装 */public class MailSenderInfo {    private String serverHost;          //服务器主机    private String serverPort;          //服务器端口    private String fromAddress;         //发件人的邮箱地址    private List&lt;String&gt; toAddress;     //收件人邮箱地址    private String userName;            //邮件服务器用户名    private String userPwd;             //邮件服务器密码    private String subject;             //邮件主题    private String content;             //邮件内容    private String flag=&quot;true&quot;;          //邮件服务器认证属性    private List&lt;String&gt; attachFileNames;   //附件文件名    //===============getters and setters===============    ...}</code></pre><p>邮件发送具体类的实现如下:</p><pre><code>package com.carleviets.service;import com.carleviets.auth.MyAuthenticator;import com.carleviets.po.vo.MailSenderInfo;import javax.activation.DataHandler;import javax.activation.FileDataSource;import javax.mail.*;import javax.mail.internet.*;import java.io.File;import java.io.UnsupportedEncodingException;import java.util.Date;import java.util.List;import java.util.Properties;/** * 简单封装邮件发送器，实现邮件的发送 */public class MailSender {    public void sendHtmlMail(MailSenderInfo mailSendInfo){        Message message=null;        Session session=null;        try{            MyAuthenticator authenticator=new MyAuthenticator(mailSendInfo.getUserName(), mailSendInfo.getUserPwd());            //===============定义邮箱服务器配置================            Properties properties=new Properties();            //163   邮件服务器地址            properties.put(&quot;mail.smtp.host&quot;, mailSendInfo.getServerHost());            //163   邮件服务器端口            properties.put(&quot;mail.smtp.port&quot;, mailSendInfo.getServerPort());            //163   邮件服务器认证属性            properties.put(&quot;mail.smtp.auth&quot;, mailSendInfo.getFlag());            //===============创建Session对象，添加配置和授权===============            session=Session.getInstance(properties, authenticator);            //===============设置收件人、发件人和邮件信息===============            message=new MimeMessage(session);            Address from=new InternetAddress(mailSendInfo.getFromAddress());            message.setFrom(from);            message.setSentDate(new Date());            if(mailSendInfo.getToAddress()!=null &amp;&amp; mailSendInfo.getToAddress().size()&gt;0){                Address[] addresses=new Address[mailSendInfo.getToAddress().size()];                for (int i=0;i&lt;mailSendInfo.getToAddress().size();i++){                    Address address=new InternetAddress(mailSendInfo.getToAddress().get(i));                    addresses[i]=address;                }                message.setRecipients(Message.RecipientType.TO, addresses); //设置收件人地址                message.setSubject(mailSendInfo.getSubject());                Multipart multipart=new MimeMultipart();                BodyPart bodyPart=new MimeBodyPart();                bodyPart.setContent(mailSendInfo.getContent(), &quot;text/html;charset=utf-8&quot;);                multipart.addBodyPart(bodyPart);                //附件添加                List&lt;String&gt; files=mailSendInfo.getAttachFileNames();                if(files!=null&amp;&amp; files.size()&gt;0){                    for(int i=0;i&lt;files.size();i++){                        File tempFile=new File(files.get(i));                        if(tempFile.exists()){                            BodyPart temp=new MimeBodyPart();                            temp.setDataHandler(new DataHandler(new FileDataSource(tempFile)));                            temp.setFileName(MimeUtility.encodeText(tempFile.getName()));   //设置文件名                            multipart.addBodyPart(temp);    //添加附件                        }                    }                }                //设置邮件内容                message.setContent(multipart);                //===============发送邮件===============                Transport.send(message);            }        } catch (AddressException e) {            e.printStackTrace();        } catch (MessagingException e) {            e.printStackTrace();        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        }    }}</code></pre><p>测试代码很简单，这里略去。</p><h3 id="五、使用spring来实现邮件的发送"><a href="#五、使用spring来实现邮件的发送" class="headerlink" title="五、使用spring来实现邮件的发送"></a>五、使用spring来实现邮件的发送</h3><h4 id="5-1-maven坐标依赖"><a href="#5-1-maven坐标依赖" class="headerlink" title="5.1 maven坐标依赖"></a>5.1 maven坐标依赖</h4><pre><code>&lt;!--junit测试依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;junit&lt;/groupId&gt;  &lt;artifactId&gt;junit&lt;/artifactId&gt;  &lt;version&gt;4.12&lt;/version&gt;  &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--spring-test测试--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-test&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring核心依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring 上下文环境支持--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--java mail邮件发送--&gt;&lt;dependency&gt;  &lt;groupId&gt;javax.mail&lt;/groupId&gt;  &lt;artifactId&gt;mail&lt;/artifactId&gt;  &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="5-2-spring-xml具体配置"><a href="#5-2-spring-xml具体配置" class="headerlink" title="5.2 spring.xml具体配置"></a>5.2 spring.xml具体配置</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--配置JavaMailSenderImpl bean--&gt;    &lt;bean id=&quot;mailSender&quot; class=&quot;org.springframework.mail.javamail.JavaMailSenderImpl&quot;&gt;        &lt;property name=&quot;host&quot; value=&quot;smtp.163.com&quot;/&gt;        &lt;property name=&quot;port&quot; value=&quot;25&quot;/&gt;        &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;carleviets0420@163.com&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;carleviets0318&quot;/&gt;        &lt;property name=&quot;javaMailProperties&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;mail.smtp.auth&quot;&gt;true&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!--this is a template message that we can preload with a default state--&gt;    &lt;!--配置SimpleMailMessage bean--&gt;    &lt;bean id=&quot;templateMessage&quot; class=&quot;org.springframework.mail.SimpleMailMessage&quot;&gt;        &lt;property name=&quot;from&quot; value=&quot;carleviets0420@163.com&quot;/&gt;        &lt;property name=&quot;subject&quot; value=&quot;spring email&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置发送邮件的bean--&gt;    &lt;bean id=&quot;mailManager&quot; class=&quot;com.carleviets.springimpl.SimpleMailManager&quot;&gt;        &lt;property name=&quot;mailSender&quot; ref=&quot;mailSender&quot;/&gt;        &lt;property name=&quot;mailMessage&quot; ref=&quot;templateMessage&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h4 id="5-3定义邮件发送接口"><a href="#5-3定义邮件发送接口" class="headerlink" title="5.3定义邮件发送接口"></a>5.3定义邮件发送接口</h4><pre><code>package com.carleviets.springInterface;/** *  发送邮件接口的定义 */public interface MailManager {    void placeMail();}</code></pre><h4 id="5-4定义邮件发送接口"><a href="#5-4定义邮件发送接口" class="headerlink" title="5.4定义邮件发送接口"></a>5.4定义邮件发送接口</h4><pre><code>package com.carleviets.springimpl;import com.carleviets.springInterface.MailManager;import org.springframework.mail.MailException;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSenderImpl;/** * 发送邮件的简单实现类——在发送邮件的方法中实现发送邮件的代码 */public class SimpleMailManager implements MailManager {    @Autowired    private JavaMailSenderImpl mailSender;    @Autowired    private SimpleMailMessage mailMessage;    @Override    public void placeMail() {        mailMessage.setTo(&quot;carleviets0420@163.com&quot;);        mailMessage.setText(&quot;江火似流萤...&quot;);        try{            mailSender.send(message);        }catch (MailException ex){            System.err.println(ex.getMessage());        }    }}</code></pre><p>普通邮件测试代码如下：</p><pre><code>@Testpublic void test(){    mailManager.placeMail();}</code></pre><h4 id="5-5使用spring发送带附件的邮件"><a href="#5-5使用spring发送带附件的邮件" class="headerlink" title="5.5使用spring发送带附件的邮件"></a>5.5使用spring发送带附件的邮件</h4><p>使用spring发送带附件的邮件步骤和普通邮件一样，只是需要借助MimeMessageHelper辅助类来设置消息的属性。具体测试代码如下：</p><pre><code>/** * 测试通过spring发送带有附件的邮件 * @throws MessagingException */@Testpublic void test() throws MessagingException {    ApplicationContext applicationContext=            new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);    JavaMailSender mailSender= (JavaMailSender) applicationContext.getBean(&quot;mailSender&quot;);    MimeMessage message=mailSender.createMimeMessage();    message.setSubject(&quot;spring mail file&quot;);    //创建带有附件的消息帮助类    MimeMessageHelper helper=new MimeMessageHelper(message, true, &quot;utf-8&quot;);    helper.setTo(new InternetAddress(&quot;carleviets0420@163.com&quot;));    //设置接收人    helper.setText(&quot;Thank you for ordering!&quot;);    helper.setFrom(&quot;carleviets0420@163.com&quot;);    helper.addAttachment(&quot;timg.jpg&quot;, new File(&quot;C:\\Users\\Administrator\\Desktop\\timg.jpg&quot;));    mailSender.send(message);}</code></pre><p>至此，我们就实现了通过JDK的方式和通过Spring Mail的方式来实现邮件的发送。</p>]]></content>
      
      
      <categories>
          
          <category> Java Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 邮件发送 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用工具类总结</title>
      <link href="/2019/01/13/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/13/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1-1、AssertUtil"><a href="#1-1、AssertUtil" class="headerlink" title="1.1、AssertUtil"></a>1.1、AssertUtil</h3><p>该实用工具类主要通过断言的思想，在相应的条件成立下，通过抛出异常的方式来阻止代码的继续执行，可以在很多情况下将需要好几行的代码浓缩为只有一行代码，并且可以配合全局异常处理器的使用来将异常处理集中到处理器中。具体如下:</p><pre><code>package com.carleviets.crm.utils;import com.carleviets.crm.exceptions.LoginException;import com.carleviets.crm.exceptions.ParamsException;public class AssertUtil {    public static void isTrue(Boolean flag, String msg){        if(flag){            throw new ParamsException(msg);        }    }    public static void isTrue(Boolean flag, Integer code, String msg){        if(flag){            throw new ParamsException(code, msg);        }    }    public static void isNotLogin(Boolean flag, String msg) {        if(flag){            throw new LoginException(msg);        }    }}</code></pre><h3 id="1-2、JsonUtil"><a href="#1-2、JsonUtil" class="headerlink" title="1.2、JsonUtil"></a>1.2、JsonUtil</h3><p>该实用工具类主要用于将java对象以JSON字符串的形式响应给客户端，具体代码如下：</p><pre><code>package com.carleviets.crm.utils;import com.alibaba.fastjson.JSON;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class JsonUtil {    /**     * 将对象转换为json字符串并发送到前台     * @param object     * @param response     */    public static void toJson(Object object, HttpServletResponse response){        try {            //将对象转换为json字符串            String jsonStr= JSON.toJSONString(object);            //设置响应类型及编码            response.setContentType(&quot;application/json;charset=utf-8&quot;);            //得到输出流            PrintWriter out=response.getWriter();            out.write(jsonStr);            out.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><h3 id="1-3、MD5Util"><a href="#1-3、MD5Util" class="headerlink" title="1.3、MD5Util"></a>1.3、MD5Util</h3><p>该实用工具类主要用于对字符串进行MD5加密，具体代码如下:</p><pre><code>package com.carleviets.crm.utils;import org.apache.commons.codec.binary.Base64;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class MD5Util {    public static String encode(String str){        String value=&quot;&quot;;        try {            //得到MD5加密的算法程序            MessageDigest messageDigest=MessageDigest.getInstance(&quot;MD5&quot;);            //对字符串进行MD5加密，返回byte数组            byte[] bytes=messageDigest.digest(str.getBytes());            //使用Base64对byte数组进行编码            value=Base64.encodeBase64String(bytes);        } catch (NoSuchAlgorithmException e) {            e.printStackTrace();        }        return value;    }    public static void main(String[] args) {        System.out.println(encode(&quot;12345&quot;));    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用工具类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM整合依赖及配置总结</title>
      <link href="/2019/01/13/SSM%E6%95%B4%E5%90%88%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/13/SSM%E6%95%B4%E5%90%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、所需引入的maven依赖"><a href="#一、所需引入的maven依赖" class="headerlink" title="一、所需引入的maven依赖"></a>一、所需引入的maven依赖</h2><h3 id="1-1测试依赖"><a href="#1-1测试依赖" class="headerlink" title="1.1测试依赖"></a>1.1测试依赖</h3><pre><code>&lt;!--junit测试依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;junit&lt;/groupId&gt;  &lt;artifactId&gt;junit&lt;/artifactId&gt;  &lt;version&gt;4.12&lt;/version&gt;  &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--spring测试依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-test&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-2-spring核心依赖"><a href="#1-2-spring核心依赖" class="headerlink" title="1.2 spring核心依赖"></a>1.2 spring核心依赖</h3>   <!--spring上下文依赖--><pre><code>&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectj切面代理--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;  &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;  &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-3-数据库相关"><a href="#1-3-数据库相关" class="headerlink" title="1.3 数据库相关"></a>1.3 数据库相关</h3><pre><code>&lt;!--spring jdbc--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring 事务管理--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--c3p0连接池--&gt;&lt;dependency&gt;  &lt;groupId&gt;com.mchange&lt;/groupId&gt;  &lt;artifactId&gt;c3p0&lt;/artifactId&gt;  &lt;version&gt;0.9.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis核心依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;  &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis与spring整合依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;  &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql数据库驱动包--&gt;&lt;dependency&gt;  &lt;groupId&gt;mysql&lt;/groupId&gt;  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  &lt;version&gt;8.0.11&lt;/version&gt;&lt;/dependency&gt;    &lt;!--mybatis分页插件--&gt;&lt;dependency&gt;  &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;  &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;  &lt;version&gt;4.1.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-4-日志打印"><a href="#1-4-日志打印" class="headerlink" title="1.4 日志打印"></a>1.4 日志打印</h3><pre><code>&lt;!--日志打印相关jar--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;  &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;  &lt;version&gt;1.7.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;  &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;  &lt;version&gt;1.7.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-5-spring-mvc依赖"><a href="#1-5-spring-mvc依赖" class="headerlink" title="1.5 spring-mvc依赖"></a>1.5 spring-mvc依赖</h3><pre><code>&lt;!--spring web--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-web&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring webmvc--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring mvc上下文支持 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--web servlet--&gt;&lt;dependency&gt;  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;  &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;  &lt;version&gt;3.0.1&lt;/version&gt;  &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;</code></pre><h3 id="1-6-json支持"><a href="#1-6-json支持" class="headerlink" title="1.6 json支持"></a>1.6 json支持</h3><pre><code>&lt;!--json依赖jar--&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;  &lt;version&gt;2.9.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;  &lt;version&gt;2.9.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;  &lt;version&gt;2.9.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--阿里巴巴 fastjson --&gt;&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-7-Apache-commons文件上传支持"><a href="#1-7-Apache-commons文件上传支持" class="headerlink" title="1.7 Apache-commons文件上传支持"></a>1.7 Apache-commons文件上传支持</h3><pre><code>&lt;!--commons文件上传--&gt;&lt;dependency&gt;  &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;  &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;  &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-8其他工具包"><a href="#1-8其他工具包" class="headerlink" title="1.8其他工具包"></a>1.8其他工具包</h3><pre><code>&lt;!-- commons-lang3实用工具类 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;  &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;  &lt;version&gt;3.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Base64编码解码支持 --&gt;&lt;dependency&gt;  &lt;groupId&gt;commons-codec&lt;/groupId&gt;  &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;  &lt;version&gt;1.10&lt;/version&gt;&lt;/dependency&gt;&lt;!-- freemarker视图模板 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.freemarker&lt;/groupId&gt;  &lt;artifactId&gt;freemarker&lt;/artifactId&gt;  &lt;version&gt;2.3.23&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>###1.9其他配置###</p><pre><code>&lt;!--指定资源访问路径，默认情况下为src/main/resources目录--&gt;&lt;resources&gt;  &lt;resource&gt;    &lt;directory&gt;src/main/resources/${env}&lt;/directory&gt;  &lt;/resource&gt;  &lt;resource&gt;    &lt;directory&gt;src/main/java&lt;/directory&gt;    &lt;includes&gt;      &lt;include&gt;**/*.xml&lt;/include&gt;      &lt;include&gt;**/*.properties&lt;/include&gt;      &lt;include&gt;**/*.tld&lt;/include&gt;    &lt;/includes&gt;    &lt;filtering&gt;false&lt;/filtering&gt;  &lt;/resource&gt;&lt;/resources&lt;plugins&gt;  &lt;!--如果用到了Base64编码，需要指定编译的虚拟机--&gt;  &lt;plugin&gt;    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;    &lt;configuration&gt;      &lt;source&gt;1.8&lt;/source&gt;      &lt;target&gt;1.8&lt;/target&gt;      &lt;encoding&gt;utf-8&lt;/encoding&gt;      &lt;compilerArguments&gt;        &lt;bootclasspath&gt;${java.home}/lib/rt.jar&lt;/bootclasspath&gt;      &lt;/compilerArguments&gt;    &lt;/configuration&gt;  &lt;/plugin&gt;  &lt;!--jetty服务器插件--&gt;  &lt;plugin&gt;    &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;    &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;    &lt;version&gt;6.1.25&lt;/version&gt;    &lt;configuration&gt;      &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt;      &lt;contextPath&gt;/crm&lt;/contextPath&gt;      &lt;webDefaultXml&gt;src/main/resources/${env}/webdefault.xml&lt;/webDefaultXml&gt;    &lt;/configuration&gt;  &lt;/plugin&gt;  &lt;!--mybatis代码自动生成插件--&gt;  &lt;plugin&gt;      &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;      &lt;version&gt;1.3.2&lt;/version&gt;      &lt;configuration&gt;        &lt;configurationFile&gt;src/main/resources/${env}/generatorConfig.xml&lt;/configurationFile&gt;        &lt;verbose&gt;true&lt;/verbose&gt;        &lt;overwrite&gt;true&lt;/overwrite&gt;      &lt;/configuration&gt;  &lt;/plugin&gt;&lt;/plugins&gt;&lt;!--配置不同的环境打包--&gt;&lt;profiles&gt;    &lt;!--默认开发环境--&gt;    &lt;profile&gt;      &lt;id&gt;dev&lt;/id&gt;      &lt;properties&gt;        &lt;env&gt;dev&lt;/env&gt;      &lt;/properties&gt;      &lt;!--此处指定哪个环境激活打包时就打哪个环境下的包--&gt;      &lt;activation&gt;        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;      &lt;/activation&gt;    &lt;/profile&gt;    &lt;!--测试环境--&gt;    &lt;profile&gt;      &lt;id&gt;test&lt;/id&gt;      &lt;properties&gt;        &lt;env&gt;test&lt;/env&gt;      &lt;/properties&gt;    &lt;/profile&gt;    &lt;!--生产环境--&gt;    &lt;profile&gt;      &lt;id&gt;product&lt;/id&gt;      &lt;properties&gt;        &lt;env&gt;product&lt;/env&gt;      &lt;/properties&gt;    &lt;/profile&gt;&lt;/profiles&gt;</code></pre><h2 id="二、配置文件总结"><a href="#二、配置文件总结" class="headerlink" title="二、配置文件总结"></a>二、配置文件总结</h2><h3 id="2-1-web-xml配置文件"><a href="#2-1-web-xml配置文件" class="headerlink" title="2.1 web.xml配置文件"></a>2.1 web.xml配置文件</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt;  &lt;!--配置ContextLoaderListener监听的上下文参数--&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;!--配置ContextLoaderListener上下文监听器--&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;!--配置字符过滤器--&gt;  &lt;filter&gt;    &lt;description&gt;char encoding filter&lt;/description&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;utf-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  &lt;!--配置spring-mvc前端控制器--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:servlet-context.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;!--注意次数映射路径不能为&quot;/*&quot;--&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><h3 id="2-2-spring-xml-配置文件"><a href="#2-2-spring-xml-配置文件" class="headerlink" title="2.2 spring.xml 配置文件"></a>2.2 spring.xml 配置文件</h3><p>该配置文件主要用于管理除了Controller层之外所有其它层的bean,配置如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:task=&quot;http://www.springframework.org/schema/task&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/task        http://www.springframework.org/schema/task/spring-task.xsd&quot;&gt;    &lt;!--开启组件扫描，通过注解的形式排除掉controller包--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets.crm&quot;&gt;        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;    &lt;/context:component-scan&gt;    &lt;!--指定数据库配置文件所在位置--&gt;    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;    &lt;!--配置c3p0数据源--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt;        &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置spring事务管理器并注入数据源--&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置事务通知--&gt;    &lt;tx:advice id=&quot;transactionInterceptor&quot; transaction-manager=&quot;transactionManager&quot;&gt;        &lt;tx:attributes&gt;            &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;load*&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;del*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!--通过aop切面配置事务管理--&gt;    &lt;aop:config&gt;        &lt;aop:pointcut id=&quot;servicePointCut&quot; expression=&quot;execution(* com.carleviets.crm.service..*.*(..))&quot;/&gt;        &lt;aop:advisor advice-ref=&quot;transactionInterceptor&quot; pointcut-ref=&quot;servicePointCut&quot;/&gt;    &lt;/aop:config&gt;    &lt;!--配置mybatis sqlSessionFactory bean--&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis.xml&quot;/&gt;        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/carleviets/crm/mapper/*.xml&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置mybatis包扫描器--&gt;    &lt;bean id=&quot;scannerConfigurer&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;!-- 扫描com.carleviets.crm.dao这个包以及它的子包下的所有映射接口类 --&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.carleviets.crm.dao&quot;/&gt;        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;    &lt;/bean&gt;    &lt;!--启用定时任务的注解驱动--&gt;    &lt;task:annotation-driven/&gt;&lt;/beans&gt;</code></pre><h3 id="2-2-servlet-context-xml-配置文件"><a href="#2-2-servlet-context-xml-配置文件" class="headerlink" title="2.2 servlet-context.xml 配置文件"></a>2.2 servlet-context.xml 配置文件</h3><p>该配置文件用于配置spring-mvc,即管理所谓的Controller层的bean，配置如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!--开启组件扫描,并且只扫描controller包--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets.crm.controller&quot;/&gt;    &lt;!--开启aspectj自动代理，由于controller层调用service层,service层dao层，故在此文件配置的aspectj自动代理可以代理其它层--&gt;    &lt;aop:aspectj-autoproxy/&gt;    &lt;!--配置freemarker配置--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;        &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/views/&quot;/&gt;        &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置freemarker视图解析器--&gt;    &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;&quot;/&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot;/&gt;        &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=utf-8&quot;/&gt;    &lt;/bean&gt;    &lt;!--mvc注解驱动并添加对响应json的支持, 可不配，内部自动提供--&gt;    &lt;mvc:annotation-driven&gt;        &lt;mvc:message-converters&gt;            &lt;!--返回信息为字符串时处理--&gt;            &lt;bean id=&quot;stringHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;/&gt;            &lt;!--将对象转化为json字符串--&gt;            &lt;bean id=&quot;jackson2HttpMessageConverter&quot; class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;/&gt;        &lt;/mvc:message-converters&gt;    &lt;/mvc:annotation-driven&gt;    &lt;!--配置对静态资源的放行处理 方式一--&gt;    &lt;!--&lt;mvc:default-servlet-handler/&gt;--&gt;    &lt;!--配置对静态资源的放行处理 方式二--&gt;    &lt;mvc:resources mapping=&quot;/statics/**&quot; location=&quot;/statics/&quot;/&gt;    &lt;!--配置拦截器--&gt;    &lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;            &lt;!--拦截所有路径--&gt;            &lt;mvc:mapping path=&quot;/**&quot;/&gt;            &lt;!--静态资源放行--&gt;            &lt;mvc:exclude-mapping path=&quot;/statics/**&quot;/&gt;            &lt;!--登录页面放行--&gt;            &lt;mvc:exclude-mapping path=&quot;/index&quot;/&gt;            &lt;!--登录操作放行--&gt;            &lt;mvc:exclude-mapping path=&quot;/user/login&quot;/&gt;            &lt;!--配置拦截器bean--&gt;            &lt;bean class=&quot;com.carleviets.crm.interceptor.LoginInterceptor&quot;/&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;&lt;/beans&gt;</code></pre><h3 id="2-3-mybatis-xml-配置文件"><a href="#2-3-mybatis-xml-配置文件" class="headerlink" title="2.3 mybatis.xml 配置文件"></a>2.3 mybatis.xml 配置文件</h3><p>该配置文件用于配置mybatis的别名扫描和分页插件配置，如果不需要别名和分页可不配置此文件。具体配置如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--配置mybatis别名包扫描--&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;com.carleviets.crm.po&quot;/&gt;    &lt;/typeAliases&gt;    &lt;!--配置mybatis分页插件--&gt;    &lt;plugins&gt;        &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt;            &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;            &lt;!-- 该参数默认为false --&gt;            &lt;!-- 设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用 --&gt;            &lt;!-- 和startPage中的pageNum效果一样 --&gt;            &lt;property name=&quot;offsetAsPageNum&quot; value=&quot;true&quot;/&gt;            &lt;!-- 该参数默认为false --&gt;            &lt;!-- 设置为true时，使用RowBounds分页会进行count查询 --&gt;            &lt;property name=&quot;rowBoundsWithCount&quot; value=&quot;true&quot;/&gt;            &lt;!-- 设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果 --&gt;            &lt;!-- （相当于没有执行分页查询，但是返回结果仍然是Page类型） --&gt;            &lt;property name=&quot;pageSizeZero&quot; value=&quot;true&quot;/&gt;            &lt;!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 --&gt;            &lt;!-- 启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;pages会查询最后一页 --&gt;            &lt;!-- 禁用合理化时，如果pageNum&lt;1或pageNum&gt;pages会返回空数据 --&gt;            &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt;            &lt;!-- 3.5.0版本可用 - 为了支持startPage(Object params)方法 --&gt;            &lt;!-- 增加了一个`params`参数来配置参数映射，用于从Map或ServletRequest中取值 --&gt;            &lt;!-- 可以配置pageNum,pageSize,count,pageSizeZero,reasonable,不配置映射的用默认值 --&gt;            &lt;property name=&quot;params&quot; value=&quot;pageNum=start;pageSize=limit;pageSizeZero=zero;reasonable=heli;count=contsql&quot;/&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/configuration&gt;</code></pre><h3 id="2-4-generatorConfig-xml-配置文件"><a href="#2-4-generatorConfig-xml-配置文件" class="headerlink" title="2.4 generatorConfig.xml 配置文件"></a>2.4 generatorConfig.xml 配置文件</h3><p>该配置文件用于mybatis代码的逆向生成，要使用mybatis代码自动生成的功能需要在pom.xml中配置mybatis代码自动生成插件，插件的引入如下:</p><pre><code>&lt;!--mybatis代码自动生成插件--&gt;  &lt;plugin&gt;      &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;      &lt;version&gt;1.3.2&lt;/version&gt;      &lt;configuration&gt;        &lt;configurationFile&gt;src/main/resources/${env}/generatorConfig.xml&lt;/configurationFile&gt;        &lt;verbose&gt;true&lt;/verbose&gt;        &lt;overwrite&gt;true&lt;/overwrite&gt;      &lt;/configuration&gt;  &lt;/plugin&gt;</code></pre><p>generatorConfig.xml 配置文件的具体配置如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;!--数据库驱动，此处的路径为maven仓库下mysql数据库驱动所对应的路径--&gt;    &lt;classPathEntry location=&quot;D:/apache-maven-3.6.0/Repositories/mysql/mysql-connector-java/8.0.11/mysql-connector-java-8.0.11.jar&quot;/&gt;    &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;    &lt;!--生成的代码中不需要注释--&gt;    &lt;commentGenerator&gt;        &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;        &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;    &lt;/commentGenerator&gt;    &lt;!--数据库链接地址、账号和密码--&gt;    &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/project?useSSL=false&amp;amp;serverTimezone=GMT%2B8&quot; userId=&quot;root&quot; password=&quot;12345&quot;&gt;    &lt;/jdbcConnection&gt;    &lt;javaTypeResolver&gt;        &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;    &lt;/javaTypeResolver&gt;    &lt;!--生成Model类存放位置，此处路径为项目下src/main/java的绝对路径--&gt;    &lt;javaModelGenerator targetPackage=&quot;com.carleviets.crm.po&quot; targetProject=&quot;C:/Users/Administrator/IdeaProjects/crm_2/src/main/java&quot;&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;    &lt;/javaModelGenerator&gt;    &lt;!--生成映射文件存放位置，此处路径为项目下src/main/java的绝对路径--&gt;    &lt;sqlMapGenerator targetPackage=&quot;com.carleviets.crm.mapper&quot; targetProject=&quot;C:/Users/Administrator/IdeaProjects/crm_2/src/main/java&quot;&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;    &lt;/sqlMapGenerator&gt;    &lt;!--生成Dao类存放位置，此处路径为项目下src/main/java的绝对路径--&gt;    &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.carleviets.crm.dao&quot; targetProject=&quot;C:/Users/Administrator/IdeaProjects/crm_2/src/main/java&quot;&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;    &lt;/javaClientGenerator&gt;    &lt;!--指定需要生成代码、映射文件、Mapper接口的表--&gt;    &lt;table tableName=&quot;t_customer&quot; domainObjectName=&quot;Customer&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><h3 id="2-5-其他配置文件"><a href="#2-5-其他配置文件" class="headerlink" title="2.5 其他配置文件"></a>2.5 其他配置文件</h3><p>数据库属性文件db.properties:</p><pre><code>jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/crm?useSSL=false&amp;serverTimezone=GMT%2B8jdbc.username=rootjdbc.password=12345</code></pre><p>日志打印文件log4j.properties：</p><pre><code>log4j.rootLogger=DEBUG, Console  #Consolelog4j.appender.Console=org.apache.log4j.ConsoleAppender  log4j.appender.Console.layout=org.apache.log4j.PatternLayout  log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n  log4j.logger.java.sql.ResultSet=INFO  log4j.logger.org.apache=INFO  log4j.logger.java.sql.Connection=DEBUG  log4j.logger.java.sql.Statement=DEBUG  log4j.logger.java.sql.PreparedStatement=DEBUG </code></pre>]]></content>
      
      
      <categories>
          
          <category> SSM整合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven依赖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM整合时高可用代码总结</title>
      <link href="/2019/01/13/SSM%E6%95%B4%E5%90%88%E6%97%B6%E9%AB%98%E5%8F%AF%E7%94%A8%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/13/SSM%E6%95%B4%E5%90%88%E6%97%B6%E9%AB%98%E5%8F%AF%E7%94%A8%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1、BaseDAO"><a href="#1、BaseDAO" class="headerlink" title="1、BaseDAO"></a>1、BaseDAO</h3><p>baseDAO是一个高可用的接口，里面集成了添加、查询、修改、删除等方法，在ssm集成的时候，任何继承了该接口的mapper接口就拥有了对应的操作响应数据的方法，可以在很大程度上减少代码的重复，其具体如下：</p><pre><code>package com.carleviets.crm.base;import org.springframework.dao.DataAccessException;import java.util.List;import java.util.Map;public interface BaseDAO&lt;T&gt; {    /**     * 添加记录     * @param entity     * @return     * @throws DataAccessException     */    Integer save(T entity)throws DataAccessException;    /**     * 批量添加记录     * @param entities     * @return     * @throws DataAccessException     */    Integer saveBatch(List&lt;T&gt; entities) throws DataAccessException;    /**     * 通过id查询     * @param id     * @return     * @throws DataAccessException     */    T queryById(Integer id) throws DataAccessException;    /**     * 参数化查询     * @param baseQuery     * @return     * @throws DataAccessException     */    List&lt;T&gt; queryByParams(BaseQuery baseQuery) throws DataAccessException;    /**     * 更新单条记录     * @param entity     * @return     * @throws DataAccessException     */    Integer update(T entity) throws DataAccessException;    /**     * 批量更新     * @param map     * @return     * @throws DataAccessException     */    Integer updateBatch(Map&lt;String, Object&gt; map) throws DataAccessException;    /**     * 通过id删除单条记录     * @param id     * @return     * @throws DataAccessException     */    Integer delete(Integer id) throws DataAccessException;    /**     * 批量删除记录     * @param ids     * @return     * @throws DataAccessException     */    Integer deleteBatch(Integer[] ids) throws DataAccessException;}</code></pre><h3 id="2、BaseService"><a href="#2、BaseService" class="headerlink" title="2、BaseService"></a>2、BaseService</h3><p>该实用工具类对查询，更新、删除、分页查询等常用的操作进行了封装，Service层只需要继承该实用工具类，就可以省去大量的重复代码，具体如下:</p><pre><code>package com.carleviets.crm.base;import com.carleviets.crm.utils.AssertUtil;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.dao.DataAccessException;import java.util.HashMap;import java.util.List;import java.util.Map;public class BaseService&lt;T&gt; {    @Autowired    private BaseDAO&lt;T&gt; baseDAO;    /**     * 添加单条记录     * @param entity     * @return     * @throws DataAccessException     */    public Integer save(T entity) throws DataAccessException{        return baseDAO.save(entity);    }    /**     * 批量添加记录     * @param entities     * @return     * @throws DataAccessException     */    public Integer saveBatch(List&lt;T&gt; entities) throws DataAccessException{        return baseDAO.saveBatch(entities);    }    /**     * 通过id查询     * @param id     * @return     * @throws DataAccessException     */    public T queryById(Integer id) throws DataAccessException{        AssertUtil.isTrue(id==null||id&lt;0, &quot;带查询的记录不存在&quot;);        return baseDAO.queryById(id);    }    /**     * 参数化查询     * @param baseQuery     * @return     * @throws DataAccessException     */    public PageInfo&lt;T&gt; queryByParams(BaseQuery baseQuery) throws DataAccessException{        PageHelper.startPage(baseQuery.getPageNum(), baseQuery.getPageSize());        List&lt;T&gt; entities = baseDAO.queryByParams(baseQuery);        return new PageInfo&lt;T&gt;(entities);    }    /**     * 参数化分页查询     * @param baseQuery     * @return     * @throws DataAccessException     */    public Map&lt;String, Object&gt; queryForPage(BaseQuery baseQuery) throws DataAccessException{        PageHelper.startPage(baseQuery.getPageNum(), baseQuery.getPageSize());        List&lt;T&gt; entities=baseDAO.queryByParams(baseQuery);        PageInfo&lt;T&gt; pageInfo=new PageInfo&lt;T&gt;(entities);        Map&lt;String, Object&gt; map=new HashMap&lt;&gt;();        map.put(&quot;total&quot;, pageInfo.getTotal());        map.put(&quot;rows&quot;, pageInfo.getList());        return map;    }    /**     * 更新单条记录     * @param entity     * @return     * @throws DataAccessException     */    public Integer update(T entity) throws DataAccessException{        return baseDAO.update(entity);    }    /**     * 批量更新记录     * @param map     * @return     * @throws DataAccessException     */    public Integer updateBatch(Map&lt;String, Object&gt; map) throws DataAccessException{        return baseDAO.updateBatch(map);    }    /**     * 删除单条记录     * @param id     * @return     * @throws DataAccessException     */    public Integer delete(Integer id) throws DataAccessException{        AssertUtil.isTrue(id==null||id&lt;=0||queryById(id)==null, &quot;待删除的记录不存在&quot;);        return baseDAO.delete(id);    }    /**     * 批量删除记录     * @param ids     * @return     * @throws DataAccessException     */    public Integer deleteBatch(Integer[] ids) throws DataAccessException{        AssertUtil.isTrue(ids==null||ids.length==0, &quot;请选择待删除的记录&quot;);        return baseDAO.deleteBatch(ids);    }}</code></pre><h3 id="3、BaseController"><a href="#3、BaseController" class="headerlink" title="3、BaseController"></a>3、BaseController</h3><p>该实用工具类封装了对于成功操作时返回ResultInfo对象的方法，并且通过@ModelAttribute注解可以在继承该实用工具类的每一个控制器方法执行前统一在request作用域中添加了上下文路径，省去了大量的重复代码：</p><pre><code>package com.carleviets.crm.base;import com.carleviets.crm.po.vo.ResultInfo;import org.springframework.web.bind.annotation.ModelAttribute;import javax.servlet.http.HttpServletRequest;public class BaseController {    public ResultInfo success(Integer code, String msg, Object result){        ResultInfo resultInfo=new ResultInfo();        resultInfo.setCode(code);        resultInfo.setMsg(msg);        resultInfo.setResult(result);        return resultInfo;    }    public ResultInfo success(Integer code, String msg){        ResultInfo resultInfo=new ResultInfo();        resultInfo.setCode(code);        resultInfo.setMsg(msg);        return resultInfo;    }    //此注解标注的方法会在每个Controller的方法执行之前执行    @ModelAttribute    public void preHandle(HttpServletRequest request){        request.setAttribute(&quot;ctx&quot;, request.getContextPath());    }}</code></pre><h3 id="3、BaseQuery"><a href="#3、BaseQuery" class="headerlink" title="3、BaseQuery"></a>3、BaseQuery</h3><p>这个不用多说，所有的参数查询前台都需要传递pageNum和pageSize这两个参数，但是对于具体的情况，可以具有其他不同的参数，该实用工具类就是对pageNum和pageSize这两个参数进行简单封装的JavaBean，所有的参数查询都可以继承该实用工具类：</p><pre><code>package com.carleviets.crm.base;public class BaseQuery {    private Integer pageNum;    private Integer pageSize;    public Integer getPageNum() {        return pageNum;    }    public void setPageNum(Integer pageNum) {        this.pageNum = pageNum;    }    public Integer getPageSize() {        return pageSize;    }    public void setPageSize(Integer pageSize) {        this.pageSize = pageSize;    }}</code></pre><h3 id="3、GlobalExceptionHandler全局异常处理器"><a href="#3、GlobalExceptionHandler全局异常处理器" class="headerlink" title="3、GlobalExceptionHandler全局异常处理器"></a>3、GlobalExceptionHandler全局异常处理器</h3><p>全局异常处理器是spring-mvc中异常集中处理的地方。配置全局异常处理器后，Controller中只需要关注代码正常执行的情况，而异常发生时由全局异常处理器来进行统一的处理，并且根据前台需要的是普通视图还是JSON字符串进行不同的响应，具体代码如下：</p><pre><code>package com.carleviets.crm.exceptions;import com.carleviets.crm.po.vo.ResultInfo;import com.carleviets.crm.utils.JsonUtil;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.lang.reflect.Method;@Componentpublic class GlobalExceptionResolver implements HandlerExceptionResolver {    /**     * @param request     * @param response     * @param target    调用的方法     * @param ex     * @return     */    @Override    public ModelAndView resolveException(HttpServletRequest request,                                         HttpServletResponse response,                                         Object target,                                         Exception ex) {        ModelAndView modelAndView=createDefaultModelAndView(request);        if(ex instanceof LoginException){            LoginException e= (LoginException) ex;            modelAndView.addObject(&quot;errorMsg&quot;, e.getMsg());        }        //如果目标方法是处理器方法的实例        if(target instanceof HandlerMethod){            HandlerMethod handlerMethod= (HandlerMethod) target;            Method method=handlerMethod.getMethod();            //@ResponseBody注解区分前台是需要json数据还是视图            ResponseBody annotation = method.getAnnotation(ResponseBody.class);            if(annotation==null){                //普通页面请求                if(ex instanceof ParamsException){                    ParamsException e= (ParamsException) ex;                    modelAndView.addObject(&quot;errorMsg&quot;, e.getMsg());                }else{                    modelAndView.addObject(&quot;errorMsg&quot;, &quot;系统繁忙&quot;);                }                return modelAndView;            }else{                //前台需要json数据                ResultInfo resultInfo=new ResultInfo();                if(ex instanceof ParamsException){                    ParamsException e= (ParamsException) ex;                    resultInfo.setCode(e.getCode());                    resultInfo.setMsg(e.getMsg());                }else{                    resultInfo.setCode(417);                    resultInfo.setMsg(&quot;系统繁忙&quot;);                }                //将resultInfo转化为json数据发送到前台                JsonUtil.toJson(resultInfo, response);            }        }        return null;    }    private ModelAndView createDefaultModelAndView(HttpServletRequest request) {        ModelAndView modelAndView=new ModelAndView();        modelAndView.setViewName(&quot;error&quot;);  //设置视图名称        modelAndView.addObject(&quot;ctx&quot;, request.getContextPath());        return modelAndView;    }}</code></pre><h3 id="4、spring-mvc中拦截器实现对特定请求的拦截"><a href="#4、spring-mvc中拦截器实现对特定请求的拦截" class="headerlink" title="4、spring-mvc中拦截器实现对特定请求的拦截"></a>4、spring-mvc中拦截器实现对特定请求的拦截</h3><p>在spring-mvc中，可以通过拦截器实现对特定请求的拦截，如：拦截用户登录等。下面是一个拦截用户登录的代码：</p><pre><code>package com.carleviets.crm.interceptor;import com.carleviets.crm.service.UserService;import com.carleviets.crm.utils.AssertUtil;import com.carleviets.crm.utils.LoginUserUtil;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class LoginInterceptor extends HandlerInterceptorAdapter {    @Autowired    private UserService userService;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        //从cookie中获取到userId        Integer userId= LoginUserUtil.releaseUserIdFromCookie(request);        AssertUtil.isNotLogin(userId==null||userService.queryById(userId)==null, &quot;用户未登录&quot;);        return true;    //true为放行，false为拦截    }}</code></pre><p>除了编写拦截器外，还需要在servlet-context.xml中显示配置拦截器的拦截路径，放行的资源和放行的操作等，这种方式粒度较粗，对应的配置如下：</p><pre><code>&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt;    &lt;mvc:interceptor&gt;        &lt;!--拦截所有路径--&gt;        &lt;mvc:mapping path=&quot;/**&quot;/&gt;        &lt;!--静态资源放行--&gt;        &lt;mvc:exclude-mapping path=&quot;/statics/**&quot;/&gt;        &lt;!--登录页面放行--&gt;        &lt;mvc:exclude-mapping path=&quot;/index&quot;/&gt;        &lt;!--登录操作放行--&gt;        &lt;mvc:exclude-mapping path=&quot;/user/login&quot;/&gt;        &lt;!--配置拦截器bean--&gt;        &lt;bean class=&quot;com.carleviets.crm.interceptor.LoginInterceptor&quot;/&gt;    &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;</code></pre><p>除了这种方式外，还可以通过spring中的AOP实现拦截操作。</p><h3 id="4、通过AOP代理实现拦截请求的操作"><a href="#4、通过AOP代理实现拦截请求的操作" class="headerlink" title="4、通过AOP代理实现拦截请求的操作"></a>4、通过AOP代理实现拦截请求的操作</h3><p>在spring中，可以通过前置通知和环绕通知来实现对特定请求的拦截。下面是基于特定的注解和环绕通知来实现没有对应权限的用户的拦截代码：</p><pre><code>package com.carleviets.crm.aop;import com.carleviets.crm.annotations.RequestPermission;import com.carleviets.crm.constants.CrmConstants;import com.carleviets.crm.utils.AssertUtil;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import javax.servlet.http.HttpSession;import java.lang.reflect.Method;import java.util.List;@Component@Aspectpublic class PermissionAdapter {    @Autowired    private HttpSession httpSession;    //声明切点     @Pointcut(&quot;@annotation(com.carleviets.crm.annotations.RequestPermission)&quot;)    public void cut(){}    //声明环绕通知    @Around(&quot;cut()&quot;)    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {        //通过连接点拿到方法签名        MethodSignature methodSignature= (MethodSignature) proceedingJoinPoint.getSignature();        //通过方法签名获取到该方法        Method method=methodSignature.getMethod();        //通过方法获取到特定的注解        RequestPermission annotation=method.getAnnotation(RequestPermission.class);        //通过注解获取到权限码值        String aclValue=annotation.aclValue();        //判断会话中储存的权限列表中是否包含该权限码        List&lt;String&gt; permissions= (List&lt;String&gt;) httpSession.getAttribute(CrmConstants.USER_PERMISSIONS);        AssertUtil.isTrue(permissions==null||!permissions.contains(aclValue), &quot;没有权限&quot;);        return proceedingJoinPoint.proceed();    }}</code></pre><p>其中，注解的定义如下：</p><pre><code>package com.carleviets.crm.annotations;import java.lang.annotation.*;@Target({ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface RequestPermission {    String aclValue() default &quot;&quot;;}</code></pre><p>控制器中的方法，@RequestPermission注解中的value值为需要访问控制器中该方法的权限码值，具体代码如下：</p><pre><code>@RequestPermission(aclValue = &quot;101001&quot;)@RequestMapping(&quot;/querySaleChancesByParams&quot;)public @ResponseBody Map&lt;String, Object&gt; querySaleChancesByParams(SaleChanceQuery saleChanceQuery,                                                                  @RequestParam(defaultValue = &quot;1&quot;) Integer page,                                                                  @RequestParam(defaultValue = &quot;10&quot;) Integer rows){    saleChanceQuery.setPageNum(page);    saleChanceQuery.setPageSize(rows);    return saleChanceService.queryForPage(saleChanceQuery);}</code></pre><p>通过AOP这种方式实现对特定请求的拦截，不需要在servlet-context.xml中进行任何的配置，并且控制的粒度更细，也是本人推荐使用的一种方式。</p>]]></content>
      
      
      <categories>
          
          <category> SSM整合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用工具类 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
