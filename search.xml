<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis总结</title>
      <link href="/2019/01/20/Redis%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/20/Redis%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关系型数据库和非关系型数据库的对比"><a href="#一、关系型数据库和非关系型数据库的对比" class="headerlink" title="一、关系型数据库和非关系型数据库的对比"></a>一、关系型数据库和非关系型数据库的对比</h2><h4 id="1、关系型数据库"><a href="#1、关系型数据库" class="headerlink" title="1、关系型数据库"></a>1、关系型数据库</h4><ul><li>表与表之间存在约束关系(即所谓的范式)</li><li>表设计</li><li>SQL编写 </li><li>当表数据量很大，进行查询时，效率比较低（多表关联） </li><li>存在IO开销问题</li></ul><h4 id="2、非关系型数据库"><a href="#2、非关系型数据库" class="headerlink" title="2、非关系型数据库"></a>2、非关系型数据库</h4><p>非关系型数据库，基于key-value形式对数据进行存储，优先基于内存（内存+磁盘），类似的产品（Redis、MemcachedMongoDB-基于文档存储..）。关系库能够存储的数据，在非关系库中都能实现。</p><p>特点:</p><ul><li>不存在表概念</li><li>不需要编写SQL</li><li>访问数据效率更高（优先基于内存）</li><li>支持持久化</li><li>Redis支持分布式存储（高可用-HA）</li></ul><h2 id="二、Redis介绍"><a href="#二、Redis介绍" class="headerlink" title="二、Redis介绍"></a>二、Redis介绍</h2><p>Redis是一个<strong>内存中的</strong>数据结构存储系统，它可以用作<strong>数据库、缓存和消息中间件</strong>。它支持多种类型的数据结构，如<strong>字符串（strings）、散列（hashes）、列表（lists)、集合（sets）、有序集合（sorted sets）</strong>与范围查询，bitmaps，hyperloglogs和地理空（geospatial）索引半径查询。 Redis内置了复制（replication），LUA脚本（Lua scripting），LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的磁盘持久化（persistence，并通过 Redis哨兵（Sentinel）和自动分区（Cluster）供高可用性（high availability）。从这段简介中我们应该掌握一下几点：</p><pre><code>1. Redis 是把数据存放在内存当中，所以它的运行速度会非常快2. Redis 具有多种数据存储结构3. Redis 具有持久化的功能4. Redis 上的数据可以设置过期5. Redis 支持集群，而且可以自动切换6. 跨平台 支持多种语言客户端</code></pre><h2 id="三、CentOS环境下Redis的安装"><a href="#三、CentOS环境下Redis的安装" class="headerlink" title="三、CentOS环境下Redis的安装"></a>三、CentOS环境下Redis的安装</h2><p>(1) 执行下面的命令执行下载并解压:</p><pre><code>wget http://download.redis.io/releases/redis-3.2.8.tar.gztar -zxvf redis-3.2.8.tar.gz</code></pre><p>(2) 如果centos没有gcc环境, 需要先安装gcc</p><pre><code>yum install gcc</code></pre><p>(3) 进入解压后的目录，通过make命令执行编译</p><pre><code>cd redis-3.2.8make</code></pre><h2 id="四、Redis的运行"><a href="#四、Redis的运行" class="headerlink" title="四、Redis的运行"></a>四、Redis的运行</h2><h4 id="1、配置文件说明"><a href="#1、配置文件说明" class="headerlink" title="1、配置文件说明"></a>1、配置文件说明</h4><pre><code>redis.conf                     redis服务器启动基本配置文件sentinel.conf                 redis哨兵配置文件redis-server                 启动服务器脚本redis-cli                     连接redis服务器脚本redis-sentinel                 redis哨兵服务器启动脚本</code></pre><h4 id="2、Redis的运行"><a href="#2、Redis的运行" class="headerlink" title="2、Redis的运行"></a>2、Redis的运行</h4><p>(1) redis-server启动方式一</p><p>进入redis-3.2.8目录下，执行以下命令:</p><pre><code>src/redis-server</code></pre><p>但是通过这种方式启动Redis之后当前窗口无法再继续其他操作，不推荐。</p><p>(2) redis-server启动方式二</p><p>修改redis.conf配置文件中daemonize默认属性no修改为yes，如下:</p><pre><code>daemonize yes</code></pre><p>保存并退出后执行以下命令指定配置文件启动服务器:</p><pre><code>src/redis-server ./redis.conf</code></pre><p>注意vi非编辑模式下可以通过    “/+待查找文本” 来执行查找，通过”:noh”来取消选中标记。</p><p>(3) 通过redis.conf文件中的requirepass password配置密码，如下将服务器的密码设置为123456：</p><pre><code>requirepass 123456</code></pre><p>(4)Redis客户端的启动</p><pre><code>src/redis-cli -p port -a password</code></pre><p>通过执行redis-cli并指定所连接的端口号和密码来启动客户端。</p><h2 id="五、Redis通用命令介绍"><a href="#五、Redis通用命令介绍" class="headerlink" title="五、Redis通用命令介绍"></a>五、Redis通用命令介绍</h2><pre><code>exists key                         检测指定key是否存在，返回1表示存在，0不存在del key1 key2 ...... keyN         删除给定 key,返回删除key的数目，0表示给定key都不存在type key                         返回给定key值的类型。返回none表示key不存在,string——字符类型，list——链表类型，set——无序集合类型......keys pattern                     返回匹配指定模式的所有keyrandomkey                           返回从当前数据库中随机选择的一个key,如果当前数据库是空的，返回空串rename oldkey newkey             重命名一个key,如果newkey存在，将会被覆盖，返回1表示成功，0失败。返回0时可能是oldkey不存在或者和newkey 相同。renamenx oldkey newkey             同上，但是如果newkey存在返回失败。expire key seconds                 为key指定过期时间，单位是秒。返回1成功，0表示key已经设置过过期时间或者不存在。ttl key                             返回设置过过期时间key的剩余过期秒数。-1表示key不存在或者未设置过期时间。select db-index                 通过索引选择数据库，默认连接的数据库是0,默认数据库数是16个。返回1表示成功，0失败。move key db-index                 将key从当前数据库移动到指定数据库。返回1表示成功。0表示key不存在或者已经在指定数据库中</code></pre><h2 id="六、五种基本数据类型"><a href="#六、五种基本数据类型" class="headerlink" title="六、五种基本数据类型"></a>六、五种基本数据类型</h2><h4 id="1、string类型基本命令"><a href="#1、string类型基本命令" class="headerlink" title="1、string类型基本命令"></a>1、string类型基本命令</h4><p>string是最基本的类型，而且string类型是二进制安全的。意思是redis的string可以包含任何数据。比如 jpg 图片或者序列化的对象。从内部实现来看其实string可以看作byte组，最大上限是 1G 字节。string类型的基本命令如下:</p><pre><code>set key value                                 设置key对应string类型的值，返回1表示成功，0表示失败。setnx key value                             如果key不存在，设置key对应string类型的值。如果key已经存在，返回0。get key                                     获取key对应的string值,如果key不存在返回nilgetset key value                             先获取key的值，再设置key的值。如果key不存在返回 nil。mget key1 key2 ......keyN                     一次获取多个key的值，如果对应key不存在，则对应返回nil。mset key1 value1 ......keyN valueN             一次设置多个key的值，成功返回1，表示所有的值都设置了，失败返回0表示没有任何值被设置。msetnx key1 value1 ......keyN valueN         一次设置多个 key 的值，但是不会覆盖已经存在的keyincr key                                     对key的值做++操作，并返回新的值。注意incr一个不是int的value会返回错误，incr一个不存在的key，                                            则设置key值为1。decr key                                     对key的值做--操作，decr一个不存在的key，则设置key值为-1。incrby key integer                             对key加上指定值，key不存在时候会设置key，并认为原来的value是0。decrby key integer                             对key减去指定值。decrby完全是为了可读性，我们完全可以通过incrby一个负值来实现同样效果，反之一样。</code></pre><h4 id="2、Hash类型基本命令"><a href="#2、Hash类型基本命令" class="headerlink" title="2、Hash类型基本命令"></a>2、Hash类型基本命令</h4><pre><code>hset key field value                             设置 hash field 为指定值，如果 key 不存在，则创建hget key field                                     获取指定的 hash field。hmget key filed1....fieldN                         获取全部指定的 hash filed。hmset key filed1 value1 ......filedN valueN     同时设置 hash 的多个 field。hincrby key field integer                         将指定的hash filed加上指定值。成功返回hash filed变更后的值。hexists key field                                 检测指定 field 是否存在。hdel key field                                     删除指定的hash field。hlen key                                         返回指定 hash 的 field 数量hkeys key                                         返回 hash 的所有 field。hvals key                                         返回 hash 的所有 value。hgetall key                                     返回 hash 的所有 filed 和 value。</code></pre><p>内部实现方式:Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，当Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject 的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap。</p><h4 id="3、List类型基本命令"><a href="#3、List类型基本命令" class="headerlink" title="3、List类型基本命令"></a>3、List类型基本命令</h4><pre><code>lpush key string                                 在key对应list的头部添加字符串元素，返回1表示成功，0表示key存在且不是list类型。rpush key string                                 在key对应list的尾部添加字符串元素。llen key                                         返回key对应list的长度，如果key不存在返回0，如果key对应类型不是list返回错误。lrange key start end                             返回指定区间内的元素，下标从0开始，负值表示从后面计算，-1表示倒数第一个元素 ，key不存在返回空列表。ltrim key start end                             截取list指定区间内元素，成功返回 1，key不存在返回错误。lset key indexvalue                             设置list中指定下标的元素值，成功返回 1，key或者下标不存在返回错误。lrem key count value                             从List的头部（count 正数）或尾部（count 负数）删除一定数量（count）匹配value的元素，返回删除的元素数量。count为0时候删除全部。lpop key                                         从list的头部删除并返回删除元素。如果key对应list不存在或者是空返回nil，如果key对应值不是 list 返回错误。rpop key                                         从list的尾部删除并返回删除元素。blpop key1 ......keyN timeout                     从左到右扫描，返回对第一个非空list进行lpop 操作并返回，比如 blpop list1 list2 list3 0 ,如果list不存在                                                   list2,list3 都是非空则对 list2 做 lpop 并返回从 list2 中删除的元素。如果所有的list都是空或不存在，则                                                会阻塞timeout秒，timeout为0表示一直阻塞。当阻塞时，如果有client对key1...keyN中的任意key进行push操作，则                                                第一在这个key上被阻塞的client会立即返回。如果超时发生，则返回nil。有点像unix的select或者poll。brpop                                             同blpop，一个是从头部删除一个是从尾部删除</code></pre><p>Lists的另一个应用就是队列,可以利用Lists的PUSH操作，将任务存在List中，然后工作线程再用POP操作将任务取出进行执行。</p><p>内部实现方式：Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis 内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。</p><h4 id="4、Set类型基本命令"><a href="#4、Set类型基本命令" class="headerlink" title="4、Set类型基本命令"></a>4、Set类型基本命令</h4><p>是无序集合，最大可以包含(2的32次方-1)个元素。set的是通过hashtable实现的，所以添加，删除，查找的复杂度都是 O(1)。hash table会随着添加或者删除自动的调整大小。需要注意的是调整hashtable大小时候需要同步（获取写锁）会阻塞其他读写操作。关于 set 集合类型除了基本的添加删除操作，其它有用的操作还包含集合的取并集(union)，交集(intersection)，差集(difference)。通过这些操作可以很容易的实现SNS中的好友推荐和blog的tag功能。set集合的基本命令如下:</p><pre><code>sadd key member                         添加一个string元素到key对应set集合中，成功返回1,如果元素以及在集合中则返回0，                                        key对应的set不存在则返回错误。srem key member                         从key对应set中移除指定元素，成功返回1，如果member在集合中不存在或者key不存在返回0，                                        如果key对应的不是set类型的值返回错误。spop key                                 删除并返回key对应set中随机的一个元素,如果set是空或者key不存在返回nil。srandmember key                         同spop，随机取set中的一个元素，但是不删除元素。smove srckey dstkey member                 从srckey对应set中移除member并添加到dstkey对应set中，整个操作是原子的。                                        成功返回1,如果member在srckey中不存在返回0，如果key不是set类型返回错误。Scard key                                 返回set的元素个数，如果set是空或者key不存在返回0。sismember key member                     判断member是否在set中，存在返回1，0表示不存在或者key不存在。sinter key1 key2 …… keyN                 返回所有给定key的交集。sinterstore dstkey key1 ....... keyN     返回所有给定key的交集，并保存交集存到dstkey下。sunion key1 key2 ...... keyN             返回所有给定key的并集。sunionstore dstkey key1 ......keyN         返回所有给定key的并集，并保存并集到dstkey下。sdiff key1 key2 ......keyN                 返回所有给定key的差集。sdiffstore dstkey key1 ......keyN         返回所有给定key的差集，并保存差集到dstkey下。smembers key                             返回key对应set的所有元素，结果是无序的。</code></pre><p>set的内部实现是一个value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。</p><h4 id="5、Sorted-Set类型基本命令"><a href="#5、Sorted-Set类型基本命令" class="headerlink" title="5、Sorted Set类型基本命令"></a>5、Sorted Set类型基本命令</h4><p>Sorted Set是有序集合，它在set的基础上增加了一个顺序属性，这一属性在添加修改元素的时候可以指定，每次指定后，会自动重新按新的值调整顺序。可以理解了有两列的mysql表，一列存 value，一列存顺序。操作中 key 理解为sorted set的名字，最多包含2^(32-1)个元素。Sorted Set集合的基本，命令如下:</p><pre><code>zadd key score member                     添加元素到集合，元素在集合中存在则更新对应score。zrem key member                         删除指定元素，1表示成功，如果元素不存在返回0。zincrby key incrmember                     增加对应member的score，然后移动元素并保持skip list保持有序。返回更新后的 score 值。zrank key member                         返回指定元素在集合中的排名（下标），集合中元素是按score从小到大排序的。zrevrankkey member                         同上,但是集合中元素是按 score 从大到小排序。zrange key start end                     类似lrange操作从集合中去指定区间的元素。返回的是有序结果zrevrange key start end                 同上，返回结果是按score逆序的。zrangebyscore key min max                 返回集合中score在给定区间的元素。zcount key min max                         返回集合中score在给定区间的数量。zcard key                                 返回集合中元素个数。zscore key element                         返回给定元素对应的 score</code></pre><h2 id="四、集群环境下Redis实现主备切换和读写分离"><a href="#四、集群环境下Redis实现主备切换和读写分离" class="headerlink" title="四、集群环境下Redis实现主备切换和读写分离"></a>四、集群环境下Redis实现主备切换和读写分离</h2><p>Redis支持主从复用。数据可以从主服务器向任意数量的从服务器上同步，同步使用的是发布/订阅机制。Mater Slave的模式，从Slave向Master发起 SYNC 命令。可以是1 Master 多 Slave，也可以分层，Slave 下可以再接Slave，可扩展成树状结构。这里使用单机来模拟redis主从服务器 ，实现读写分离配置。具体实现步骤如下：</p><h4 id="1、Redis实现读写分离"><a href="#1、Redis实现读写分离" class="headerlink" title="1、Redis实现读写分离"></a>1、Redis实现读写分离</h4><p>(1) Redis节点准备</p><p>在home目录新建ha文件夹并拷贝三份 redis 服务器文件到该目录下，分别更名为redis-6379，redis-6380和redis-6381，其中redis-6379作为主服务器，redis-6380和redis-6381作为从服务器。通过以下命令执行复制:</p><pre><code>cp -r 源目录 目标目录</code></pre><p>(2) 修改主服务器的配置</p><p>进入redis-6379目录，以vi编辑模式进入redis.conf文件，修改slave-read-only属性的值修改为yes,requirepass属性指定具体的密码:</p><pre><code>slave-read-only yes 从服务器默认是只读的不允许输入requirepass 123456    指定主服务器的访问密码</code></pre><p>(3) 修改从服务器的配置</p><p>分别进入redis-6380和redis-6381目录，以vi编辑模式进入redis.conf文件，需要修改的配置如下:</p><pre><code>port 6380    指定从服务器的端口requirepass 123456    指定该从服务器的访问密码slaveof &lt;masterip&gt; &lt;masterport&gt;        指定该从服务器所隶属的主服务器的ip和端口masterauth 指定该从服务器的主服务器密码</code></pre><p>slave of 后填写主服务器的ip和主服务器的端口。</p><p>以上两处修改完毕后，查看服务器的具体信息,命令如下:</p><pre><code>info replication</code></pre><h4 id="2、Redis实现主备切换"><a href="#2、Redis实现主备切换" class="headerlink" title="2、Redis实现主备切换"></a>2、Redis实现主备切换</h4><p>(1) Redis节点准备</p><p>Redis服务器三台：</p><pre><code>redis-6379(master)redis-6380(slave)redis-6381(slave)</code></pre><p>Sentinel 哨兵服务器三台:</p><pre><code>redis-26379redis-26380redis-26381</code></pre><p>(2)主从节点redis.conf配置</p><p>主节点配置:</p><pre><code>设置端口(port),daemonize,密码(requirepass)，主节点密码(masterauth),禁用 bind 等基本配置。</code></pre><p><strong>注意</strong>，这里必须加入<strong>masterauth</strong>属性，因为如果主节点宕机后，再重新加入集群是作为从服务器的，需要主节点的访问密码。</p><p>从节点配置:</p><pre><code>设置端口(port),requirepass,daemonize,主节点密码(masterauth),禁用 bind ,slaveof 属性设置等。</code></pre><p>(3)sentinel.conf 哨兵文件配置</p><p>初始化启动配置:</p><ul><li>默认监听 6379 端口</li><li>设置连接服务器密码属性: sentinel auth-pass mymaster</li><li>设置同意选举成功的票数为 2 台(通常为:至少为半数票数通过)</li></ul><p>具体说明如下:</p><pre><code>##redis## 哨兵监听进程端口号设置port 26379#master# 指示 Sentinel 去监视一个名为 master 的主服务器， 这个主服务器的 IP 地址为# 127.0.0.1 ， 端口号为 6379 ， 而将这个主服务器判断为失效至少需要 1 个# Sentinel 同意 （只要同意 Sentinel 的数量不达标，自动故障迁移就不会执行）。sentinel monitor master 192.168.132.8 6379 2# Sentinel 认为服务器已经断线所需的毫秒数sentinel down-after-milliseconds master 5000#若 sentinel 在该配置值内未能完成 failover 操作（即故障时 master/slave 自动切换），则认为本次 failover 失败。sentinel failover-timeout master 900000</code></pre><p>(4)测试主备切换</p><ul><li>服务器启动顺序:先启动redis服务器，后启动哨兵服务器</li><li>关闭主服务器，查看哨兵日志信息-&gt;找到新的主节点 添加redis 数据</li></ul><h2 id="五、Redis-持久化"><a href="#五、Redis-持久化" class="headerlink" title="五、Redis 持久化"></a>五、Redis 持久化</h2><p>对于 Redis,其提供了不同级别的持久化操作:</p><ul><li><p>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照。</p></li><li><p>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。</p></li><li><p>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时,它会优先使用 AOF 文件来还原数据集,因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</p></li><li><p>持久化功能当然也可以进行关闭操作，让数据仅在服务器运行时存在</p></li></ul><h4 id="1、RDB持久化操作（快照-SnapShot-方式）"><a href="#1、RDB持久化操作（快照-SnapShot-方式）" class="headerlink" title="1、RDB持久化操作（快照 SnapShot 方式）"></a>1、RDB持久化操作（快照 SnapShot 方式）</h4><p>默认情况下，Redis将数据库快照保存在名字为 dump.rdb 的二进制文件中。当然， 这里可以通过修改 redis.conf 配置文件来对数据存储条件进行定义，规定在“ N 秒内数据集至少有 M 个改动”这一条件被满足时,自动保存一次数据集。 也可以通过调用save 或 bgsave ,手动让 Redis 进行数据集保存操作。</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fzd6umpa2aj30hl0azjrx.jpg" alt=""></p><p><strong>Save | Bgsave 手动方式即时保存数据</strong></p><p>通过 save 操作 ，当前 io 操作被阻塞，当 save 保存执行完毕才会进行后续 io 操作。而bgsave 操作在背后开启一个新的进程来对数据进行快照处理。保存后的快照存放在 dump.rdb 文件中，快照RDB文件的名称和具体位置在redis.conf如下:</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fzd6zuidurj30fv05uwem.jpg" alt=""></p><p><strong>快照运行方式</strong></p><p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作：</p><ul><li>Redis调用 fork()，同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中。</li><li>当子进程完成对新RDB文件的写入时，Redis用新RDB文件替换原来的RDB文件，并删除旧的RDB文件。</li></ul><p><strong>RDB 优缺点</strong></p><p>优点:</p><ul><li><p>RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 该文件适合用于进行备份 。 比如说，可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。</p></li><li><p>RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心。</p></li><li><p>RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。</p></li><li><p>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p></li></ul><p>缺点：</p><ul><li><p>如果想要做到数据实时备份级别，此时使用 rdb 快照进行备份可能会出现数据无法备份完整情况，比如在数据备份完毕下次备份操作发起前，服务器由于某种原因意外宕机，此时采用 rdb 就无法对当前情况做的实时响应处理。</p></li><li><p>RDB 需要经常 fork 子进程来保存数据集到硬盘上,当数据集比较大的时候,fork 的过程是非常耗时的,可能会导致 Redis 在一些毫秒级内不能响应客户端的请求.如果数据集巨大并且 CPU 性能不是很好的情况下,这种情况会持续 1 秒,AOF 也需要 fork,但是你可以调节重写日志文件的频率来提高数据集的耐久度。</p></li></ul><h4 id="2、AOF只追加操作的文件"><a href="#2、AOF只追加操作的文件" class="headerlink" title="2、AOF只追加操作的文件"></a>2、AOF只追加操作的文件</h4><p> AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， AOF文件的体积也会变得越来越大。但是，AOF可以在不打断服务客户端的情况下，对 AOF 文件进行重建（rebuild）。 Redis 2.4 则可以自动触发 AOF 重写。AOF 重写文件配置:</p><pre><code>############################## APPEND ONLY MODE################################ 是否开启 AOF，默认关闭（no）appendonly yes# 指定 AOF 文件名appendfilename appendonly.aof# Redis 支持三种不同的刷写模式：# appendfsync always #每次收到写命令就立即强制写入磁盘，是最有保证的完全的持久化，但速度也是最慢的，一般不推荐使用。appendfsync everysec #每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，是受推荐的方式。# appendfsync no #完全依赖 OS 的写入，一般为 30 秒左右一次，性能最好但是持久化最没有保证，不被推荐。#在日志重写时，不进行命令追加操作，而只是将其放在缓冲区里，避免与命令的追加造成DISK IO 上的冲突。#设置为 yes 表示 rewrite 期间对新写操作不 fsync,暂时存在内存中,等 rewrite 完成后再写入，默认为 nono-appendfsync-on-rewrite no#当前 AOF 文件大小是上次日志重写得到 AOF 文件大小的二倍时，自动启动新的日志重写过程。auto-aof-rewrite-percentage 100#当前 AOF 文件启动新的日志重写过程的最小值，避免刚刚启动 Reids 时由于文件尺寸较小导致频繁的重写。auto-aof-rewrite-min-size 64mb</code></pre><h2 id="六、使用-Jedis-客户端工具操作-redis"><a href="#六、使用-Jedis-客户端工具操作-redis" class="headerlink" title="六、使用 Jedis 客户端工具操作 redis"></a>六、使用 Jedis 客户端工具操作 redis</h2><h4 id="1、服务端环境准备"><a href="#1、服务端环境准备" class="headerlink" title="1、服务端环境准备"></a>1、服务端环境准备</h4><ul><li><p>添加访问认证</p><pre><code>  requirepass 123456        指定该从服务器的访问密码</code></pre></li><li><p>ip地址bind属性修改</p><p>  <img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fzd8fh6orrj30fg044jrf.jpg" alt=""></p></li></ul><p>将 bind 127.0.0.1 属性禁用（如果不禁用，仅限本机ip访问redis服务器）能够让外界客户端进行访问。</p><ul><li><p>关闭防火墙</p><pre><code>  service iptables stop</code></pre></li></ul><h4 id="2、pom依赖引入"><a href="#2、pom依赖引入" class="headerlink" title="2、pom依赖引入"></a>2、pom依赖引入</h4><pre><code>&lt;!--Jedis客户端依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;redis.clients&lt;/groupId&gt;  &lt;artifactId&gt;jedis&lt;/artifactId&gt;  &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="3、通过-junit-进行简单测试"><a href="#3、通过-junit-进行简单测试" class="headerlink" title="3、通过 junit 进行简单测试"></a>3、通过 junit 进行简单测试</h4><pre><code>package com.carleviets;import org.junit.Test;import redis.clients.jedis.Jedis;import java.util.HashMap;import java.util.Map;public class RedisTest {    @Test    public void test01(){        Jedis jedis=new Jedis(&quot;192.168.107.220&quot;, 6379);        jedis.auth(&quot;123456&quot;);   //设置连接密码        jedis.set(&quot;2019&quot;, &quot;hello redis!&quot;);        System.out.println(jedis.get(&quot;2019&quot;));        System.out.println(jedis.type(&quot;2019&quot;));    }}</code></pre><h4 id="4、Jedis客户端操作数据的RedisUtil工具类"><a href="#4、Jedis客户端操作数据的RedisUtil工具类" class="headerlink" title="4、Jedis客户端操作数据的RedisUtil工具类"></a>4、Jedis客户端操作数据的RedisUtil工具类</h4><p>以下是用连接池的思想实行封装的RedisUtil工具类:</p><pre><code>package com.carleviets.util;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import redis.clients.jedis.Jedis;public final class RedisUtil {    //Redis 服务器 IP    private static String ADDR = &quot;192.168.107.220&quot;;    //Redis 的端口号    private static int PORT = 6379;    //访问密码    private static String AUTH = &quot;123456&quot;;    //可用连接实例的最大数目，默认值为 8；    //如果赋值为-1，则表示不限制；如果 pool 已经分配了 maxActive 个 jedis 实例，则此时 pool 的状态为 exhausted(耗尽)。    private static int MAX_ACTIVE = 1024;    //控制一个 pool 最多有多少个状态为 idle(空闲的)的 jedis 实例，默认值也是 8。    private static int MAX_IDLE = 200;    //等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。    //如果超过等待时间，则直接抛出 JedisConnectionException；    private static int MAX_WAIT = 10000;    private static int TIMEOUT = 10000;    //在 borrow 一个 jedis 实例时，是否提前进行 validate 操作；    //如果为 true，则得到的 jedis 实例均是可用的；    private static boolean TEST_ON_BORROW = true;    private static JedisPool jedisPool = null;    /**     * 初始化 Redis 连接池     */    static {        try {            JedisPoolConfig config = new JedisPoolConfig();            config.setMaxTotal(MAX_ACTIVE);            config.setMaxIdle(MAX_IDLE);            config.setMaxWaitMillis(MAX_WAIT);            config.setTestOnBorrow(TEST_ON_BORROW);            jedisPool = new JedisPool(config, ADDR, PORT, TIMEOUT, AUTH);        } catch (Exception e) {            e.printStackTrace();        }    }    /**     * 获取 Jedis 实例     * @return     */    public synchronized static Jedis getJedis() {        try {            if (jedisPool != null) {                Jedis resource = jedisPool.getResource();                return resource;            } else {                return null;            }        } catch (Exception e) {            e.printStackTrace();            return null;        }    }    /**     * 释放 jedis 资源     * @param jedis     */    public static void returnResource(final Jedis jedis) {        if (jedis != null) {            //此处close()方法将连接还给连接池对象，并不是关闭jedis连接            jedisPool.close();        }    }}</code></pre><p>如果要想获取一个Redis连接的话，只需要调用RedisUtil.getJedis()方法即可。</p><h2 id="七、Spring-Data-Redis-操作-redis-服务器"><a href="#七、Spring-Data-Redis-操作-redis-服务器" class="headerlink" title="七、Spring-Data-Redis 操作 redis 服务器"></a>七、Spring-Data-Redis 操作 redis 服务器</h2><h4 id="1、pom坐标依赖"><a href="#1、pom坐标依赖" class="headerlink" title="1、pom坐标依赖"></a>1、pom坐标依赖</h4><pre><code>&lt;!-- spring-data-redis --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;  &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;  &lt;version&gt;1.8.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--jedis 客户端--&gt;&lt;dependency&gt;  &lt;groupId&gt;redis.clients&lt;/groupId&gt;  &lt;artifactId&gt;jedis&lt;/artifactId&gt;  &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="2、spring-xml具体配置"><a href="#2、spring-xml具体配置" class="headerlink" title="2、spring.xml具体配置"></a>2、spring.xml具体配置</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--jedis连接池配置--&gt;    &lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;        &lt;!--允许的最大连接数--&gt;        &lt;property name=&quot;maxTotal&quot; value=&quot;1024&quot;/&gt;        &lt;!--最大空闲连接数--&gt;        &lt;property name=&quot;maxIdle&quot; value=&quot;200&quot;/&gt;        &lt;!--获取连接时最大等待毫秒数--&gt;        &lt;property name=&quot;maxWaitMillis&quot; value=&quot;10000&quot;/&gt;        &lt;!--在获取连接时检查有效性--&gt;        &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置客户端连接工厂--&gt;    &lt;bean id=&quot;jedisConnectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;&gt;        &lt;property name=&quot;usePool&quot; value=&quot;true&quot;/&gt;        &lt;property name=&quot;hostName&quot; value=&quot;192.168.107.220&quot;/&gt;        &lt;property name=&quot;port&quot; value=&quot;6379&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;        &lt;constructor-arg name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置RedisTemplate模板--&gt;    &lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;        &lt;!--配置redis模板的连接工厂--&gt;        &lt;property name=&quot;connectionFactory&quot; ref=&quot;jedisConnectionFactory&quot;/&gt;        &lt;!--配置键序列化以及哈希键序列化方式--&gt;        &lt;property name=&quot;keySerializer&quot;&gt;            &lt;bean class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;/&gt;        &lt;/property&gt;        &lt;property name=&quot;hashKeySerializer&quot;&gt;            &lt;bean class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;/&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h4 id="3、测试代码"><a href="#3、测试代码" class="headerlink" title="3、测试代码"></a>3、测试代码</h4><pre><code>package com.carleviets;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = {&quot;classpath:spring.xml&quot;})public class SpringDataRedisTest {    @Resource    private RedisTemplate&lt;String, Object&gt; redisTemplate;    @Test    public void test01(){        ValueOperations&lt;String, Object&gt; valueOperations= redisTemplate.opsForValue();        valueOperations.set(&quot;spring_data_redis&quot;, &quot;redis is not easy!&quot;);        //System.out.println(valueOperations.get(&quot;spring_data_redis&quot;));    }}</code></pre><h2 id="八、Spring-Data-Redis环境下读写分离配置"><a href="#八、Spring-Data-Redis环境下读写分离配置" class="headerlink" title="八、Spring-Data-Redis环境下读写分离配置"></a>八、Spring-Data-Redis环境下读写分离配置</h2><h4 id="1、pom坐标依赖-1"><a href="#1、pom坐标依赖-1" class="headerlink" title="1、pom坐标依赖"></a>1、pom坐标依赖</h4><p>pom坐标依赖同上述单机环境下的坐标依赖。</p><h4 id="2、spring-xml具体配置（spring-sentinel-xml）"><a href="#2、spring-xml具体配置（spring-sentinel-xml）" class="headerlink" title="2、spring.xml具体配置（spring-sentinel.xml）"></a>2、spring.xml具体配置（spring-sentinel.xml）</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--Redis连接池配置--&gt;    &lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;        &lt;!--最大连接数--&gt;        &lt;property name=&quot;maxTotal&quot; value=&quot;1024&quot;/&gt;        &lt;!--最大空闲连接数--&gt;        &lt;property name=&quot;maxIdle&quot; value=&quot;200&quot;/&gt;        &lt;!--获取连接时最大等待毫秒数--&gt;        &lt;property name=&quot;maxWaitMillis&quot; value=&quot;10000&quot;/&gt;        &lt;!--在获取连接时检查有效性--&gt;        &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot;/&gt;    &lt;/bean&gt;    &lt;!--哨兵配置，注意哨兵节点只监视主节点--&gt;    &lt;bean id=&quot;redisSentinelConfiguration&quot; class=&quot;org.springframework.data.redis.connection.RedisSentinelConfiguration&quot;&gt;        &lt;property name=&quot;master&quot;&gt;            &lt;bean class=&quot;org.springframework.data.redis.connection.RedisNode&quot;&gt;                &lt;property name=&quot;name&quot; value=&quot;mymaster&quot;/&gt;            &lt;/bean&gt;        &lt;/property&gt;        &lt;property name=&quot;sentinels&quot;&gt;            &lt;set&gt;                &lt;bean class=&quot;org.springframework.data.redis.connection.RedisNode&quot;&gt;                    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.107.220&quot;/&gt;                    &lt;constructor-arg name=&quot;port&quot; value=&quot;26379&quot;/&gt;                &lt;/bean&gt;                &lt;bean class=&quot;org.springframework.data.redis.connection.RedisNode&quot;&gt;                    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.107.220&quot;/&gt;                    &lt;constructor-arg name=&quot;port&quot; value=&quot;26380&quot;/&gt;                &lt;/bean&gt;                &lt;bean class=&quot;org.springframework.data.redis.connection.RedisNode&quot;&gt;                    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.107.220&quot;/&gt;                    &lt;constructor-arg name=&quot;port&quot; value=&quot;26381&quot;/&gt;                &lt;/bean&gt;            &lt;/set&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!--Redis连接工厂配置--&gt;    &lt;bean id=&quot;jedisConnectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;&gt;        &lt;!--连接池的引用--&gt;        &lt;property name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot;/&gt;        &lt;!--哨兵配置的引用--&gt;        &lt;constructor-arg name=&quot;sentinelConfig&quot; ref=&quot;redisSentinelConfiguration&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置redis模板--&gt;    &lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;        &lt;!--配置连接工厂引用--&gt;        &lt;property name=&quot;connectionFactory&quot; ref=&quot;jedisConnectionFactory&quot;/&gt;        &lt;!--配置keySerializer和hashKeySerializer--&gt;        &lt;property name=&quot;keySerializer&quot;&gt;            &lt;bean class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;&gt;&lt;/bean&gt;        &lt;/property&gt;        &lt;property name=&quot;hashKeySerializer&quot;&gt;            &lt;bean class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;&gt;&lt;/bean&gt;        &lt;/property&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p><strong>说明:</strong><br>Spring-data-redis 中是先将 key 与 value 进行序列化成变成 byte[] 字节数组进行传输，再调用对应的 redis的java客户端进行存储的。默认情况下，Redis采用JdkSerializationRedisSerializer，该序列化器序列化的是Object对象。而在一般情况下，对于 key 序列化采用字符串进行序列化，对于value序列化采用默认的JdkSerializationRedisSerializer。</p><h4 id="3、测试代码-1"><a href="#3、测试代码-1" class="headerlink" title="3、测试代码"></a>3、测试代码</h4><pre><code>package com.carleviets;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = {&quot;classpath:spring-sentinel.xml&quot;})public class SpringDataRedisTest2 {    @Resource    private RedisTemplate redisTemplate;    @Test    public void test(){        redisTemplate.opsForValue().set(&quot;spring_redis_sentinel&quot;, &quot;Hello, redis sentinel!&quot;);    }}</code></pre><h2 id="九、采用Spring-Data-Redis的RedisUtil实用工具类的简单封装"><a href="#九、采用Spring-Data-Redis的RedisUtil实用工具类的简单封装" class="headerlink" title="九、采用Spring-Data-Redis的RedisUtil实用工具类的简单封装"></a>九、采用Spring-Data-Redis的RedisUtil实用工具类的简单封装</h2><pre><code>package com.carleviets.util;import org.springframework.data.redis.core.HashOperations;import org.springframework.data.redis.core.ListOperations;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.ValueOperations;import org.springframework.stereotype.Component;import org.springframework.util.CollectionUtils;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit;/** * Redis操作数据的简单封装 */@Component@SuppressWarnings(&quot;all&quot;)public class RedisUtils {    private RedisTemplate&lt;String,Object&gt; redisTemplate;    private ValueOperations&lt;String, Object&gt; valueOperations;    private ListOperations&lt;String, Object&gt; listOperations;    private HashOperations&lt;String, String, Object&gt; hashOperations;    public RedisUtils(RedisTemplate&lt;String, Object&gt; redisTemplate) {        this.redisTemplate = redisTemplate;        valueOperations=this.redisTemplate.opsForValue();        listOperations=this.redisTemplate.opsForList();        hashOperations=this.redisTemplate.opsForHash();    }    public void setString(String key,Object value){        valueOperations.set(key, value);    }    public void setStringExpires(String key,Object value,Long time){        valueOperations.set(key, value, time, TimeUnit.MINUTES);    }    public Object getString(String key){        return valueOperations.get(key);    }    public void clearKeyByPattern(String pattern){        Set&lt;String&gt; keys= redisTemplate.keys(pattern);        if(!CollectionUtils.isEmpty(keys)){            redisTemplate.delete(keys);        }    }    public void delKey(String key){        if(redisTemplate.hasKey(key)){            redisTemplate.delete(key);        }    }    public void setList(String key,List list){        if(!CollectionUtils.isEmpty(list)){            for(Object t:list){                listOperations.rightPush(key, t);            }        }    }    public List&lt;Object&gt; getList(String key){        List&lt;Object&gt; list=null;        if(redisTemplate.hasKey(key)){            list=listOperations.range(key, 0, -1);        }        return list;    }    public void setHash(String key,String field,Object t){        hashOperations.put(key, field, t);    }    public void setHashAll(String key,Map&lt;String, Object&gt; map){        hashOperations.putAll(key, map);    }    public Object getHash(String key,String field){        return hashOperations.get(key, field);    }    public List&lt;Object&gt; getMultiHash(String key,List fields){        return hashOperations.multiGet(key, fields);    }    public Map getHashMap(String key){        return hashOperations.entries(key);    }}</code></pre><h2 id="十、热点问题"><a href="#十、热点问题" class="headerlink" title="十、热点问题"></a>十、热点问题</h2><h4 id="1、缓存穿透现象"><a href="#1、缓存穿透现象" class="headerlink" title="1、缓存穿透现象"></a>1、缓存穿透现象</h4><p>缓存系统，按照 KEY 去查询 VALUE,当 KEY 对应的 VALUE 一定不存在的时候并对 KEY 并发请求量很大的时候，就会造成缓存穿透情况!</p><p>缓存穿透场景:</p><ul><li><p>根据key查询对应value不存在时，到数据库中查询</p></li><li><p>当key对应value一定不存在，且查询并发量很大时，数据库压力增大!</p></li></ul><p>解决方案:</p><ul><li><p>对查询结果为空也进行缓存，并设置缓存过期时间</p></li><li><p>对不存在的 key 进行过滤操作——布隆过滤器</p></li></ul><p>业务代码中添加缓存时，并发量高的情况下下出现缓存穿透问题,这种情况下的解决方案:</p><ul><li>双重检查锁 类比单例模式下 双重检查锁实现</li></ul><h4 id="2、缓存雪崩现象"><a href="#2、缓存雪崩现象" class="headerlink" title="2、缓存雪崩现象"></a>2、缓存雪崩现象</h4><p>如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，就有可能造成存雪崩现象。</p><p>解决方案:</p><ul><li><p>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p></li><li><p>不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀</p></li><li><p>做二级缓存，或者双缓存策略。比如A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> jedis </tag>
            
            <tag> spring-data-redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令总结</title>
      <link href="/2019/01/19/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/19/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、git的三个分区"><a href="#一、git的三个分区" class="headerlink" title="一、git的三个分区"></a>一、git的三个分区</h2><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fzc630ca3uj30qp0b60ur.jpg" alt=""></p><ul><li><p>工作区（Working Directory）<br>是直接编辑的地方，肉眼可见，直接操作。</p></li><li><p>暂存区（Stage 或 Index）<br>数据暂时存放的区域。 </p></li><li><p>版本库（commit History）<br>存放已经提交的数据，push 的时候，就是把这个区的数据 push 到远程git仓库了。</p></li></ul><h2 id="二、git创建版本库"><a href="#二、git创建版本库" class="headerlink" title="二、git创建版本库"></a>二、git创建版本库</h2><pre><code>cd: 切换目录,比如 cd e: 切换到 e 盘mkdir: 创建一个文件夹pwd: 查看当前目录git init: 初始化一个本地库$ git config --global user.name &quot;name&quot;: 设置用户名$ git config --global user.email &quot;email@example.com&quot;: 设置邮箱</code></pre><h2 id="三、基本文件操作"><a href="#三、基本文件操作" class="headerlink" title="三、基本文件操作"></a>三、基本文件操作</h2><pre><code>git add: 添加文件到缓存区git commit: 提交文件到分支,-m 添加说明git status: 查看文件是否有修改git diff: 对比文件修改内容git log: 查看提交历史git reset --hard HEAD^: 回到上一个版本git reset --hard xxx: 回到指定版本,版本号可以不写全git reflog: 查看历史提交版本git rm: 删除版本库文件rm: 删除本地文件ls: 查看文件目录</code></pre><h2 id="四、创建远程版本库"><a href="#四、创建远程版本库" class="headerlink" title="四、创建远程版本库"></a>四、创建远程版本库</h2><pre><code>1. 创建 SSH Key      $ ssh-keygen -t rsa -C &quot;your email&quot;    在用户主目录里找到.ssh 目录， 里面有 id_rsa 和 id_rsa.pub2. 登陆 GitHub， 打开“Account settings”， “SSH Keys”页面。 点“Add SSH Key”，填上任意 Title，    在 Key 文本框里粘贴 id_rsa.pub 文件的内容。 点“Add Key”， 你就应该看到已经添加的 Key3. 验证是否成功    $ ssh -T git@github.com    如果出现:Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access,则表示成功!</code></pre><h2 id="五、添加远程库"><a href="#五、添加远程库" class="headerlink" title="五、添加远程库"></a>五、添加远程库</h2><pre><code>1. 登陆 GitHub， 在右上角找到“Create a new repo”按钮， 创建一个新的仓库。2. 在Repository name填入&quot;仓库名称&quot;，其他保持默认设置，点击 “Create repository” 按钮，就成功地创建了一个新的Git 仓库。3. $ git remote add origin git@github:&lt;your github address&gt;， 添加远程库，名字叫做 origin。4. $ git push -u origin master，把本地库推送到远程库上。由于远程库是空的，我们第一次推送 master 分支时，加上了-u 参数，Git 不但会把本地的 master 分支内容。推送的远程新的 master 分支，还会把本地的 master 分支和远程的master 分支关联起来，在以后的推送或者拉取时就可以简化命令。5. 以后提交只用写，$ git push origin master。6. 克隆远程库，$ git clone git@github.com:&lt;your github programe address&gt;.git。</code></pre><h2 id="六、分支管理"><a href="#六、分支管理" class="headerlink" title="六、分支管理"></a>六、分支管理</h2><pre><code>1、 创建dev分支，切换到dev分支    $ git checkout -b dev    (git checkout 命令加上-b 参数表示创建并切换， 相当于以下两条命令：        $ git branch dev        $ git checkout dev    )2、 查看当前分支    $ git branch3、 修改 readme.txt, add、 commit4、 切换回 master    $ git checkout master5、 合并分支    $ git merge dev6、 删除分支    $ git branch -d dev7、 解决冲突    找到冲突文件,去掉 &lt;&lt;&lt;&lt;&lt; =====    $ git add 冲突文件名字    $ git commit -m ‘注释’</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring aop 简单总结</title>
      <link href="/2019/01/19/Spring%20aop%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/19/Spring%20aop%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关于Spring-aop"><a href="#一、关于Spring-aop" class="headerlink" title="一、关于Spring aop"></a>一、关于Spring aop</h2><h4 id="1、简单介绍"><a href="#1、简单介绍" class="headerlink" title="1、简单介绍"></a>1、简单介绍</h4><p>在软件开发中，散布于应用中多处的功能被称为横切关注点（crosscutting concern）。通常来讲，这些横切关注点从概念上是与应用的业务逻辑相分离的（但是往往会直接嵌入到应用的业务逻辑之中）。简而言之，横切关注点可以被描述为影响应用多处的功能。</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fz9w687qgaj30km0cowj1.jpg" alt=""></p><p>AOP,即面向切面编程（Aspect Oriented Programing），相较OOP而言，AOP 关注的不再是程序代码中某个类或某些方法，而 aop 考虑的更多的是一种面到面的切入，即层与层之间的一种切入，所以称之为切面。</p><h4 id="2、应用场景"><a href="#2、应用场景" class="headerlink" title="2、应用场景"></a>2、应用场景</h4><p>AOP主要应用于日志、安全、事务管理性能统计等方面，实现公共功能代码的复用。</p><h4 id="3、AOP带来的好处"><a href="#3、AOP带来的好处" class="headerlink" title="3、AOP带来的好处"></a>3、AOP带来的好处</h4><p>(1) 降低模块与模块之间的耦合度，提高业务代码的聚合度，即所谓的高内聚低耦合（DI有助于应用对象之间的解耦，而AOP可以实现横切关注点与它们所影响的对象之间的解耦）。</p><p>(2) 提高了代码的复用性。</p><p>(3) 提高系统的扩展性。</p><h2 id="二、AOP基本概念"><a href="#二、AOP基本概念" class="headerlink" title="二、AOP基本概念"></a>二、AOP基本概念</h2><h4 id="1、通知（Advice"><a href="#1、通知（Advice" class="headerlink" title="1、通知（Advice)"></a>1、通知（Advice)</h4><p>在AOP术语中，切面的工作被称为通知。通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。Spring切面可以应用5种类型的通知：</p><pre><code>前置通知（Before）：在目标方法被调用之前调用通知功能；后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；返回通知（After-returning）：在目标方法成功执行之后调用通知；异常通知（After-throwing）：在目标方法抛出异常后调用通知；环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</code></pre><h4 id="2、连接点（Join-point）"><a href="#2、连接点（Join-point）" class="headerlink" title="2、连接点（Join point）"></a>2、连接点（Join point）</h4><p>连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。<br><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fz9wn10ky6j30mn0g7tbx.jpg" alt=""></p><h4 id="3、-切点（Poincut）"><a href="#3、-切点（Poincut）" class="headerlink" title="3、 切点（Poincut）"></a>3、 切点（Poincut）</h4><p>如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处”。切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p><h4 id="4、切面（Aspect）"><a href="#4、切面（Aspect）" class="headerlink" title="4、切面（Aspect）"></a>4、切面（Aspect）</h4><p>切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——它是什么，在何时和何处完成其功能。切点定义了要拦截哪些类的哪些方法， 通知则定义了拦截过方法后要做什么，切面则是横切关注点的抽象，与类相似，类是对物体特征的抽象，切面则是横切关注点抽象。</p><h4 id="5、引入（Introduction）"><a href="#5、引入（Introduction）" class="headerlink" title="5、引入（Introduction）"></a>5、引入（Introduction）</h4><p>在不修改原有应用程序代码的情况下，在程序运行期为类动态添加方法或者字段的过程称为引入。</p><p>####6、织入（Weaving）</p><p>织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多个点可以进行织入，包括编译期、类加载期和运行期，但是Spring的AOP只支持在运行期织入。</p><h2 id="三、Spring-对AOP的支持"><a href="#三、Spring-对AOP的支持" class="headerlink" title="三、Spring 对AOP的支持"></a>三、Spring 对AOP的支持</h2><h4 id="1、Spring在运行时通知对象"><a href="#1、Spring在运行时通知对象" class="headerlink" title="1、Spring在运行时通知对象"></a>1、Spring在运行时通知对象</h4><p>Spring AOP是基于动态代理的，通过在代理类中包裹切面，Spring在运行期把切面织入到Spring管理的bean中。如图所示，代理类封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fz9y9bib6nj30q20ds0ul.jpg" alt=""></p><p>直到应用需要被代理的bean时，Spring才创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入Spring AOP的切面。</p><h4 id="2、Spring只支持方法级别的连接点"><a href="#2、Spring只支持方法级别的连接点" class="headerlink" title="2、Spring只支持方法级别的连接点"></a>2、Spring只支持方法级别的连接点</h4><p>因为Spring基于动态代理，所以Spring只支持方法连接点。这与一些其他的AOP框架是不同的，例如AspectJ和JBoss，除了方法切点，它们还提供了字段和构造器接入点。 Spring缺少对字段连接点的支持，无法让我们创建细粒度的通知，例如拦截对象字段的修改。而且它不支持构造器连接点，我们就无法在bean创建时应用通知，但是方法拦截可以满足绝大部分的需求。</p><h2 id="四、切点表达式语言"><a href="#四、切点表达式语言" class="headerlink" title="四、切点表达式语言"></a>四、切点表达式语言</h2><p>在Spring AOP中，要使用AspectJ的切点表达式语言来定义切点，但是，Spring仅支持AspectJ切点指示器（pointcut designator）的一个子集。如下：</p><pre><code>AspectJ指示器                                             描　　述 arg()                                         限制连接点匹配参数为指定类型的执行方法 @args()                                    限制连接点匹配参数由指定注解标注的执行方法 execution()                                 用于匹配是连接点的执行方法 this()                                     限制连接点匹配AOP代理的bean引用为指定类型的类 target                                     限制连接点匹配目标对象为指定类型的类 @target()                                    限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解 within()                                     限制连接点匹配指定的类型 @within()                                    限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方法定义在由指定的注解所标注的类里） @annotation                                 限定匹配带有指定注解的连接点 bean()                                        允许我们在切点表达式中使用bean的ID来匹配特定的bean</code></pre><p>注意，只有execution指示器是实际执行匹配的，而其他的指示器都是用来限制匹配的。如下是一个式例声明：</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fz9yx6ksutj30lg08mgnb.jpg" alt=""></p><h2 id="五、具体使用"><a href="#五、具体使用" class="headerlink" title="五、具体使用"></a>五、具体使用</h2><h4 id="1、配置文件"><a href="#1、配置文件" class="headerlink" title="1、配置文件"></a>1、配置文件</h4><p>要想使用Spring aop,首先需要在pom.xml中引入如下的坐标依赖:</p><pre><code> &lt;!--spring 核心依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring-aop面向切面--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectj代理--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;  &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;  &lt;version&gt;1.8.9&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>其次，需要在spring.xml开启组件扫描和AspectJ自动代理:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!--组件扫描--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets&quot;/&gt;    &lt;!--aspectj自动代理--&gt;    &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt;</code></pre><h4 id="2、使用AOP"><a href="#2、使用AOP" class="headerlink" title="2、使用AOP"></a>2、使用AOP</h4><p>例如，对于演出而言，观众是很重要的一个关注点，但就演出本身而言，它并不是演出的核心功能，在演出前观众需要就坐和把手机调到静音，演出很精彩的话观众可能会鼓掌，演出没有达到预期的话观众可能就需要退款了，如下是通过java的方式将观众配置为一个切面：</p><pre><code>package com.carleviets.aop;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;@Component@Aspectpublic class Audience {    @Pointcut(&quot;execution(* com.carleviets.concert.Perfermance.perform(..))&quot;)    public void performance(){}    @Before(&quot;performance()&quot;)    public void silenceCellPhones(){        System.out.println(&quot;将手机调到静音...&quot;);    }    @Before(&quot;performance()&quot;)    public void takeSeats(){        System.out.println(&quot;就坐...&quot;);    }    @AfterReturning(&quot;performance()&quot;)    public void applause(){        System.out.println(&quot;鼓掌...&quot;);    }    @AfterThrowing(&quot;performance()&quot;)    public void demandRefund(){        System.out.println(&quot;需要退款...&quot;);    }}</code></pre><p>注意上面定义的perfermance()方法本身的内容并不重要，该方法本身只是一个标识，供@Pointcut注解依附以便声明切点。同时也需要注意上面使用AspectJ注解声明了通知的方法。</p><p>同样，我们也可以通过xml的方式进行切面配置, 首先，去掉注解后的Audience类是一个普通的POJO类:</p><pre><code>package com.carleviets.aop;import org.springframework.stereotype.Component;@Componentpublic class Audience {    public void silenceCellPhones(){        System.out.println(&quot;将手机调到静音...&quot;);    }    public void takeSeats(){        System.out.println(&quot;就坐...&quot;);    }    public void applause(){        System.out.println(&quot;鼓掌...&quot;);    }    public void demandRefund(){        System.out.println(&quot;需要退款...&quot;);    }}</code></pre><p>在spring.xml中，需要添加如下配置：</p><pre><code>&lt;aop:config&gt;    &lt;!--声明切面--&gt;    &lt;aop:aspect ref=&quot;audience&quot;&gt;        &lt;!--声明切点--&gt;        &lt;aop:pointcut id=&quot;perfermance&quot; expression=&quot;execution(* com.carleviets.concert.Perfermance.perform(..))&quot;/&gt;        &lt;!--声明前置通知--&gt;        &lt;aop:before pointcut-ref=&quot;perfermance&quot; method=&quot;silenceCellPhones&quot;/&gt;        &lt;aop:before pointcut-ref=&quot;perfermance&quot; method=&quot;takeSeats&quot;/&gt;        &lt;!--声明返回通知--&gt;        &lt;aop:after-returning pointcut-ref=&quot;perfermance&quot; method=&quot;applause&quot;/&gt;        &lt;!--声明异常通知--&gt;        &lt;aop:after-throwing pointcut-ref=&quot;perfermance&quot; method=&quot;demandRefund&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><p>这样，我们就通过Java配置的方式和通过xml的方式完成了一个切面的配置。</p><h4 id="3、使用环绕通知"><a href="#3、使用环绕通知" class="headerlink" title="3、使用环绕通知"></a>3、使用环绕通知</h4><p>在所有的通知中，环绕通知是功能最为强大的类型。它能够让你所编写的逻辑将被通知的目标方法完全包装起来。实际上就像在一个通知方法中同时编写前置通知和后置通知。同样以上述的表演为例，环绕通知的Java配置如下:</p><pre><code>package com.carleviets.aop;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;@Component@Aspectpublic class Audience {    @Pointcut(&quot;execution(* com.carleviets.concert.Perfermance.perform(..))&quot;)    public void performance(){}    @Around(&quot;performance()&quot;)    public Object watchPerfermance(ProceedingJoinPoint proceedingJoinPoint){        Object result=null;        try {            //在演出开始前把手机调到静音和就坐            System.out.println(&quot;将手机调到静音...&quot;);            System.out.println(&quot;就坐...&quot;);            //调用被拦截的方法，如果方法有返回值需要在最后通过return返回结果            result=proceedingJoinPoint.proceed();            //演出成功，鼓掌            System.out.println(&quot;鼓掌...&quot;);        } catch (Throwable throwable) {            throwable.printStackTrace();            //演出不符合预期            System.out.println(&quot;需要退款...&quot;);        }        return result;    }}</code></pre><p>在上面的配置中需要注意的是ProceedingJoinPoint对象的proceed方法的调用，当然你也可以不调用proceed()方法，这样的话会阻塞对被通知方法的访问，同样，你也可以在通知中对它进行多次调用。同样，如果用xml来配置环绕通知的话，此时，具体Java类的代码如下:</p><pre><code>package com.carleviets.aop;import org.aspectj.lang.ProceedingJoinPoint;import org.springframework.stereotype.Component;@Componentpublic class Audience {    public Object watchPerfermance(ProceedingJoinPoint proceedingJoinPoint){        Object result=null;        try {            //在演出开始前把手机调到静音和就坐            System.out.println(&quot;将手机调到静音...&quot;);            System.out.println(&quot;就坐...&quot;);            //调用被拦截的方法，如果方法有返回值需要在最后通过return返回结果            result=proceedingJoinPoint.proceed();            //演出成功，鼓掌            System.out.println(&quot;鼓掌...&quot;);        } catch (Throwable throwable) {            throwable.printStackTrace();            //演出不符合预期            System.out.println(&quot;需要退款...&quot;);        }        return result;    }}</code></pre><p>具体的xml配置如下:</p><pre><code>&lt;aop:config&gt;    &lt;!--声明切面--&gt;    &lt;aop:aspect ref=&quot;audience&quot;&gt;        &lt;!--声明切点--&gt;        &lt;aop:pointcut id=&quot;perfermance&quot; expression=&quot;execution(* com.carleviets.concert.Perfermance.perform(..))&quot;/&gt;        &lt;!--配置环绕通知--&gt;        &lt;aop:around method=&quot;watchPerfermance&quot; pointcut-ref=&quot;perfermance&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><h4 id="4、处理通知中的参数"><a href="#4、处理通知中的参数" class="headerlink" title="4、处理通知中的参数"></a>4、处理通知中的参数</h4><p>上面的通知方法中都没有参数，但是，如果要往通知中传入参数，该怎么办?下面是一个记录音乐CD播放的磁道计数的Java切面代码:</p><pre><code>package com.carleviets.aop;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;import java.util.HashMap;import java.util.Map;@Component@Aspectpublic class TrackCounter {    //定义一个Map,键为歌曲在磁道中的位置，值为磁道中对应歌曲所对应的播放次数计数值    private Map&lt;Integer, Integer&gt; tracks=new HashMap&lt;&gt;();    @Pointcut(&quot;execution(* com.carleviets.soundsystem.CD.playTrack(int )) &amp;&amp; args(trackNumber))&quot;)    public void trackPlayed(int trackNumber){}    @Before(&quot;trackPlayed(trackNumber)&quot;)    public void trackCount(int trackNumber){        int currentCount=getPlayCount(trackNumber);        tracks.put(trackNumber, currentCount++);    }    /**     * 如果该trackNumber之前存在播放记录，则返回之前的播放次数，否则返回0     * @param trackNumber     * @return     */    private int getPlayCount(int trackNumber) {        return tracks.containsKey(trackNumber) ? tracks.get(trackNumber) : 0;    }}</code></pre><p>切点表达式的具体解释如下图所示:</p><p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fzc4m51xibj30ot095406.jpg" alt=""></p><p>上述代码如果采用xml来配置的话，Java类如下:</p><pre><code>package com.carleviets.aop;import org.aspectj.lang.annotation.Aspect;import org.springframework.stereotype.Component;import java.util.HashMap;import java.util.Map;@Componentpublic class TrackCounter {    //定义一个Map,键为歌曲在磁道中的位置，值为磁道中对应歌曲所对应的播放次数计数值    private Map&lt;Integer, Integer&gt; tracks=new HashMap&lt;&gt;();    public void trackCount(int trackNumber){        int currentCount=getPlayCount(trackNumber);        tracks.put(trackNumber, currentCount++);    }    /**     * 如果该trackNumber之前存在播放记录，则返回之前的播放次数，否则返回0     * @param trackNumber     * @return     */    private int getPlayCount(int trackNumber) {        return tracks.containsKey(trackNumber) ? tracks.get(trackNumber) : 0;    }}</code></pre><p>spring.xml的具体配置如下:</p><pre><code>&lt;aop:config&gt;    &lt;!--声明切面--&gt;    &lt;aop:aspect ref=&quot;trackCounter&quot;&gt;        &lt;!--声明切点--&gt;        &lt;aop:pointcut id=&quot;trackPlayed&quot; expression=&quot;execution(* com.carleviets.soundsystem.CD.playTrack(int)) and args(trackNumber)))&quot;/&gt;        &lt;!--声明前置通知--&gt;        &lt;aop:before method=&quot;trackCount&quot; pointcut-ref=&quot;trackPlayed&quot;/&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><h4 id="1、代理模式实现三要素"><a href="#1、代理模式实现三要素" class="headerlink" title="1、代理模式实现三要素"></a>1、代理模式实现三要素</h4><pre><code>（1）接口定义（2）目标对象 与代理对象必须实现统一接口（3）代理对象持有目标对象的引用 增强目标对象行为</code></pre><h4 id="2、代理模式实现分类以及对应区别"><a href="#2、代理模式实现分类以及对应区别" class="headerlink" title="2、代理模式实现分类以及对应区别"></a>2、代理模式实现分类以及对应区别</h4><pre><code>（1）静态代理：手动为目标对象制作代理对象，即在程序编译阶段完成代理对象的创建（2）动态代理：在程序运行期动态创建目标对象对应代理对象。    jdk 动态代理：被代理目标对象必须实现某一或某一组接口 实现方式 通过回调创建代理对象。    cglib 动态代理：被代理目标对象可以不必实现接口，继承的方式实现。    动态代理相比较静态代理，提高开发效率，可以批量化创建代理，提高代码复用率。</code></pre><h4 id="3、Aop-理解"><a href="#3、Aop-理解" class="headerlink" title="3、Aop 理解"></a>3、Aop 理解</h4><pre><code>(1)面向切面，相比oop, aop关注的是代码中的层或面(2) 解耦，提高系统扩展性(3) 提高代码复用</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代理模式总结</title>
      <link href="/2019/01/16/Java%E4%BB%A3%E7%90%86%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/16/Java%E4%BB%A3%E7%90%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、代理模式介绍"><a href="#一、代理模式介绍" class="headerlink" title="一、代理模式介绍"></a>一、代理模式介绍</h2><p>代理(Proxy)是一种设计模式,提供了对目标对象另外的一种访问方式:即通过代理对象访问目标对象。这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。用图表示如下:</p><p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fz8jpxbn9xj30lb06gq36.jpg" alt=""></p><p>代理模式分为静态代理和动态代理。代理模式的设计有两个重要的原则:</p><pre><code>1、 代理类与委托类具有相似的行为（共同）2、 代理类增强委托类的行为</code></pre><h2 id="二、静态代理"><a href="#二、静态代理" class="headerlink" title="二、静态代理"></a>二、静态代理</h2><p>为某个对象提供一个代理，代理角色固定，以控制对这个对象的访问。代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象替代。 代理类负责请求的预处理、 过滤、 将请求分派给委托类处理、 以及委托类执行完请求后的后续处理。</p><p>代理接口的定义如下:</p><pre><code>package com.carleviets;/** * 代理接口的定义 */public interface Marry {    void toMarry();}</code></pre><p>目标类的定义如下:</p><pre><code>package com.carleviets.demo;import com.carleviets.Marry;/** * 目标类的具体实现 */public class Person implements Marry {    @Override    public void toMarry() {        System.out.println(&quot;即将结婚了...&quot;);    }}</code></pre><p>代理类的定义如下:</p><pre><code>package com.carleviets.demo;import com.carleviets.Marry;/** * 代理类的具体实现 */public class Company implements Marry {    //代理的对象，委托类    private Person target;         public Company(Person target) {        this.target = target;    }    public void before(){        System.out.println(&quot;布置婚礼现场...&quot;);    }    public void after(){        System.out.println(&quot;进入人生第二阶段，好嗨哟...&quot;);    }    @Override    public void toMarry() {        before();        target.toMarry();   //真实行为        after();    }}</code></pre><p>测试代码:</p><pre><code>package com.carleviets.demo;import org.junit.Test;public class CompanyTest {    @Test    public void test(){        Person person=new Person();        //构造代理角色的同时传入真实角色        Company company=new Company(person);        company.toMarry();    }}</code></pre><p>静态代理的总结：<br><br>1.可以做到在不修改目标对象的功能前提下,对目标功能扩展。<br><br>2、缺点:因为静态代理对于代理的角色是固定的,并且代理对象需要与目标对象实现相同的接口,所以会有很多的代理类。同时,一旦接口增加方法,目标对象与代理对象都需要维护，这使得静态代理就无法满足生产上的需要，于是就催生了动态代理的思想。</p><h2 id="三、JDK动态代理"><a href="#三、JDK动态代理" class="headerlink" title="三、JDK动态代理"></a>三、JDK动态代理</h2><p>JDK动态代理具有如下的特点:</p><pre><code>1.代理对象,不需要实现接口2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)</code></pre><p>要使用JDK中的代理，我们首先需要了解JDK中的代理接口:</p><p>1、java.lang.reflect.Proxy：这是Java动态代理机制的主类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象。其中Proxy代理类中具有如下常用的核心方法:</p><pre><code>// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器static InvocationHandler getInvocationHandler(Object proxy) // 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象static Class getProxyClass(ClassLoader loader, Class[] interfaces) // 方法 3：该方法用于判断指定类对象是否是一个动态代理类static boolean isProxyClass(Class cl) // 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)</code></pre><p>2、java.lang.reflect.InvocationHandler：这是调用处理器接口，它自定义了一个 invoke 方法，用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类的代理访问。该类具有如下的核心方法:</p><pre><code>// 该方法负责集中处理动态代理类上的所有方法调用。第一个参数既是代理类实例，第二个参数是被调用的方法对象// 第三个方法是调用参数。调用处理器根据这三个参数进行预处理或分派到委托类实例上反射执行Object invoke(Object proxy, Method method, Object[] args)</code></pre><p>每次生成动态代理类对象时都需要指定一个实现了该接口的调用处理器对象（参见 Proxy 静态方法 4 的第三个参数）。</p><p>3、java.lang.ClassLoader：这是类装载器类，负责将类的字节码装载到Java虚拟机（JVM）中并为其定义类对象，然后该类才能被使用。Proxy 静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是由 JVM 在运行时动态生成的而非预存在于任何一个 .class 文件中。每次生成动态代理类对象时都需要指定一个类装载器对象（参见 Proxy 静态方法 4 的第一个参数）。</p><p>动态代理的底层原理比较负责，这里直接进入动态代理的使用,以下是InvocationHandler接口的具体实现:</p><pre><code>package com.carleviets.jdk;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * JDK动态代理 */public class JdkHandler implements InvocationHandler {    //目标类    private Object target;    public JdkHandler(Object target) {        this.target = target;    }    /**     * 程序运行期间动态创建代理角色     * @return     */    public Object getProxy(){        /**         * 获取代理对象：         *  1、类加载器         *  2、目标类   实现的接口   class         *  3、当前类         */        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this);    }    public void before(){        System.out.println(&quot;婚礼现场紧张布置中...&quot;);    }    public void after(){        System.out.println(&quot;恭喜你成功进入人生的第二阶段...&quot;);    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        before();        Object object=method.invoke(target, args);        after();        return object;    }}</code></pre><p>以下是JDK动态代理的具体测试代码:</p><pre><code>package com.carleviets.jdk;import com.carleviets.demo.Person;import org.junit.Test;public class JdkHandlerTest {    @Test    public void test() throws Throwable {        Person you=new Person();  //委托类        JdkHandler handler=new JdkHandler(you); //代理工厂        Object proxy=handler.getProxy();        handler.invoke(proxy, Person.class.getMethod(&quot;toMarry&quot;), null);    //执行    }}</code></pre><h2 id="四、Cglib动态代理"><a href="#四、Cglib动态代理" class="headerlink" title="四、Cglib动态代理"></a>四、Cglib动态代理</h2><p>Cglib（code generator library，代码生成库),是一个第三方提供的动态代理实现方案。与JDK动态代理相比:<br></p><pre><code>Proxy代理：委托类必须有接口，制作过程比较快，执行较慢。Cglib代理:委托类可以没有接口,使用继承的思维来实现相似性，制作代理过程相对较慢，执行快。 主要用于解决没有接口类的代理实现。</code></pre><p>使用Cglib来实现代理需要实现MethodInterceptor接口，具体实现如下:</p><pre><code>package com.carleviets.cglib;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class CglibInterceptor implements MethodInterceptor {    //被代理的目标对象    private Object target;    public CglibInterceptor(Object target) {        this.target = target;    }    //运行期动态创建代理类    public Object getProxy(){        Enhancer enhancer=new Enhancer();        //设置父类  class        enhancer.setSuperclass(target.getClass());        enhancer.setCallback(this);        return enhancer.create();    }    public void before(){        System.out.println(&quot;婚礼现场紧张布置中...&quot;);    }    public void after(){        System.out.println(&quot;进入人生第二阶段，好嗨哟...&quot;);    }    @Override    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {        before();   //增强真实角色行为        Object result=methodProxy.invoke(target, objects);        after();    //增强真实角色行为        return result;    }}</code></pre><p>具体的测试代码如下:</p><pre><code>package com.carleviets.cglib;import com.carleviets.demo.Person;import org.junit.Test;public class CglibInterceptorTest {    @Test    public void test(){        //创建目标对象        Person you=new Person();        CglibInterceptor cglibInterceptor=new CglibInterceptor(you);        //获取代理对象        Person proxy= (Person) cglibInterceptor.getProxy();        //调用代理对象的方法        proxy.toMarry();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RMI远程方法调用</title>
      <link href="/2019/01/16/%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/"/>
      <url>/2019/01/16/%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、RMI介绍"><a href="#一、RMI介绍" class="headerlink" title="一、RMI介绍"></a>一、RMI介绍</h2><p>Java远程方法调用 (Remote Method Invocation，RMI)是一种机制，能够让在某个Java虚拟机上的对象调用另一个Java虚拟机中的对象上的方法。JVM可以位于相同或不同计算机上，在多个JVM中，一个JVM可以调用存储在其它JVM的对象的方法。</p><p>RMI是Java编程语言里，一种用于实现远程过程调用的应用程序编程接口， 它是客户机上运行的程序可以调用远程服务器上的对象，远程方法调用特性使 Java 编程人员能够在网络环境中分布操作。</p><p>Java RMI极大地依赖于接口，在需要创建一个远程对象的时候，程序员通过传递一个接口来隐藏底层的实现细节，客户端得到的远程对象句柄正好与本地的根代码连接，由后者负责透过网络通信。 这样一来，程序员只需关心如何通过自己的接口句柄发送消息。</p><p>RMI底层封装了Socket反射机制——java语言当中分布式的基础（实现 java 之间的互相访问）。RMI 本质就是使用代理类来封装 Socket 的通信细节！ </p><h2 id="二、RMI实现常用API"><a href="#二、RMI实现常用API" class="headerlink" title="二、RMI实现常用API"></a>二、RMI实现常用API</h2><p>1）Remote接口：每一个要暴露出去的java类，都需要实现 Remote 接口，并且所有的方法必须抛出 RemoteException。</p><p>2）UnicastRemoteObject类:服务端程序的实现方案之一就是继承这个类，无参构造器也要抛出 RemoteException。</p><p>3）LocateRegistry类:创建能在特定接口接受调用远程对象注册服务程序。</p><pre><code>    public static Registry createRegistry(int port) throws RemoteException</code></pre><p>4) Naming类：提供了存储和获得远程对象注册服务程序中的远程对象进行引用的方法</p><pre><code>    public static Remote lookup(String name) throws NotBoundException, MalformedURException, ReoteException    public static void bind(String name,Remote obj) throws AlreadyBoundException, MalforedURException, RemoteException</code></pre><h2 id="三、通过Java-RMI远程方法调用"><a href="#三、通过Java-RMI远程方法调用" class="headerlink" title="三、通过Java RMI远程方法调用"></a>三、通过Java RMI远程方法调用</h2><p>下面是使用Maven的多模块模拟远程方法调用的过程，首先先建一个父工程<code>rmi_par</code>,在<code>rmi_par</code>模块下建立如下子模块：</p><pre><code>rmi_api模块：远程方法调用的接口定义rmi_server模块:远程方法调用的具体服务实现rmi_client模块:调用远程方法的具体模块</code></pre><h3 id="1、服务的接口定义——rmi-api模块"><a href="#1、服务的接口定义——rmi-api模块" class="headerlink" title="1、服务的接口定义——rmi_api模块"></a>1、服务的接口定义——rmi_api模块</h3><p>以下是服务接口的定义:</p><pre><code>package com.carleviets.service;import java.rmi.Remote;import java.rmi.RemoteException;/** * 1、接口继承自Remote * 2、对外服务方法声明RemoteException异常 */public interface IHelloService extends Remote {    String sayHello(String msg) throws RemoteException;}</code></pre><h3 id="2、服务接口的具体实现和发布——rmi-server模块"><a href="#2、服务接口的具体实现和发布——rmi-server模块" class="headerlink" title="2、服务接口的具体实现和发布——rmi_server模块"></a>2、服务接口的具体实现和发布——rmi_server模块</h3><p>以下是服务端服务接口的具体实现:</p><pre><code>package com.carleviets.service.impl;import com.carleviets.service.IHelloService;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;/** * 1、继承 UnicastRemoteObject * 2、提供无参构造，对外声明 RemoteException */public class HelloServiceImpl extends UnicastRemoteObject implements IHelloService {    protected HelloServiceImpl() throws RemoteException {    }    @Override    public String sayHello(String msg) throws RemoteException {        System.out.println(&quot;服务器端接收到消息：&quot;+msg);        return &quot;hello:&quot;+msg;    }}</code></pre><p>现在，就可以把服务发布出去了，具体的发布代码如下：</p><pre><code>package com.carleviets.service.impl;import java.net.MalformedURLException;import java.rmi.AlreadyBoundException;import java.rmi.Naming;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;/** * 对外发布服务 */public class Publish {    public static void main(String[] args) throws RemoteException, AlreadyBoundException, MalformedURLException {        //注册端口        LocateRegistry.createRegistry(8888);        //对外发布RMI服务        Naming.bind(&quot;rmi://127.0.0.1:8888/hello&quot;, new HelloServiceImpl());    }}</code></pre><h3 id="3、服务的调用——rmi-client模块"><a href="#3、服务的调用——rmi-client模块" class="headerlink" title="3、服务的调用——rmi_client模块"></a>3、服务的调用——rmi_client模块</h3><pre><code>package com.carleviets;import com.carleviets.service.IHelloService;import org.junit.Test;import java.net.MalformedURLException;import java.rmi.Naming;import java.rmi.NotBoundException;import java.rmi.RemoteException;public class TestRMI {    @Test    public void test() throws RemoteException, NotBoundException, MalformedURLException {        IHelloService helloService= (IHelloService) Naming.lookup(&quot;rmi://127.0.0.1:8888/hello&quot;);        String hello=helloService.sayHello(&quot;I&#39;m a hero.&quot;);        System.out.println(hello);    }}</code></pre><p>注意，这里只是通过maven的多模块对RMI远程调用进行模拟测试，在具体的现实环境中，要通过RMI进行远程方法调用，需要服务器端和客户端实现相同的接口。</p><h2 id="四、通过Spring来实现远程方法调用"><a href="#四、通过Spring来实现远程方法调用" class="headerlink" title="四、通过Spring来实现远程方法调用"></a>四、通过Spring来实现远程方法调用</h2><p>使用Spring的RMI，提供的服务简单方便，不用继承特定的类，也不需要抛出异常。</p><h3 id="1、-服务的接口定义——rmi-api模块："><a href="#1、-服务的接口定义——rmi-api模块：" class="headerlink" title="1、 服务的接口定义——rmi_api模块："></a>1、 服务的接口定义——rmi_api模块：</h3><pre><code>package com.carleviets.service;import java.rmi.Remote;import java.rmi.RemoteException;/** * 1、接口继承自Remote * 2、对外服务方法声明RemoteException异常 */public interface IHelloService extends Remote {    String sayHello(String msg) throws RemoteException;}</code></pre><p>可以看出，在提供服务的接口这一块儿，没有任何变化。</p><h3 id="2、服务接口的具体实现和发布——spring-server模块"><a href="#2、服务接口的具体实现和发布——spring-server模块" class="headerlink" title="2、服务接口的具体实现和发布——spring_server模块"></a>2、服务接口的具体实现和发布——spring_server模块</h3><pre><code>package com.carleviets.service.impl;import com.carleviets.service.IHelloService;import org.springframework.stereotype.Service;import java.rmi.RemoteException;/** * 使用spring实现服务器端服务 */@Servicepublic class HelloServiceImpl implements IHelloService {    @Override    public String sayHello(String msg) throws RemoteException {        System.out.println(&quot;服务端收到消息：&quot;+msg);        return &quot;hello:&quot;+msg;    }}</code></pre><p>同时，需要将上述的服务实现的具体类在spring的配置文件中通过相应的配置发布出去，具体配置如下:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!--定义组件扫描的范围--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets&quot;/&gt;    &lt;!--加入rmi相关配置--&gt;    &lt;bean class=&quot;org.springframework.remoting.rmi.RmiServiceExporter&quot;&gt;        &lt;!--配置对外提供服务的名称--&gt;        &lt;property name=&quot;serviceName&quot; value=&quot;hello&quot;/&gt;        &lt;!--指定服务的具体实现bean--&gt;        &lt;property name=&quot;service&quot; ref=&quot;helloServiceImpl&quot;/&gt;        &lt;!--配置发布的服务接口--&gt;        &lt;property name=&quot;serviceInterface&quot; value=&quot;com.carleviets.service.IHelloService&quot;/&gt;        &lt;!--配置服务注册的端口号--&gt;        &lt;property name=&quot;registryPort&quot; value=&quot;1199&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>这样，spring容器在启动的时候，就会自动将服务注册到对应的rmi地址上:</p><pre><code>package com.carleviets.service.impl;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 测试spring实现RMI的服务器端 */public class HelloServiceImplTest {    public static void main(String[] args) {        //布置RMI服务只需要启动容器即可        new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);    }}</code></pre><h3 id="3、客户端服务的调用——spring-client模块"><a href="#3、客户端服务的调用——spring-client模块" class="headerlink" title="3、客户端服务的调用——spring_client模块"></a>3、客户端服务的调用——spring_client模块</h3><p>要使用以上通过spring发布的服务，首先需要在spring.xml配置RMI代理工厂bean：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--配置Rmi代理工厂bean--&gt;    &lt;bean class=&quot;org.springframework.remoting.rmi.RmiProxyFactoryBean&quot;&gt;        &lt;!--指定提供服务的地址、端口和服务名称--&gt;        &lt;property name=&quot;serviceUrl&quot; value=&quot;rmi://localhost:1199/hello&quot;/&gt;        &lt;!-- 指定使用服务的接口 --&gt;        &lt;property name=&quot;serviceInterface&quot; value=&quot;com.carleviets.service.IHelloService&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>这样，就可以使用具体的服务了，如下是调用远程服务的测试代码:</p><pre><code>package com.carleviets;import com.carleviets.service.IHelloService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.rmi.RemoteException;/** * Spring实现RMI的客户端 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = {&quot;classpath:spring.xml&quot;})public class TestSpringRmiClient {    @Autowired    private IHelloService helloService;    @Test    public void test() throws RemoteException {        String hello=helloService.sayHello(&quot;I&#39;m spring rmi.&quot;);        System.out.println(hello);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rmi远程方法调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring mvc中的全局异常处理</title>
      <link href="/2019/01/16/Spring%20mvc%E4%B8%AD%E7%9A%84%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2019/01/16/Spring%20mvc%E4%B8%AD%E7%9A%84%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-mvc中的全局异常处理"><a href="#Spring-mvc中的全局异常处理" class="headerlink" title="Spring mvc中的全局异常处理"></a>Spring mvc中的全局异常处理</h1><p>在spring mvc中，对全局异常处理的支持有以下三种方式:</p><pre><code>1、使用Spring mvc提供的简单异常处理器 SimpleMappingExceptionResolver；2、实现Spring的异常处理接口 HandlerExceptionResolver 自定义自己的异常处理器;3、使用@ExceptionHandler 注解实现异常处理；4、控制器通知和@ExceptionHandler注解结合使用</code></pre><h2 id="一、使用SimpleMappingExceptionResolver进行异常处理"><a href="#一、使用SimpleMappingExceptionResolver进行异常处理" class="headerlink" title="一、使用SimpleMappingExceptionResolver进行异常处理"></a>一、使用SimpleMappingExceptionResolver进行异常处理</h2><p>使用Spring中的自带的SimpleMappingExceptionResolver类进行异常处理，具有集成简单、扩展性好、对已有代码没有侵入性等优点，但该方法仅能获取到异常信息，若在出现异常时，对需要获取除异常以外的数据的情况不适用。要使用SimpleMappingExceptionResolver，需要配置bean:</p><pre><code>&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;    &lt;!-- 为所有的异常定义默认的异常处理页面，exceptionMappings未定义的异常使用本默认配置 --&gt;    &lt;property name=&quot;defaultErrorView&quot; value=&quot;error&quot;/&gt;    &lt;!-- 定义异常处理页面用来获取异常信息的变量名，默认名为exception --&gt;    &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;/&gt;    &lt;!--定义需要特殊处理的异常，用类名或完全路径名作为key，异常页文件名作为值，将不同的异常映射到不同的页面上。--&gt;    &lt;property name=&quot;exceptionMappings&quot;&gt;        &lt;props&gt;            &lt;prop key=&quot;com.carleviets.exception.BusinessException&quot;&gt;business_error&lt;/prop&gt;            &lt;prop key=&quot;com.carleviets.exception.ParamsException&quot;&gt;params_error&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><p>一个典型的异常显示界面如下：</p><pre><code>&lt;html&gt; &lt;head&gt;&lt;title&gt;Exception!&lt;/title&gt;&lt;/head&gt; &lt;body&gt; 　　&lt;% Exception e = (Exception)request.getAttribute(&quot;ex&quot;); %&gt; 　　&lt;H2&gt;Exception: &lt;%= e.getMessage();%&gt;&lt;/H2&gt; 　　&lt;P/&gt; 　　&lt;% e.printStackTrace(new java.io.PrintWriter(out)); %&gt; &lt;/body&gt; &lt;/html&gt; </code></pre><p>exception 是在 SimpleMappingExceptionResolver 被存放到 request 中的，具体可以查看源代码。</p><h2 id="二、实现-HandlerExceptionResolver-接口"><a href="#二、实现-HandlerExceptionResolver-接口" class="headerlink" title="二、实现 HandlerExceptionResolver 接口"></a>二、实现 HandlerExceptionResolver 接口</h2><p>使用这种方式只需要实现 resolveException 方法，该方法返回一个 ModelAndView 对象，在方法内部对异常的类型进行判断，然后返回合适的 ModelAndView 对象，如果该方法返回 null，则 Spring 会继续寻找其他的实现了 HandlerExceptionResolver 接口的 Bean。换句话说，Spring 会搜索所有注册在其环境中的实现了 HandlerExceptionResolver 接口的 Bean，逐个执行，直到返回了一个 ModelAndView 对象。</p><pre><code>package com.carleviets.exceptions.handler;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.HashMap;import java.util.Map;public class MyExceptionHandler implements HandlerExceptionResolver {    /**     *     * @param request     * @param response     * @param target   被调用的方法     * @param ex       用来接收异常的局部变量名     * @return     */    @Override    public ModelAndView resolveException(HttpServletRequest request,                                         HttpServletResponse response, Object target, Exception ex) {        //此处定义的Map实际上就是Spring mvc中的Model(Model的内部实现就是一个Map)        Map&lt;String,Object&gt; map=new HashMap&lt;String, Object&gt;();        map.put(&quot;ex&quot;, ex);        if(ex instanceof ParamsException){            return new ModelAndView(&quot;error_param&quot;, map);        }        if(ex instanceof BusinessException){            return new ModelAndView(&quot;error_business&quot;, map);        }        return new ModelAndView(&quot;error&quot;, map);    }}</code></pre><p>要注意，实现HandlerExceptionResolver接口的类必须声明到 Spring 配置文件中，或者使用 @Component 标签，让 Spring 管理它。</p><h2 id="三、使用-ExceptionHandler-注解实现异常处理"><a href="#三、使用-ExceptionHandler-注解实现异常处理" class="headerlink" title="三、使用 @ExceptionHandler 注解实现异常处理"></a>三、使用 @ExceptionHandler 注解实现异常处理</h2><p>该方法需要定义在某个 Controller 内部，表示能够处理同一个控制器中所有处理器方法抛出的相应异常。@ExceptionHandler 中可以添加一个或多个异常的类型，如果为空的话则认为可以触发所有的异常类型错误。</p><pre><code>package com.carleviets.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.ExceptionHandler;import javax.servlet.http.HttpServletRequest;import java.io.IOException;@Controllerpublic class  BaseController {    @ExceptionHandler(value={ParamsException.class,BusinessException.class, IOException.class})    public String exp(HttpServletRequest request, Exception ex) {        request.setAttribute(&quot;ex&quot;, ex);        if(ex instanceof ParamsException){            return &quot;error_param&quot;;        }        if(ex instanceof BusinessException){            return &quot;error_business&quot;;        }        return &quot;error&quot;;    }} </code></pre><p>上面我们写了一个BaseController,所有继承了该类的控制器就可以实现相应异常的处理。但这种方式对代码具有侵入性，考虑到Java具有单继承多实现的特点，这种方式不推荐使用。</p><h2 id="四、使用控制器通知"><a href="#四、使用控制器通知" class="headerlink" title="四、使用控制器通知"></a>四、使用控制器通知</h2><p>控制器通知是Spring 3.2引入的一个新特性，通俗来讲，控制器通知（controller advice）是任意带有@ControllerAdvice注解的类，这个类会包含一个或多个如下类型的方法：</p><pre><code>@ExceptionHandler 注解标注的方法；@InitBinder 注解标注的方法；@ModelAttribute 注解标注的方法</code></pre><p>在带有@ControllerAdvice注解的类中，以上所述的这些方法会运用到整个应用程序所有控制器中带有@RequestMapping注解的方法上。下面是Spring中ControllerAdvice的源码:</p><pre><code>@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface ControllerAdvice {    @AliasFor(&quot;basePackages&quot;)    String[] value() default {};    @AliasFor(&quot;value&quot;)    String[] basePackages() default {};    Class&lt;?&gt;[] basePackageClasses() default {};    Class&lt;?&gt;[] assignableTypes() default {};    Class&lt;? extends Annotation&gt;[] annotations() default {};}</code></pre><p>@ControllerAdvice注解本身已经使用了@Component，因此@ControllerAdvice注解所标注的类将会自动被组件扫描获取到，就像带有@Component注解的类一样。控制器通知最为实用的一个场景就是将所有的@ExceptionHandler方法收集到一个类中，这样所有控制器的异常就能在一个地方进行一致的处理。如下:</p><pre><code>package com.carleviets.exceptions.handler;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;//定义控制器通知@ControllerAdvicepublic class GlobalExceptionHandler {    //定义异常处理方法    @ExceptionHandler(BusinessException.class)    public String businessExceptionHandle(){        return &quot;error_business&quot;;    }    //定义异常处理方法    @ExceptionHandler(ParamsException.class)    public String businessExceptionHandle(){        return &quot;params_business&quot;;    }}</code></pre><h2 id="五、将具体的异常映射为HTTP状态码"><a href="#五、将具体的异常映射为HTTP状态码" class="headerlink" title="五、将具体的异常映射为HTTP状态码"></a>五、将具体的异常映射为HTTP状态码</h2><p>在默认情况下， Spring会将自身的一些异常自动转换为合适的状态码。但是我们也可以通过@ResponseStatus将具体的异常隐射为具体的HTTP状态码。</p><pre><code>package com.carleviets.exceptions;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.ResponseStatus;@ResponseStatus(value = HttpStatus.NOT_FOUND, reason = &quot;文档不存在&quot;)public class DocumentNotFoundException extends RuntimeException {}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 全局异常处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring定时任务的实现</title>
      <link href="/2019/01/14/Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2019/01/14/Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、通过xml的方式配置定时任务"><a href="#一、通过xml的方式配置定时任务" class="headerlink" title="一、通过xml的方式配置定时任务"></a>一、通过xml的方式配置定时任务</h2><p>以下是通过XML实现定时任务的具体Java代码:</p><pre><code>package com.carleviets;import org.springframework.stereotype.Component;@Componentpublic class TaskJob {    public void job01(){        System.out.println(&quot;job01...&quot;);    }    public void job02(){        System.out.println(&quot;job02...&quot;);    }}</code></pre><p>以下是使用XML配置定时任务时spring.xml的具体配置:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;   xmlns:task=&quot;http://www.springframework.org/schema/task&quot;   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd   http://www.springframework.org/schema/task   http://www.springframework.org/schema/task/spring-task.xsd&quot;&gt;    &lt;!--启动Spring组件扫描--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets&quot;/&gt;    &lt;!--XML的方式配置定时任务--&gt;    &lt;task:scheduled-tasks&gt;        &lt;task:scheduled ref=&quot;taskJob&quot; method=&quot;job01&quot; cron=&quot;0/5 * * * * ? &quot;/&gt;        &lt;task:scheduled ref=&quot;taskJob&quot; method=&quot;job02&quot; cron=&quot;0/2 * * * * ? &quot; /&gt;    &lt;/task:scheduled-tasks&gt;&lt;/beans&gt;</code></pre><h2 id="二、通过注解的方式配置定时任务"><a href="#二、通过注解的方式配置定时任务" class="headerlink" title="二、通过注解的方式配置定时任务"></a>二、通过注解的方式配置定时任务</h2><p>以下是通过注解的方式实现定时任务的具体Java代码：</p><pre><code>package com.carleviets;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;@Componentpublic class TaskJob {    @Scheduled(cron = &quot;0/5 * * * * ? &quot;)    public void job01(){        System.out.println(&quot;job03...&quot;);    }    @Scheduled(cron = &quot;0/2 * * * * ? &quot;)    public void job02(){        System.out.println(&quot;job04...&quot;);    }}</code></pre><p>以下是使用注解配置定时任务时spring.xml的具体配置:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;   xmlns:task=&quot;http://www.springframework.org/schema/task&quot;   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context.xsd   http://www.springframework.org/schema/task   http://www.springframework.org/schema/task/spring-task.xsd&quot;&gt;    &lt;!--启动Spring组件扫描--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets&quot;/&gt;      &lt;!--引入定时任务的注解驱动--&gt;       &lt;task:annotation-driven/&gt;&lt;/beans&gt;</code></pre><h2 id="三、分析总结"><a href="#三、分析总结" class="headerlink" title="三、分析总结"></a>三、分析总结</h2><p>不管是用过XML的方式还是通过注解的方式配置定时任务，都应该先引入spring-task的命名空间:</p><pre><code>xmlns:task=&quot;http://www.springframework.org/schema/taskhttp://www.springframework.org/schema/taskhttp://www.springframework.org/schema/task/spring-task.xsd</code></pre><p>其次，根据不同的情况来给定时任务的代码使用Cron表达式，具体Cron表达式的生成可参照: <a href="http://cron.qqe2.com/" target="_blank" rel="noopener">http://cron.qqe2.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Spring中的作用域问题</title>
      <link href="/2019/01/13/%E5%85%B3%E4%BA%8ESpring%E4%B8%ADbean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2019/01/13/%E5%85%B3%E4%BA%8ESpring%E4%B8%ADbean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="一、bean的四种作用域"><a href="#一、bean的四种作用域" class="headerlink" title="一、bean的四种作用域"></a>一、bean的四种作用域</h2><p>Spring定义了多种作用域，可以基于这些作用域创建bean，包括:</p><pre><code>单例（Singleton）：在整个应用中，只创建bean的一个实例。原型（Prototype）：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。会话（Session）：在Web应用中，为每个会话创建一个bean实例。请求（Rquest）：在Web应用中，为每个请求创建一个bean实例 </code></pre><p>在默认情况下， Spring应用上下文中所有bean都是作为以单例（singleton）的形式创建的。也就是说，不管给定的一个bean被注入到其他bean多少次，每次所注入的都是同一个实例。在大多数情况下，单例bean是很理想的方案。但是在某些情况下，你所使用的类是易变的（mutable），它们会保持一些状态，因此重用是不安全的。在这种情况下，将class声明为单例的bean就不是什么好主意了。</p><h2 id="二、使用其他作用域的bean"><a href="#二、使用其他作用域的bean" class="headerlink" title="二、使用其他作用域的bean"></a>二、使用其他作用域的bean</h2><p>要声明bean为其他作用域，可以使用@Scope注解，以下是用过@Scope注解和@Component注解一起使用，声明了一个原型作用域的bean：</p><pre><code>@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class Notepad{...}</code></pre><p>这里，使用ConfigurableBeanFactory类的<code>SCOPE_PROTOTYPE</code>常量设置了原型作用域。你当然也可以使用@Scope(“prototype”)，但是使用<code>SCOPE_PROTOTYPE</code>常量更加安全并且不易出错。</p><p>同样，@Scope注解也可以和@Bean注解一起使用:</p><pre><code>@Bean@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public Notepad notepad(){    return new Notepad();}</code></pre><p>同样，可以使用scope属性通过XML的方式配置其他作用域的bean:</p><pre><code>&lt;bean id=&quot;notepad&quot; class=&quot;com.carleviets.Notepad&quot; scope=&quot;prototype&quot;/&gt;</code></pre><h2 id="三、使用会话和请求作用域"><a href="#三、使用会话和请求作用域" class="headerlink" title="三、使用会话和请求作用域"></a>三、使用会话和请求作用域</h2><p>在典型的电子商务应用中，可能会有一个bean代表用户的购物车。如果购物车是单例的话，那么将会导致所有的用户都会向同一个购物车中添加商品。另一方面，如果购物车是原型作用域的，那么在应用中某一个地方往购物车中添加商品，在应用的另外一个地方可能就不可用了。就购物车bean来说，会话作用域是最为合适的，因为它与给定的用户关联性最大。</p><pre><code>@Component@Scope(value=WebApplicationContext.SCOPE_SESSION, proxyMode=ScopedProxyMode.INTERFACES)public class ShoppingCart{...}</code></pre><p>注意,@Scope同时还有一个proxyMode属性，它被设置成了ScopedProxyMode.INTERFACES。这个属性解决了将会话或请求作用域的bean注入到单例bean中所遇到的问题。例如，如下的StoreService bean表示在线商店提供的服务:</p><pre><code>@Componentpublic class StoreService{    private ShoppingCart shoppingCart;    @Autowired    public void setShoppingCart(ShoppingCart shoppingCart){        this.shoppingCart=shoppingCart;    }    ...}</code></pre><p>因为StoreService是一个单例的bean，会在Spring应用上下文加载的时候创建。当它创建的时候， Spring会试图将ShoppingCart bean注入到setShoppingCart()方法中。但是ShoppingCart bean是会话作用域的，此时并不存在。直到某个用户进入系统，创建了会话之后，才会出现ShoppingCart实例。</p><p>如果使用了proxyMode=ScopedProxyMode.INTERFACES的话，Spring并不会将实际的ShoppingCart bean注入到StoreService中，而是会注入一个到ShoppingCart bean的代理，如图所示。这个代理会暴露与ShoppingCart相同的方法，所以StoreService会认为它就是一个购物车。但是，当StoreService调用ShoppingCart的方法时，代理会对其进行懒解析并将调用委托给会话作用域内真正的ShoppingCart bean。</p><p><img src="http://wx1.sinaimg.cn/mw690/0060lm7Tly1fz6igknkjlj30r00dy78f.jpg" alt="avatar"></p><p>这是使用的是Spring基于接口的代理，但如果ShoppingCart是一个具体的类的话，Spring就没有办法创建基于接口的代理了。此时，它必须使用CGLib来生成基于类的代理。所以，如果bean类型是具体类的话，我们必须要将proxyMode属性设置为ScopedProxyMode.TARGET_CLASS，以此来表明要以生成目标类扩展的方式创建代理。</p><p>尽管这里主要关注了会话作用域，但是请求作用域的bean会面临相同的装配问题。因此，请求作用域的bean应该也以作用域代理的方式进行注入。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 四种作用域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>邮件发送实的现</title>
      <link href="/2019/01/13/%E4%BD%BF%E7%94%A8JDK%E5%92%8C%E4%BD%BF%E7%94%A8Spring%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E7%9A%84%E5%8F%91%E9%80%81/"/>
      <url>/2019/01/13/%E4%BD%BF%E7%94%A8JDK%E5%92%8C%E4%BD%BF%E7%94%A8Spring%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E7%9A%84%E5%8F%91%E9%80%81/</url>
      
        <content type="html"><![CDATA[<h3 id="一、邮件发送相关的协议"><a href="#一、邮件发送相关的协议" class="headerlink" title="一、邮件发送相关的协议"></a>一、邮件发送相关的协议</h3><pre><code>SMTP： 简单邮件传输协议（Simple Mail Transfer Protocol），该协议定义了邮件发送的机制。POP3：邮局协议（Post Office Protocol），目前用的是版本3，也称POP3。POP3协议定义了接收电子邮件的标准。IMAP： 互联网消息协议(Internet Message Access Protocol)，是更高级的用于接收消息的协议，作为POP3的替代。MIME： 代表多用途因特网邮件扩展标准（Multipurpose Internet Mail Extensions） 。 它不是邮件传输协议。 但对传输内容的消息、       附件及其它的内容定义了格式。</code></pre><h3 id="二、JavaMail中的关键属性"><a href="#二、JavaMail中的关键属性" class="headerlink" title="二、JavaMail中的关键属性"></a>二、JavaMail中的关键属性</h3><pre><code>属性名                                   属性类型                             说明mail.smtp.host                              String                 SMTP服务器地址， 如smtp.sina.com.cnmail.smtp.port                           int                     SMTP服务器端口号，默认为 25mail.smtp.auth                              boolean                 SMTP服务器是否需要用户认证，默认为 falsemail.smtp.user                              String                 SMTP默认的登陆用户名mail.smtp.from                              String                 默认的邮件发送源地址mail.smtp.socketFactory.class             String                 socket工厂类类名， 通过设置该属性可以覆盖提供者默认的实现，                                                                必须实现 javax.NET.SocketFactory接口mail.smtp.socketFactory.port              int                       指定 socket 工厂类所用的端口号，如果没有规定， 则使用默认的端口号mail.smtp.socketFactory.fallback          boolean                 设置为 true时，当使用指定的socket类创建socket失败后，将使用                                                                Java.net.Socket 创建 socket， 默认为 truemail.smtp.timeout                          int                     I/O连接超时时间， 单位为毫秒，默认为永不超时</code></pre><h3 id="三、JavaMail中的关键对象"><a href="#三、JavaMail中的关键对象" class="headerlink" title="三、JavaMail中的关键对象"></a>三、JavaMail中的关键对象</h3><h4 id="3-1-Session对象"><a href="#3-1-Session对象" class="headerlink" title="3.1 Session对象"></a>3.1 Session对象</h4><p>创建 Session 对象时，并没有对应的物理连接， 它只不过是一对配置信息的集合。 Session 的主要作用包括两个方面：</p><pre><code>1） 接收各种配置属性信息：通过 Properties 对象设置的属性信息；2） 初始化JavaMail环境：根据JavaMail的配置文件，初始化JavaMail环境，以便通过Session对象创建其他重要类的实例。</code></pre><h4 id="3-2-Transport对象和Store对象"><a href="#3-2-Transport对象和Store对象" class="headerlink" title="3.2 Transport对象和Store对象"></a>3.2 Transport对象和Store对象</h4><p>Transport对象对应着邮件的发送，而Store对象对应着邮件的接收。</p><h4 id="3-3-Message对象"><a href="#3-3-Message对象" class="headerlink" title="3.3 Message对象"></a>3.3 Message对象</h4><p>Message对象即为用户发送的邮件，由于Messa类是一个抽象类，多数情况下使用其子类为javax.mail.internet.MimeMessage。MimeMessage是个能理解MIME类型和头的电子邮件消息。</p><h4 id="3-4-Address对象"><a href="#3-4-Address对象" class="headerlink" title="3.4 Address对象"></a>3.4 Address对象</h4><p>Address对象是邮件发送的地址，和Message一样，Address也是个抽象类。您用的是javax.mail.internet.InternetAddress类。</p><h4 id="3-5-Authenticator对象"><a href="#3-5-Authenticator对象" class="headerlink" title="3.5 Authenticator对象"></a>3.5 Authenticator对象</h4><p>JavaMail API利用Authenticator通过用户名和密码访问受保护的资源。对于JavaMail API来说，这些资源就是邮件服务器。</p><p>要使用 Authenticator，先创建一个抽象类的子类，并从getPasswordAuthentication()方法中返回PasswordAuthentication实例。 创建完<br>成后，您必需向session注册Authenticator。然后，在需要认证的时候，就会通知Authenticator。</p><h3 id="三、使用JDK实现邮件的发送功能"><a href="#三、使用JDK实现邮件的发送功能" class="headerlink" title="三、使用JDK实现邮件的发送功能"></a>三、使用JDK实现邮件的发送功能</h3><p>下面是通过JDK的方式实现邮件发送功能的代码：</p><pre><code>package com.carleviets.jdk;import com.carleviets.auth.MyAuthenticator;import javax.activation.DataHandler;import javax.activation.FileDataSource;import javax.mail.*;import javax.mail.internet.*;import java.io.File;import java.io.UnsupportedEncodingException;import java.util.Date;import java.util.Properties;/** *  通过JDK的方式发送邮件 */public class SendMail {    /**     * 发送一封带附件的html邮件     *  1、设置配置信息     *  2、创建Session对象，添加配置和授权     *  3、设置收件人、发件人和邮件信息     *  4、发送邮件     */    public void test() throws MessagingException, UnsupportedEncodingException {        //===============设置配置信息===============        //定义邮箱服务器配置        Properties properties=new Properties();        //163   邮件服务器地址        properties.put(&quot;mail.smtp.host&quot;, &quot;smtp.163.com&quot;);        //163   邮件服务器端口        properties.put(&quot;mail.smtp.port&quot;, &quot;25&quot;);        //163   邮件服务器认证属性        properties.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;);        //===============创建Session会话，添加配置和授权===============        Session session=Session.getInstance(properties,                new MyAuthenticator(&quot;carleviets0420@163.com&quot;, &quot;carleviets0318&quot;));        //===============设置收件人、发件人和邮件信息===============        Message message=new MimeMessage(session);        message.setFrom(new InternetAddress(&quot;carleviets0420@163.com&quot;)); //设置发件人邮箱地址        message.setRecipient(Message.RecipientType.TO, new InternetAddress(&quot;carleviets0420@163.com&quot;));  //设置收件人邮箱地址        //message.setRecipient(RecipientType.CC, new InternetAddress(&quot;xxx@163.com&quot;));//设置抄送人        //message.setRecipient(RecipientType.BCC, new InternetAddress(&quot;xxx@163.com&quot;));// 设置密送人        message.setSubject(&quot;我的第一封带附件的html邮件&quot;);  //设置主题        message.setSentDate(new Date());    //设置头部信息中的发件时间        Multipart multipart=new MimeMultipart();        //发送html邮件        BodyPart bodyPart1=new MimeBodyPart();        StringBuilder stringBuilder=new StringBuilder();        stringBuilder.append(&quot;&lt;html&gt;&lt;body&gt;&lt;a href=&#39;http://www.baidu.com&#39;&gt;狗日的百度&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&quot;);        bodyPart1.setContent(stringBuilder.toString(), &quot;text/html;charset=UTF-8&quot;);        multipart.addBodyPart(bodyPart1);        //发送带附件的邮件        BodyPart bodyPart2=new MimeBodyPart();        FileDataSource fileDataSource=new FileDataSource(new File(&quot;C:\\Users\\Administrator\\Desktop\\timg.jpg&quot;));        //设置附件        bodyPart2.setDataHandler(new DataHandler(fileDataSource));        //设置文件名——MimeUtility用于对文字进行Base64编码        bodyPart2.setFileName(MimeUtility.encodeText(&quot;高圆圆.jpg&quot;));        multipart.addBodyPart(bodyPart2);        message.setContent(multipart);        //===============发送邮件===============        Transport.send(message);    }}</code></pre><p>下面是实现邮箱认证的代码：</p><pre><code>package com.carleviets.auth;import javax.mail.Authenticator;import javax.mail.PasswordAuthentication;public class MyAuthenticator extends Authenticator {    private String username;    //邮箱名称    private String password;    //邮箱授权码    public MyAuthenticator(String username, String password) {        this.username = username;        this.password = password;    }    //重写Authenticator抽象类中的getPasswordAuthentication方法    @Override    protected PasswordAuthentication getPasswordAuthentication() {        return new PasswordAuthentication(username, password);    }}</code></pre><h3 id="四、JDK邮件发送代码的封装"><a href="#四、JDK邮件发送代码的封装" class="headerlink" title="四、JDK邮件发送代码的封装"></a>四、JDK邮件发送代码的封装</h3><p>如下是一个邮件发送信息类的简单封装，可以看出该类是一个简单的JavaBean：</p><pre><code>package com.carleviets.po.vo;import java.util.List;/** * 邮件发送信息类的简单封装 */public class MailSenderInfo {    private String serverHost;          //服务器主机    private String serverPort;          //服务器端口    private String fromAddress;         //发件人的邮箱地址    private List&lt;String&gt; toAddress;     //收件人邮箱地址    private String userName;            //邮件服务器用户名    private String userPwd;             //邮件服务器密码    private String subject;             //邮件主题    private String content;             //邮件内容    private String flag=&quot;true&quot;;          //邮件服务器认证属性    private List&lt;String&gt; attachFileNames;   //附件文件名    //===============getters and setters===============    ...}</code></pre><p>邮件发送具体类的实现如下:</p><pre><code>package com.carleviets.service;import com.carleviets.auth.MyAuthenticator;import com.carleviets.po.vo.MailSenderInfo;import javax.activation.DataHandler;import javax.activation.FileDataSource;import javax.mail.*;import javax.mail.internet.*;import java.io.File;import java.io.UnsupportedEncodingException;import java.util.Date;import java.util.List;import java.util.Properties;/** * 简单封装邮件发送器，实现邮件的发送 */public class MailSender {    public void sendHtmlMail(MailSenderInfo mailSendInfo){        Message message=null;        Session session=null;        try{            MyAuthenticator authenticator=new MyAuthenticator(mailSendInfo.getUserName(), mailSendInfo.getUserPwd());            //===============定义邮箱服务器配置================            Properties properties=new Properties();            //163   邮件服务器地址            properties.put(&quot;mail.smtp.host&quot;, mailSendInfo.getServerHost());            //163   邮件服务器端口            properties.put(&quot;mail.smtp.port&quot;, mailSendInfo.getServerPort());            //163   邮件服务器认证属性            properties.put(&quot;mail.smtp.auth&quot;, mailSendInfo.getFlag());            //===============创建Session对象，添加配置和授权===============            session=Session.getInstance(properties, authenticator);            //===============设置收件人、发件人和邮件信息===============            message=new MimeMessage(session);            Address from=new InternetAddress(mailSendInfo.getFromAddress());            message.setFrom(from);            message.setSentDate(new Date());            if(mailSendInfo.getToAddress()!=null &amp;&amp; mailSendInfo.getToAddress().size()&gt;0){                Address[] addresses=new Address[mailSendInfo.getToAddress().size()];                for (int i=0;i&lt;mailSendInfo.getToAddress().size();i++){                    Address address=new InternetAddress(mailSendInfo.getToAddress().get(i));                    addresses[i]=address;                }                message.setRecipients(Message.RecipientType.TO, addresses); //设置收件人地址                message.setSubject(mailSendInfo.getSubject());                Multipart multipart=new MimeMultipart();                BodyPart bodyPart=new MimeBodyPart();                bodyPart.setContent(mailSendInfo.getContent(), &quot;text/html;charset=utf-8&quot;);                multipart.addBodyPart(bodyPart);                //附件添加                List&lt;String&gt; files=mailSendInfo.getAttachFileNames();                if(files!=null&amp;&amp; files.size()&gt;0){                    for(int i=0;i&lt;files.size();i++){                        File tempFile=new File(files.get(i));                        if(tempFile.exists()){                            BodyPart temp=new MimeBodyPart();                            temp.setDataHandler(new DataHandler(new FileDataSource(tempFile)));                            temp.setFileName(MimeUtility.encodeText(tempFile.getName()));   //设置文件名                            multipart.addBodyPart(temp);    //添加附件                        }                    }                }                //设置邮件内容                message.setContent(multipart);                //===============发送邮件===============                Transport.send(message);            }        } catch (AddressException e) {            e.printStackTrace();        } catch (MessagingException e) {            e.printStackTrace();        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        }    }}</code></pre><p>测试代码很简单，这里略去。</p><h3 id="五、使用spring来实现邮件的发送"><a href="#五、使用spring来实现邮件的发送" class="headerlink" title="五、使用spring来实现邮件的发送"></a>五、使用spring来实现邮件的发送</h3><h4 id="5-1-maven坐标依赖"><a href="#5-1-maven坐标依赖" class="headerlink" title="5.1 maven坐标依赖"></a>5.1 maven坐标依赖</h4><pre><code>&lt;!--junit测试依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;junit&lt;/groupId&gt;  &lt;artifactId&gt;junit&lt;/artifactId&gt;  &lt;version&gt;4.12&lt;/version&gt;  &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--spring-test测试--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-test&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring核心依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring 上下文环境支持--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--java mail邮件发送--&gt;&lt;dependency&gt;  &lt;groupId&gt;javax.mail&lt;/groupId&gt;  &lt;artifactId&gt;mail&lt;/artifactId&gt;  &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;</code></pre><h4 id="5-2-spring-xml具体配置"><a href="#5-2-spring-xml具体配置" class="headerlink" title="5.2 spring.xml具体配置"></a>5.2 spring.xml具体配置</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!--配置JavaMailSenderImpl bean--&gt;    &lt;bean id=&quot;mailSender&quot; class=&quot;org.springframework.mail.javamail.JavaMailSenderImpl&quot;&gt;        &lt;property name=&quot;host&quot; value=&quot;smtp.163.com&quot;/&gt;        &lt;property name=&quot;port&quot; value=&quot;25&quot;/&gt;        &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;carleviets0420@163.com&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;carleviets0318&quot;/&gt;        &lt;property name=&quot;javaMailProperties&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;mail.smtp.auth&quot;&gt;true&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!--this is a template message that we can preload with a default state--&gt;    &lt;!--配置SimpleMailMessage bean--&gt;    &lt;bean id=&quot;templateMessage&quot; class=&quot;org.springframework.mail.SimpleMailMessage&quot;&gt;        &lt;property name=&quot;from&quot; value=&quot;carleviets0420@163.com&quot;/&gt;        &lt;property name=&quot;subject&quot; value=&quot;spring email&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置发送邮件的bean--&gt;    &lt;bean id=&quot;mailManager&quot; class=&quot;com.carleviets.springimpl.SimpleMailManager&quot;&gt;        &lt;property name=&quot;mailSender&quot; ref=&quot;mailSender&quot;/&gt;        &lt;property name=&quot;mailMessage&quot; ref=&quot;templateMessage&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h4 id="5-3定义邮件发送接口"><a href="#5-3定义邮件发送接口" class="headerlink" title="5.3定义邮件发送接口"></a>5.3定义邮件发送接口</h4><pre><code>package com.carleviets.springInterface;/** *  发送邮件接口的定义 */public interface MailManager {    void placeMail();}</code></pre><h4 id="5-4定义邮件发送接口"><a href="#5-4定义邮件发送接口" class="headerlink" title="5.4定义邮件发送接口"></a>5.4定义邮件发送接口</h4><pre><code>package com.carleviets.springimpl;import com.carleviets.springInterface.MailManager;import org.springframework.mail.MailException;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSenderImpl;/** * 发送邮件的简单实现类——在发送邮件的方法中实现发送邮件的代码 */public class SimpleMailManager implements MailManager {    @Autowired    private JavaMailSenderImpl mailSender;    @Autowired    private SimpleMailMessage mailMessage;    @Override    public void placeMail() {        mailMessage.setTo(&quot;carleviets0420@163.com&quot;);        mailMessage.setText(&quot;江火似流萤...&quot;);        try{            mailSender.send(message);        }catch (MailException ex){            System.err.println(ex.getMessage());        }    }}</code></pre><p>普通邮件测试代码如下：</p><pre><code>@Testpublic void test(){    mailManager.placeMail();}</code></pre><h4 id="5-5使用spring发送带附件的邮件"><a href="#5-5使用spring发送带附件的邮件" class="headerlink" title="5.5使用spring发送带附件的邮件"></a>5.5使用spring发送带附件的邮件</h4><p>使用spring发送带附件的邮件步骤和普通邮件一样，只是需要借助MimeMessageHelper辅助类来设置消息的属性。具体测试代码如下：</p><pre><code>/** * 测试通过spring发送带有附件的邮件 * @throws MessagingException */@Testpublic void test() throws MessagingException {    ApplicationContext applicationContext=            new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);    JavaMailSender mailSender= (JavaMailSender) applicationContext.getBean(&quot;mailSender&quot;);    MimeMessage message=mailSender.createMimeMessage();    message.setSubject(&quot;spring mail file&quot;);    //创建带有附件的消息帮助类    MimeMessageHelper helper=new MimeMessageHelper(message, true, &quot;utf-8&quot;);    helper.setTo(new InternetAddress(&quot;carleviets0420@163.com&quot;));    //设置接收人    helper.setText(&quot;Thank you for ordering!&quot;);    helper.setFrom(&quot;carleviets0420@163.com&quot;);    helper.addAttachment(&quot;timg.jpg&quot;, new File(&quot;C:\\Users\\Administrator\\Desktop\\timg.jpg&quot;));    mailSender.send(message);}</code></pre><p>至此，我们就实现了通过JDK的方式和通过Spring Mail的方式来实现邮件的发送。</p>]]></content>
      
      
      <categories>
          
          <category> Java Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 邮件发送 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用工具类总结</title>
      <link href="/2019/01/13/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/13/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1-1、AssertUtil"><a href="#1-1、AssertUtil" class="headerlink" title="1.1、AssertUtil"></a>1.1、AssertUtil</h3><p>该实用工具类主要通过断言的思想，在相应的条件成立下，通过抛出异常的方式来阻止代码的继续执行，可以在很多情况下将需要好几行的代码浓缩为只有一行代码，并且可以配合全局异常处理器的使用来将异常处理集中到处理器中。具体如下:</p><pre><code>package com.carleviets.crm.utils;import com.carleviets.crm.exceptions.LoginException;import com.carleviets.crm.exceptions.ParamsException;public class AssertUtil {    public static void isTrue(Boolean flag, String msg){        if(flag){            throw new ParamsException(msg);        }    }    public static void isTrue(Boolean flag, Integer code, String msg){        if(flag){            throw new ParamsException(code, msg);        }    }    public static void isNotLogin(Boolean flag, String msg) {        if(flag){            throw new LoginException(msg);        }    }}</code></pre><h3 id="1-2、JsonUtil"><a href="#1-2、JsonUtil" class="headerlink" title="1.2、JsonUtil"></a>1.2、JsonUtil</h3><p>该实用工具类主要用于将java对象以JSON字符串的形式响应给客户端，具体代码如下：</p><pre><code>package com.carleviets.crm.utils;import com.alibaba.fastjson.JSON;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class JsonUtil {    /**     * 将对象转换为json字符串并发送到前台     * @param object     * @param response     */    public static void toJson(Object object, HttpServletResponse response){        try {            //将对象转换为json字符串            String jsonStr= JSON.toJSONString(object);            //设置响应类型及编码            response.setContentType(&quot;application/json;charset=utf-8&quot;);            //得到输出流            PrintWriter out=response.getWriter();            out.write(jsonStr);            out.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><h3 id="1-3、MD5Util"><a href="#1-3、MD5Util" class="headerlink" title="1.3、MD5Util"></a>1.3、MD5Util</h3><p>该实用工具类主要用于对字符串进行MD5加密，具体代码如下:</p><pre><code>package com.carleviets.crm.utils;import org.apache.commons.codec.binary.Base64;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class MD5Util {    public static String encode(String str){        String value=&quot;&quot;;        try {            //得到MD5加密的算法程序            MessageDigest messageDigest=MessageDigest.getInstance(&quot;MD5&quot;);            //对字符串进行MD5加密，返回byte数组            byte[] bytes=messageDigest.digest(str.getBytes());            //使用Base64对byte数组进行编码            value=Base64.encodeBase64String(bytes);        } catch (NoSuchAlgorithmException e) {            e.printStackTrace();        }        return value;    }    public static void main(String[] args) {        System.out.println(encode(&quot;12345&quot;));    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用工具类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM整合依赖及配置总结</title>
      <link href="/2019/01/13/SSM%E6%95%B4%E5%90%88%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/13/SSM%E6%95%B4%E5%90%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、所需引入的maven依赖"><a href="#一、所需引入的maven依赖" class="headerlink" title="一、所需引入的maven依赖"></a>一、所需引入的maven依赖</h2><h3 id="1-1测试依赖"><a href="#1-1测试依赖" class="headerlink" title="1.1测试依赖"></a>1.1测试依赖</h3><pre><code>&lt;!--junit测试依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;junit&lt;/groupId&gt;  &lt;artifactId&gt;junit&lt;/artifactId&gt;  &lt;version&gt;4.12&lt;/version&gt;  &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--spring测试依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-test&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-2-spring核心依赖"><a href="#1-2-spring核心依赖" class="headerlink" title="1.2 spring核心依赖"></a>1.2 spring核心依赖</h3>   <!--spring上下文依赖--><pre><code>&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectj切面代理--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;  &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;  &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-3-数据库相关"><a href="#1-3-数据库相关" class="headerlink" title="1.3 数据库相关"></a>1.3 数据库相关</h3><pre><code>&lt;!--spring jdbc--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring 事务管理--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--c3p0连接池--&gt;&lt;dependency&gt;  &lt;groupId&gt;com.mchange&lt;/groupId&gt;  &lt;artifactId&gt;c3p0&lt;/artifactId&gt;  &lt;version&gt;0.9.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis核心依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;  &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis与spring整合依赖--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;  &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql数据库驱动包--&gt;&lt;dependency&gt;  &lt;groupId&gt;mysql&lt;/groupId&gt;  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  &lt;version&gt;8.0.11&lt;/version&gt;&lt;/dependency&gt;    &lt;!--mybatis分页插件--&gt;&lt;dependency&gt;  &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;  &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;  &lt;version&gt;4.1.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-4-日志打印"><a href="#1-4-日志打印" class="headerlink" title="1.4 日志打印"></a>1.4 日志打印</h3><pre><code>&lt;!--日志打印相关jar--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;  &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;  &lt;version&gt;1.7.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;  &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;  &lt;version&gt;1.7.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-5-spring-mvc依赖"><a href="#1-5-spring-mvc依赖" class="headerlink" title="1.5 spring-mvc依赖"></a>1.5 spring-mvc依赖</h3><pre><code>&lt;!--spring web--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-web&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring webmvc--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring mvc上下文支持 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;  &lt;version&gt;4.3.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--web servlet--&gt;&lt;dependency&gt;  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;  &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;  &lt;version&gt;3.0.1&lt;/version&gt;  &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;</code></pre><h3 id="1-6-json支持"><a href="#1-6-json支持" class="headerlink" title="1.6 json支持"></a>1.6 json支持</h3><pre><code>&lt;!--json依赖jar--&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;  &lt;version&gt;2.9.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;  &lt;version&gt;2.9.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;  &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;  &lt;version&gt;2.9.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--阿里巴巴 fastjson --&gt;&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  &lt;version&gt;1.2.47&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-7-Apache-commons文件上传支持"><a href="#1-7-Apache-commons文件上传支持" class="headerlink" title="1.7 Apache-commons文件上传支持"></a>1.7 Apache-commons文件上传支持</h3><pre><code>&lt;!--commons文件上传--&gt;&lt;dependency&gt;  &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;  &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;  &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="1-8其他工具包"><a href="#1-8其他工具包" class="headerlink" title="1.8其他工具包"></a>1.8其他工具包</h3><pre><code>&lt;!-- commons-lang3实用工具类 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;  &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;  &lt;version&gt;3.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Base64编码解码支持 --&gt;&lt;dependency&gt;  &lt;groupId&gt;commons-codec&lt;/groupId&gt;  &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;  &lt;version&gt;1.10&lt;/version&gt;&lt;/dependency&gt;&lt;!-- freemarker视图模板 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.freemarker&lt;/groupId&gt;  &lt;artifactId&gt;freemarker&lt;/artifactId&gt;  &lt;version&gt;2.3.23&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>###1.9其他配置###</p><pre><code>&lt;!--指定资源访问路径，默认情况下为src/main/resources目录--&gt;&lt;resources&gt;  &lt;resource&gt;    &lt;directory&gt;src/main/resources/${env}&lt;/directory&gt;  &lt;/resource&gt;  &lt;resource&gt;    &lt;directory&gt;src/main/java&lt;/directory&gt;    &lt;includes&gt;      &lt;include&gt;**/*.xml&lt;/include&gt;      &lt;include&gt;**/*.properties&lt;/include&gt;      &lt;include&gt;**/*.tld&lt;/include&gt;    &lt;/includes&gt;    &lt;filtering&gt;false&lt;/filtering&gt;  &lt;/resource&gt;&lt;/resources&lt;plugins&gt;  &lt;!--如果用到了Base64编码，需要指定编译的虚拟机--&gt;  &lt;plugin&gt;    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;    &lt;configuration&gt;      &lt;source&gt;1.8&lt;/source&gt;      &lt;target&gt;1.8&lt;/target&gt;      &lt;encoding&gt;utf-8&lt;/encoding&gt;      &lt;compilerArguments&gt;        &lt;bootclasspath&gt;${java.home}/lib/rt.jar&lt;/bootclasspath&gt;      &lt;/compilerArguments&gt;    &lt;/configuration&gt;  &lt;/plugin&gt;  &lt;!--jetty服务器插件--&gt;  &lt;plugin&gt;    &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;    &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;    &lt;version&gt;6.1.25&lt;/version&gt;    &lt;configuration&gt;      &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt;      &lt;contextPath&gt;/crm&lt;/contextPath&gt;      &lt;webDefaultXml&gt;src/main/resources/${env}/webdefault.xml&lt;/webDefaultXml&gt;    &lt;/configuration&gt;  &lt;/plugin&gt;  &lt;!--mybatis代码自动生成插件--&gt;  &lt;plugin&gt;      &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;      &lt;version&gt;1.3.2&lt;/version&gt;      &lt;configuration&gt;        &lt;configurationFile&gt;src/main/resources/${env}/generatorConfig.xml&lt;/configurationFile&gt;        &lt;verbose&gt;true&lt;/verbose&gt;        &lt;overwrite&gt;true&lt;/overwrite&gt;      &lt;/configuration&gt;  &lt;/plugin&gt;&lt;/plugins&gt;&lt;!--配置不同的环境打包--&gt;&lt;profiles&gt;    &lt;!--默认开发环境--&gt;    &lt;profile&gt;      &lt;id&gt;dev&lt;/id&gt;      &lt;properties&gt;        &lt;env&gt;dev&lt;/env&gt;      &lt;/properties&gt;      &lt;!--此处指定哪个环境激活打包时就打哪个环境下的包--&gt;      &lt;activation&gt;        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;      &lt;/activation&gt;    &lt;/profile&gt;    &lt;!--测试环境--&gt;    &lt;profile&gt;      &lt;id&gt;test&lt;/id&gt;      &lt;properties&gt;        &lt;env&gt;test&lt;/env&gt;      &lt;/properties&gt;    &lt;/profile&gt;    &lt;!--生产环境--&gt;    &lt;profile&gt;      &lt;id&gt;product&lt;/id&gt;      &lt;properties&gt;        &lt;env&gt;product&lt;/env&gt;      &lt;/properties&gt;    &lt;/profile&gt;&lt;/profiles&gt;</code></pre><h2 id="二、配置文件总结"><a href="#二、配置文件总结" class="headerlink" title="二、配置文件总结"></a>二、配置文件总结</h2><h3 id="2-1-web-xml配置文件"><a href="#2-1-web-xml配置文件" class="headerlink" title="2.1 web.xml配置文件"></a>2.1 web.xml配置文件</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt;  &lt;!--配置ContextLoaderListener监听的上下文参数--&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt;  &lt;/context-param&gt;  &lt;!--配置ContextLoaderListener上下文监听器--&gt;  &lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  &lt;/listener&gt;  &lt;!--配置字符过滤器--&gt;  &lt;filter&gt;    &lt;description&gt;char encoding filter&lt;/description&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;utf-8&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  &lt;!--配置spring-mvc前端控制器--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:servlet-context.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;!--注意次数映射路径不能为&quot;/*&quot;--&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><h3 id="2-2-spring-xml-配置文件"><a href="#2-2-spring-xml-配置文件" class="headerlink" title="2.2 spring.xml 配置文件"></a>2.2 spring.xml 配置文件</h3><p>该配置文件主要用于管理除了Controller层之外所有其它层的bean,配置如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:task=&quot;http://www.springframework.org/schema/task&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd        http://www.springframework.org/schema/task        http://www.springframework.org/schema/task/spring-task.xsd&quot;&gt;    &lt;!--开启组件扫描，通过注解的形式排除掉controller包--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets.crm&quot;&gt;        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;    &lt;/context:component-scan&gt;    &lt;!--指定数据库配置文件所在位置--&gt;    &lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;    &lt;!--配置c3p0数据源--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt;        &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置spring事务管理器并注入数据源--&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置事务通知--&gt;    &lt;tx:advice id=&quot;transactionInterceptor&quot; transaction-manager=&quot;transactionManager&quot;&gt;        &lt;tx:attributes&gt;            &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;query*&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;load*&quot; read-only=&quot;true&quot;/&gt;            &lt;tx:method name=&quot;add*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;del*&quot; propagation=&quot;REQUIRED&quot;/&gt;            &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!--通过aop切面配置事务管理--&gt;    &lt;aop:config&gt;        &lt;aop:pointcut id=&quot;servicePointCut&quot; expression=&quot;execution(* com.carleviets.crm.service..*.*(..))&quot;/&gt;        &lt;aop:advisor advice-ref=&quot;transactionInterceptor&quot; pointcut-ref=&quot;servicePointCut&quot;/&gt;    &lt;/aop:config&gt;    &lt;!--配置mybatis sqlSessionFactory bean--&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis.xml&quot;/&gt;        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/carleviets/crm/mapper/*.xml&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置mybatis包扫描器--&gt;    &lt;bean id=&quot;scannerConfigurer&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;!-- 扫描com.carleviets.crm.dao这个包以及它的子包下的所有映射接口类 --&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.carleviets.crm.dao&quot;/&gt;        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;    &lt;/bean&gt;    &lt;!--启用定时任务的注解驱动--&gt;    &lt;task:annotation-driven/&gt;&lt;/beans&gt;</code></pre><h3 id="2-2-servlet-context-xml-配置文件"><a href="#2-2-servlet-context-xml-配置文件" class="headerlink" title="2.2 servlet-context.xml 配置文件"></a>2.2 servlet-context.xml 配置文件</h3><p>该配置文件用于配置spring-mvc,即管理所谓的Controller层的bean，配置如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;    &lt;!--开启组件扫描,并且只扫描controller包--&gt;    &lt;context:component-scan base-package=&quot;com.carleviets.crm.controller&quot;/&gt;    &lt;!--开启aspectj自动代理，由于controller层调用service层,service层dao层，故在此文件配置的aspectj自动代理可以代理其它层--&gt;    &lt;aop:aspectj-autoproxy/&gt;    &lt;!--配置freemarker配置--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;        &lt;property name=&quot;templateLoaderPath&quot; value=&quot;/WEB-INF/views/&quot;/&gt;        &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置freemarker视图解析器--&gt;    &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;&gt;        &lt;property name=&quot;prefix&quot; value=&quot;&quot;/&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.ftl&quot;/&gt;        &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=utf-8&quot;/&gt;    &lt;/bean&gt;    &lt;!--mvc注解驱动并添加对响应json的支持, 可不配，内部自动提供--&gt;    &lt;mvc:annotation-driven&gt;        &lt;mvc:message-converters&gt;            &lt;!--返回信息为字符串时处理--&gt;            &lt;bean id=&quot;stringHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;/&gt;            &lt;!--将对象转化为json字符串--&gt;            &lt;bean id=&quot;jackson2HttpMessageConverter&quot; class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;/&gt;        &lt;/mvc:message-converters&gt;    &lt;/mvc:annotation-driven&gt;    &lt;!--配置对静态资源的放行处理 方式一--&gt;    &lt;!--&lt;mvc:default-servlet-handler/&gt;--&gt;    &lt;!--配置对静态资源的放行处理 方式二--&gt;    &lt;mvc:resources mapping=&quot;/statics/**&quot; location=&quot;/statics/&quot;/&gt;    &lt;!--配置拦截器--&gt;    &lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;            &lt;!--拦截所有路径--&gt;            &lt;mvc:mapping path=&quot;/**&quot;/&gt;            &lt;!--静态资源放行--&gt;            &lt;mvc:exclude-mapping path=&quot;/statics/**&quot;/&gt;            &lt;!--登录页面放行--&gt;            &lt;mvc:exclude-mapping path=&quot;/index&quot;/&gt;            &lt;!--登录操作放行--&gt;            &lt;mvc:exclude-mapping path=&quot;/user/login&quot;/&gt;            &lt;!--配置拦截器bean--&gt;            &lt;bean class=&quot;com.carleviets.crm.interceptor.LoginInterceptor&quot;/&gt;        &lt;/mvc:interceptor&gt;    &lt;/mvc:interceptors&gt;&lt;/beans&gt;</code></pre><h3 id="2-3-mybatis-xml-配置文件"><a href="#2-3-mybatis-xml-配置文件" class="headerlink" title="2.3 mybatis.xml 配置文件"></a>2.3 mybatis.xml 配置文件</h3><p>该配置文件用于配置mybatis的别名扫描和分页插件配置，如果不需要别名和分页可不配置此文件。具体配置如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--配置mybatis别名包扫描--&gt;    &lt;typeAliases&gt;        &lt;package name=&quot;com.carleviets.crm.po&quot;/&gt;    &lt;/typeAliases&gt;    &lt;!--配置mybatis分页插件--&gt;    &lt;plugins&gt;        &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt;            &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;            &lt;!-- 该参数默认为false --&gt;            &lt;!-- 设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用 --&gt;            &lt;!-- 和startPage中的pageNum效果一样 --&gt;            &lt;property name=&quot;offsetAsPageNum&quot; value=&quot;true&quot;/&gt;            &lt;!-- 该参数默认为false --&gt;            &lt;!-- 设置为true时，使用RowBounds分页会进行count查询 --&gt;            &lt;property name=&quot;rowBoundsWithCount&quot; value=&quot;true&quot;/&gt;            &lt;!-- 设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果 --&gt;            &lt;!-- （相当于没有执行分页查询，但是返回结果仍然是Page类型） --&gt;            &lt;property name=&quot;pageSizeZero&quot; value=&quot;true&quot;/&gt;            &lt;!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 --&gt;            &lt;!-- 启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;pages会查询最后一页 --&gt;            &lt;!-- 禁用合理化时，如果pageNum&lt;1或pageNum&gt;pages会返回空数据 --&gt;            &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt;            &lt;!-- 3.5.0版本可用 - 为了支持startPage(Object params)方法 --&gt;            &lt;!-- 增加了一个`params`参数来配置参数映射，用于从Map或ServletRequest中取值 --&gt;            &lt;!-- 可以配置pageNum,pageSize,count,pageSizeZero,reasonable,不配置映射的用默认值 --&gt;            &lt;property name=&quot;params&quot; value=&quot;pageNum=start;pageSize=limit;pageSizeZero=zero;reasonable=heli;count=contsql&quot;/&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/configuration&gt;</code></pre><h3 id="2-4-generatorConfig-xml-配置文件"><a href="#2-4-generatorConfig-xml-配置文件" class="headerlink" title="2.4 generatorConfig.xml 配置文件"></a>2.4 generatorConfig.xml 配置文件</h3><p>该配置文件用于mybatis代码的逆向生成，要使用mybatis代码自动生成的功能需要在pom.xml中配置mybatis代码自动生成插件，插件的引入如下:</p><pre><code>&lt;!--mybatis代码自动生成插件--&gt;  &lt;plugin&gt;      &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;      &lt;version&gt;1.3.2&lt;/version&gt;      &lt;configuration&gt;        &lt;configurationFile&gt;src/main/resources/${env}/generatorConfig.xml&lt;/configurationFile&gt;        &lt;verbose&gt;true&lt;/verbose&gt;        &lt;overwrite&gt;true&lt;/overwrite&gt;      &lt;/configuration&gt;  &lt;/plugin&gt;</code></pre><p>generatorConfig.xml 配置文件的具体配置如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;!--数据库驱动，此处的路径为maven仓库下mysql数据库驱动所对应的路径--&gt;    &lt;classPathEntry location=&quot;D:/apache-maven-3.6.0/Repositories/mysql/mysql-connector-java/8.0.11/mysql-connector-java-8.0.11.jar&quot;/&gt;    &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;    &lt;!--生成的代码中不需要注释--&gt;    &lt;commentGenerator&gt;        &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;        &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;    &lt;/commentGenerator&gt;    &lt;!--数据库链接地址、账号和密码--&gt;    &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/project?useSSL=false&amp;amp;serverTimezone=GMT%2B8&quot; userId=&quot;root&quot; password=&quot;12345&quot;&gt;    &lt;/jdbcConnection&gt;    &lt;javaTypeResolver&gt;        &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;    &lt;/javaTypeResolver&gt;    &lt;!--生成Model类存放位置，此处路径为项目下src/main/java的绝对路径--&gt;    &lt;javaModelGenerator targetPackage=&quot;com.carleviets.crm.po&quot; targetProject=&quot;C:/Users/Administrator/IdeaProjects/crm_2/src/main/java&quot;&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;    &lt;/javaModelGenerator&gt;    &lt;!--生成映射文件存放位置，此处路径为项目下src/main/java的绝对路径--&gt;    &lt;sqlMapGenerator targetPackage=&quot;com.carleviets.crm.mapper&quot; targetProject=&quot;C:/Users/Administrator/IdeaProjects/crm_2/src/main/java&quot;&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;    &lt;/sqlMapGenerator&gt;    &lt;!--生成Dao类存放位置，此处路径为项目下src/main/java的绝对路径--&gt;    &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.carleviets.crm.dao&quot; targetProject=&quot;C:/Users/Administrator/IdeaProjects/crm_2/src/main/java&quot;&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;    &lt;/javaClientGenerator&gt;    &lt;!--指定需要生成代码、映射文件、Mapper接口的表--&gt;    &lt;table tableName=&quot;t_customer&quot; domainObjectName=&quot;Customer&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><h3 id="2-5-其他配置文件"><a href="#2-5-其他配置文件" class="headerlink" title="2.5 其他配置文件"></a>2.5 其他配置文件</h3><p>数据库属性文件db.properties:</p><pre><code>jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/crm?useSSL=false&amp;serverTimezone=GMT%2B8jdbc.username=rootjdbc.password=12345</code></pre><p>日志打印文件log4j.properties：</p><pre><code>log4j.rootLogger=DEBUG, Console  #Consolelog4j.appender.Console=org.apache.log4j.ConsoleAppender  log4j.appender.Console.layout=org.apache.log4j.PatternLayout  log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n  log4j.logger.java.sql.ResultSet=INFO  log4j.logger.org.apache=INFO  log4j.logger.java.sql.Connection=DEBUG  log4j.logger.java.sql.Statement=DEBUG  log4j.logger.java.sql.PreparedStatement=DEBUG </code></pre>]]></content>
      
      
      <categories>
          
          <category> SSM整合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven依赖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM整合时高可用代码总结</title>
      <link href="/2019/01/13/SSM%E6%95%B4%E5%90%88%E6%97%B6%E9%AB%98%E5%8F%AF%E7%94%A8%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/"/>
      <url>/2019/01/13/SSM%E6%95%B4%E5%90%88%E6%97%B6%E9%AB%98%E5%8F%AF%E7%94%A8%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1、BaseDAO"><a href="#1、BaseDAO" class="headerlink" title="1、BaseDAO"></a>1、BaseDAO</h3><p>baseDAO是一个高可用的接口，里面集成了添加、查询、修改、删除等方法，在ssm集成的时候，任何继承了该接口的mapper接口就拥有了对应的操作响应数据的方法，可以在很大程度上减少代码的重复，其具体如下：</p><pre><code>package com.carleviets.crm.base;import org.springframework.dao.DataAccessException;import java.util.List;import java.util.Map;public interface BaseDAO&lt;T&gt; {    /**     * 添加记录     * @param entity     * @return     * @throws DataAccessException     */    Integer save(T entity)throws DataAccessException;    /**     * 批量添加记录     * @param entities     * @return     * @throws DataAccessException     */    Integer saveBatch(List&lt;T&gt; entities) throws DataAccessException;    /**     * 通过id查询     * @param id     * @return     * @throws DataAccessException     */    T queryById(Integer id) throws DataAccessException;    /**     * 参数化查询     * @param baseQuery     * @return     * @throws DataAccessException     */    List&lt;T&gt; queryByParams(BaseQuery baseQuery) throws DataAccessException;    /**     * 更新单条记录     * @param entity     * @return     * @throws DataAccessException     */    Integer update(T entity) throws DataAccessException;    /**     * 批量更新     * @param map     * @return     * @throws DataAccessException     */    Integer updateBatch(Map&lt;String, Object&gt; map) throws DataAccessException;    /**     * 通过id删除单条记录     * @param id     * @return     * @throws DataAccessException     */    Integer delete(Integer id) throws DataAccessException;    /**     * 批量删除记录     * @param ids     * @return     * @throws DataAccessException     */    Integer deleteBatch(Integer[] ids) throws DataAccessException;}</code></pre><h3 id="2、BaseService"><a href="#2、BaseService" class="headerlink" title="2、BaseService"></a>2、BaseService</h3><p>该实用工具类对查询，更新、删除、分页查询等常用的操作进行了封装，Service层只需要继承该实用工具类，就可以省去大量的重复代码，具体如下:</p><pre><code>package com.carleviets.crm.base;import com.carleviets.crm.utils.AssertUtil;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.dao.DataAccessException;import java.util.HashMap;import java.util.List;import java.util.Map;public class BaseService&lt;T&gt; {    @Autowired    private BaseDAO&lt;T&gt; baseDAO;    /**     * 添加单条记录     * @param entity     * @return     * @throws DataAccessException     */    public Integer save(T entity) throws DataAccessException{        return baseDAO.save(entity);    }    /**     * 批量添加记录     * @param entities     * @return     * @throws DataAccessException     */    public Integer saveBatch(List&lt;T&gt; entities) throws DataAccessException{        return baseDAO.saveBatch(entities);    }    /**     * 通过id查询     * @param id     * @return     * @throws DataAccessException     */    public T queryById(Integer id) throws DataAccessException{        AssertUtil.isTrue(id==null||id&lt;0, &quot;带查询的记录不存在&quot;);        return baseDAO.queryById(id);    }    /**     * 参数化查询     * @param baseQuery     * @return     * @throws DataAccessException     */    public PageInfo&lt;T&gt; queryByParams(BaseQuery baseQuery) throws DataAccessException{        PageHelper.startPage(baseQuery.getPageNum(), baseQuery.getPageSize());        List&lt;T&gt; entities = baseDAO.queryByParams(baseQuery);        return new PageInfo&lt;T&gt;(entities);    }    /**     * 参数化分页查询     * @param baseQuery     * @return     * @throws DataAccessException     */    public Map&lt;String, Object&gt; queryForPage(BaseQuery baseQuery) throws DataAccessException{        PageHelper.startPage(baseQuery.getPageNum(), baseQuery.getPageSize());        List&lt;T&gt; entities=baseDAO.queryByParams(baseQuery);        PageInfo&lt;T&gt; pageInfo=new PageInfo&lt;T&gt;(entities);        Map&lt;String, Object&gt; map=new HashMap&lt;&gt;();        map.put(&quot;total&quot;, pageInfo.getTotal());        map.put(&quot;rows&quot;, pageInfo.getList());        return map;    }    /**     * 更新单条记录     * @param entity     * @return     * @throws DataAccessException     */    public Integer update(T entity) throws DataAccessException{        return baseDAO.update(entity);    }    /**     * 批量更新记录     * @param map     * @return     * @throws DataAccessException     */    public Integer updateBatch(Map&lt;String, Object&gt; map) throws DataAccessException{        return baseDAO.updateBatch(map);    }    /**     * 删除单条记录     * @param id     * @return     * @throws DataAccessException     */    public Integer delete(Integer id) throws DataAccessException{        AssertUtil.isTrue(id==null||id&lt;=0||queryById(id)==null, &quot;待删除的记录不存在&quot;);        return baseDAO.delete(id);    }    /**     * 批量删除记录     * @param ids     * @return     * @throws DataAccessException     */    public Integer deleteBatch(Integer[] ids) throws DataAccessException{        AssertUtil.isTrue(ids==null||ids.length==0, &quot;请选择待删除的记录&quot;);        return baseDAO.deleteBatch(ids);    }}</code></pre><h3 id="3、BaseController"><a href="#3、BaseController" class="headerlink" title="3、BaseController"></a>3、BaseController</h3><p>该实用工具类封装了对于成功操作时返回ResultInfo对象的方法，并且通过@ModelAttribute注解可以在继承该实用工具类的每一个控制器方法执行前统一在request作用域中添加了上下文路径，省去了大量的重复代码：</p><pre><code>package com.carleviets.crm.base;import com.carleviets.crm.po.vo.ResultInfo;import org.springframework.web.bind.annotation.ModelAttribute;import javax.servlet.http.HttpServletRequest;public class BaseController {    public ResultInfo success(Integer code, String msg, Object result){        ResultInfo resultInfo=new ResultInfo();        resultInfo.setCode(code);        resultInfo.setMsg(msg);        resultInfo.setResult(result);        return resultInfo;    }    public ResultInfo success(Integer code, String msg){        ResultInfo resultInfo=new ResultInfo();        resultInfo.setCode(code);        resultInfo.setMsg(msg);        return resultInfo;    }    //此注解标注的方法会在每个Controller的方法执行之前执行    @ModelAttribute    public void preHandle(HttpServletRequest request){        request.setAttribute(&quot;ctx&quot;, request.getContextPath());    }}</code></pre><h3 id="3、BaseQuery"><a href="#3、BaseQuery" class="headerlink" title="3、BaseQuery"></a>3、BaseQuery</h3><p>这个不用多说，所有的参数查询前台都需要传递pageNum和pageSize这两个参数，但是对于具体的情况，可以具有其他不同的参数，该实用工具类就是对pageNum和pageSize这两个参数进行简单封装的JavaBean，所有的参数查询都可以继承该实用工具类：</p><pre><code>package com.carleviets.crm.base;public class BaseQuery {    private Integer pageNum;    private Integer pageSize;    public Integer getPageNum() {        return pageNum;    }    public void setPageNum(Integer pageNum) {        this.pageNum = pageNum;    }    public Integer getPageSize() {        return pageSize;    }    public void setPageSize(Integer pageSize) {        this.pageSize = pageSize;    }}</code></pre><h3 id="3、GlobalExceptionHandler全局异常处理器"><a href="#3、GlobalExceptionHandler全局异常处理器" class="headerlink" title="3、GlobalExceptionHandler全局异常处理器"></a>3、GlobalExceptionHandler全局异常处理器</h3><p>全局异常处理器是spring-mvc中异常集中处理的地方。配置全局异常处理器后，Controller中只需要关注代码正常执行的情况，而异常发生时由全局异常处理器来进行统一的处理，并且根据前台需要的是普通视图还是JSON字符串进行不同的响应，具体代码如下：</p><pre><code>package com.carleviets.crm.exceptions;import com.carleviets.crm.po.vo.ResultInfo;import com.carleviets.crm.utils.JsonUtil;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.method.HandlerMethod;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.lang.reflect.Method;@Componentpublic class GlobalExceptionResolver implements HandlerExceptionResolver {    /**     * @param request     * @param response     * @param target    调用的方法     * @param ex     * @return     */    @Override    public ModelAndView resolveException(HttpServletRequest request,                                         HttpServletResponse response,                                         Object target,                                         Exception ex) {        ModelAndView modelAndView=createDefaultModelAndView(request);        if(ex instanceof LoginException){            LoginException e= (LoginException) ex;            modelAndView.addObject(&quot;errorMsg&quot;, e.getMsg());        }        //如果目标方法是处理器方法的实例        if(target instanceof HandlerMethod){            HandlerMethod handlerMethod= (HandlerMethod) target;            Method method=handlerMethod.getMethod();            //@ResponseBody注解区分前台是需要json数据还是视图            ResponseBody annotation = method.getAnnotation(ResponseBody.class);            if(annotation==null){                //普通页面请求                if(ex instanceof ParamsException){                    ParamsException e= (ParamsException) ex;                    modelAndView.addObject(&quot;errorMsg&quot;, e.getMsg());                }else{                    modelAndView.addObject(&quot;errorMsg&quot;, &quot;系统繁忙&quot;);                }                return modelAndView;            }else{                //前台需要json数据                ResultInfo resultInfo=new ResultInfo();                if(ex instanceof ParamsException){                    ParamsException e= (ParamsException) ex;                    resultInfo.setCode(e.getCode());                    resultInfo.setMsg(e.getMsg());                }else{                    resultInfo.setCode(417);                    resultInfo.setMsg(&quot;系统繁忙&quot;);                }                //将resultInfo转化为json数据发送到前台                JsonUtil.toJson(resultInfo, response);            }        }        return null;    }    private ModelAndView createDefaultModelAndView(HttpServletRequest request) {        ModelAndView modelAndView=new ModelAndView();        modelAndView.setViewName(&quot;error&quot;);  //设置视图名称        modelAndView.addObject(&quot;ctx&quot;, request.getContextPath());        return modelAndView;    }}</code></pre><h3 id="4、spring-mvc中拦截器实现对特定请求的拦截"><a href="#4、spring-mvc中拦截器实现对特定请求的拦截" class="headerlink" title="4、spring-mvc中拦截器实现对特定请求的拦截"></a>4、spring-mvc中拦截器实现对特定请求的拦截</h3><p>在spring-mvc中，可以通过拦截器实现对特定请求的拦截，如：拦截用户登录等。下面是一个拦截用户登录的代码：</p><pre><code>package com.carleviets.crm.interceptor;import com.carleviets.crm.service.UserService;import com.carleviets.crm.utils.AssertUtil;import com.carleviets.crm.utils.LoginUserUtil;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class LoginInterceptor extends HandlerInterceptorAdapter {    @Autowired    private UserService userService;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        //从cookie中获取到userId        Integer userId= LoginUserUtil.releaseUserIdFromCookie(request);        AssertUtil.isNotLogin(userId==null||userService.queryById(userId)==null, &quot;用户未登录&quot;);        return true;    //true为放行，false为拦截    }}</code></pre><p>除了编写拦截器外，还需要在servlet-context.xml中显示配置拦截器的拦截路径，放行的资源和放行的操作等，这种方式粒度较粗，对应的配置如下：</p><pre><code>&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt;    &lt;mvc:interceptor&gt;        &lt;!--拦截所有路径--&gt;        &lt;mvc:mapping path=&quot;/**&quot;/&gt;        &lt;!--静态资源放行--&gt;        &lt;mvc:exclude-mapping path=&quot;/statics/**&quot;/&gt;        &lt;!--登录页面放行--&gt;        &lt;mvc:exclude-mapping path=&quot;/index&quot;/&gt;        &lt;!--登录操作放行--&gt;        &lt;mvc:exclude-mapping path=&quot;/user/login&quot;/&gt;        &lt;!--配置拦截器bean--&gt;        &lt;bean class=&quot;com.carleviets.crm.interceptor.LoginInterceptor&quot;/&gt;    &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;</code></pre><p>除了这种方式外，还可以通过spring中的AOP实现拦截操作。</p><h3 id="4、通过AOP代理实现拦截请求的操作"><a href="#4、通过AOP代理实现拦截请求的操作" class="headerlink" title="4、通过AOP代理实现拦截请求的操作"></a>4、通过AOP代理实现拦截请求的操作</h3><p>在spring中，可以通过前置通知和环绕通知来实现对特定请求的拦截。下面是基于特定的注解和环绕通知来实现没有对应权限的用户的拦截代码：</p><pre><code>package com.carleviets.crm.aop;import com.carleviets.crm.annotations.RequestPermission;import com.carleviets.crm.constants.CrmConstants;import com.carleviets.crm.utils.AssertUtil;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import javax.servlet.http.HttpSession;import java.lang.reflect.Method;import java.util.List;@Component@Aspectpublic class PermissionAdapter {    @Autowired    private HttpSession httpSession;    //声明切点     @Pointcut(&quot;@annotation(com.carleviets.crm.annotations.RequestPermission)&quot;)    public void cut(){}    //声明环绕通知    @Around(&quot;cut()&quot;)    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {        //通过连接点拿到方法签名        MethodSignature methodSignature= (MethodSignature) proceedingJoinPoint.getSignature();        //通过方法签名获取到该方法        Method method=methodSignature.getMethod();        //通过方法获取到特定的注解        RequestPermission annotation=method.getAnnotation(RequestPermission.class);        //通过注解获取到权限码值        String aclValue=annotation.aclValue();        //判断会话中储存的权限列表中是否包含该权限码        List&lt;String&gt; permissions= (List&lt;String&gt;) httpSession.getAttribute(CrmConstants.USER_PERMISSIONS);        AssertUtil.isTrue(permissions==null||!permissions.contains(aclValue), &quot;没有权限&quot;);        return proceedingJoinPoint.proceed();    }}</code></pre><p>其中，注解的定义如下：</p><pre><code>package com.carleviets.crm.annotations;import java.lang.annotation.*;@Target({ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface RequestPermission {    String aclValue() default &quot;&quot;;}</code></pre><p>控制器中的方法，@RequestPermission注解中的value值为需要访问控制器中该方法的权限码值，具体代码如下：</p><pre><code>@RequestPermission(aclValue = &quot;101001&quot;)@RequestMapping(&quot;/querySaleChancesByParams&quot;)public @ResponseBody Map&lt;String, Object&gt; querySaleChancesByParams(SaleChanceQuery saleChanceQuery,                                                                  @RequestParam(defaultValue = &quot;1&quot;) Integer page,                                                                  @RequestParam(defaultValue = &quot;10&quot;) Integer rows){    saleChanceQuery.setPageNum(page);    saleChanceQuery.setPageSize(rows);    return saleChanceService.queryForPage(saleChanceQuery);}</code></pre><p>通过AOP这种方式实现对特定请求的拦截，不需要在servlet-context.xml中进行任何的配置，并且控制的粒度更细，也是本人推荐使用的一种方式。</p>]]></content>
      
      
      <categories>
          
          <category> SSM整合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用工具类 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
