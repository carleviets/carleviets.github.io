<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    

<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="keywords" content="Redis总结, 江火似流萤的个人博客">
    <meta name="description" content="一、关系型数据库和非关系型数据库的对比1、关系型数据库
表与表之间存在约束关系(即所谓的范式)
表设计
SQL编写 
当表数据量很大，进行查询时，效率比较低（多表关联） 
存在IO开销问题

2、非关系型数据库非关系型数据库，基于key-v">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Redis总结 | 江火似流萤的个人博客</title>
    <link rel="icon" type="image/png" href="/medias/favicon.ico">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/css/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

</head>

<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="container">
            <div class="nav-wrapper">
                <div class="brand-logo">
                    <a href="/" class="waves-effect waves-light">
                        
                        <img src="/4027734.jpg" class="logo-img hide-on-small-only">
                        
                        <span class="logo-span">江火似流萤的个人博客</span>
                    </a>
                </div>
                

<a href="#" data-activates="mobile-nav" class="button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li>
        <a id="toggleSearch" class="waves-effect waves-light">
            <i id="searchIcon" class="mdi-action-search"></i>
        </a>
    </li>

</ul>

<div class="side-nav" id="mobile-nav">

    <div class="mobile-head bg-color">
        
        <img src="/4027734.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">江火似流萤的个人博客</div>
        <div class="logo-desc">
            
            胜，不妄喜;败，不惶妥;胸有激雷而面如平湖者，可拜上将军!
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/carleviets" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>

    <div class="social-link"><a href="https://github.com/carleviets" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
    <i class="fa fa-github"></i>
</a>
<a href="mailto:carleviets0420@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
    <i class="fa fa-envelope-open"></i>
</a>
<a href="#!" class="tooltipped" data-tooltip="QQ联系我: 892324283" data-position="top" data-delay="50">
    <i class="fa fa-qq"></i>
</a>

<a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
    <i class="fa fa-rss"></i>
</a>
</div>
</div>

            </div>
        </div>

        
        <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/carleviets" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewbox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/>
    </svg>
</a>
        
    </nav>
</header>





<div class="bg-cover post-cover" style="background-image: url('/medias/featureimages/13.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        Redis总结
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1,
    #articleContent h2,
    #articleContent h3,
    #articleContent h4,
    #articleContent h5,
    #articleContent h6 {
        padding-top: 76px;
        margin-top: -76px;
    }

    #articleContent h1 {
        line-height: 3.5rem;
    }

    #articleContent h2 {
        line-height: 3.2rem;
    }

    #articleContent h3 {
        line-height: 2.8rem;
    }

    #articleContent h4 {
        line-height: 2.5rem;
    }

    #articleContent h5 {
        line-height: 2.2rem;
    }

    #articleContent h6 {
        line-height: 1.9rem;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }
</style>
<div class="row">
    <div class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            
            <div class="article-tag">
                
                <a href="/tags/redis/" target="_blank">
                    <span class="chip bg-color">redis</span>
                </a>
                
                <a href="/tags/jedis/" target="_blank">
                    <span class="chip bg-color">jedis</span>
                </a>
                
                <a href="/tags/spring-data-redis/" target="_blank">
                    <span class="chip bg-color">spring-data-redis</span>
                </a>
                
            </div>
            
            <div class="post-info">
                
                <span class="post-cate">
                <!--<span class="post-cate" style="margin-right: 0px">-->
                    <i class="fa fa-bookmark fa-fw icon-category"></i>
                    
                    <a href="/categories/Redis/" class="post-category" target="_blank">
                        Redis
                    </a>
                    
                </span>
                

                <span class="post-date">
                    <i class="fa fa-clock-o fa-fw"></i>2019-01-20
                </span>
				
				
                    <span id="busuanzi_container_page_pv" class="post-read">
                    <i class="fa fa-eye fa-fw"></i>阅读 <span id="busuanzi_value_page_pv"></span>
				
            </span></div>
        </div>
        <hr>
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="一、关系型数据库和非关系型数据库的对比"><a href="#一、关系型数据库和非关系型数据库的对比" class="headerlink" title="一、关系型数据库和非关系型数据库的对比"></a>一、关系型数据库和非关系型数据库的对比</h2><h4 id="1、关系型数据库"><a href="#1、关系型数据库" class="headerlink" title="1、关系型数据库"></a>1、关系型数据库</h4><ul>
<li>表与表之间存在约束关系(即所谓的范式)</li>
<li>表设计</li>
<li>SQL编写 </li>
<li>当表数据量很大，进行查询时，效率比较低（多表关联） </li>
<li>存在IO开销问题</li>
</ul>
<h4 id="2、非关系型数据库"><a href="#2、非关系型数据库" class="headerlink" title="2、非关系型数据库"></a>2、非关系型数据库</h4><p>非关系型数据库，基于key-value形式对数据进行存储，优先基于内存（内存+磁盘），类似的产品（Redis、MemcachedMongoDB-基于文档存储..）。关系库能够存储的数据，在非关系库中都能实现。</p>
<p>特点:</p>
<ul>
<li>不存在表概念</li>
<li>不需要编写SQL</li>
<li>访问数据效率更高（优先基于内存）</li>
<li>支持持久化</li>
<li>Redis支持分布式存储（高可用-HA）</li>
</ul>
<h2 id="二、Redis介绍"><a href="#二、Redis介绍" class="headerlink" title="二、Redis介绍"></a>二、Redis介绍</h2><p>Redis是一个<strong>内存中的</strong>数据结构存储系统，它可以用作<strong>数据库、缓存和消息中间件</strong>。它支持多种类型的数据结构，如<strong>字符串（strings）、散列（hashes）、列表（lists)、集合（sets）、有序集合（sorted sets）</strong>与范围查询，bitmaps，hyperloglogs和地理空（geospatial）索引半径查询。 Redis内置了复制（replication），LUA脚本（Lua scripting），LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的磁盘持久化（persistence，并通过 Redis哨兵（Sentinel）和自动分区（Cluster）供高可用性（high availability）。从这段简介中我们应该掌握一下几点：</p>
<pre><code>1. Redis 是把数据存放在内存当中，所以它的运行速度会非常快
2. Redis 具有多种数据存储结构
3. Redis 具有持久化的功能
4. Redis 上的数据可以设置过期
5. Redis 支持集群，而且可以自动切换
6. 跨平台 支持多种语言客户端
</code></pre><h2 id="三、CentOS环境下Redis的安装"><a href="#三、CentOS环境下Redis的安装" class="headerlink" title="三、CentOS环境下Redis的安装"></a>三、CentOS环境下Redis的安装</h2><p>(1) 执行下面的命令执行下载并解压:</p>
<pre><code>wget http://download.redis.io/releases/redis-3.2.8.tar.gz
tar -zxvf redis-3.2.8.tar.gz
</code></pre><p>(2) 如果centos没有gcc环境, 需要先安装gcc</p>
<pre><code>yum install gcc
</code></pre><p>(3) 进入解压后的目录，通过make命令执行编译</p>
<pre><code>cd redis-3.2.8
make
</code></pre><h2 id="四、Redis的运行"><a href="#四、Redis的运行" class="headerlink" title="四、Redis的运行"></a>四、Redis的运行</h2><h4 id="1、配置文件说明"><a href="#1、配置文件说明" class="headerlink" title="1、配置文件说明"></a>1、配置文件说明</h4><pre><code>redis.conf                     redis服务器启动基本配置文件
sentinel.conf                 redis哨兵配置文件
redis-server                 启动服务器脚本
redis-cli                     连接redis服务器脚本
redis-sentinel                 redis哨兵服务器启动脚本
</code></pre><h4 id="2、Redis的运行"><a href="#2、Redis的运行" class="headerlink" title="2、Redis的运行"></a>2、Redis的运行</h4><p>(1) redis-server启动方式一</p>
<p>进入redis-3.2.8目录下，执行以下命令:</p>
<pre><code>src/redis-server
</code></pre><p>但是通过这种方式启动Redis之后当前窗口无法再继续其他操作，不推荐。</p>
<p>(2) redis-server启动方式二</p>
<p>修改redis.conf配置文件中daemonize默认属性no修改为yes，如下:</p>
<pre><code>daemonize yes
</code></pre><p>保存并退出后执行以下命令指定配置文件启动服务器:</p>
<pre><code>src/redis-server ./redis.conf
</code></pre><p>注意vi非编辑模式下可以通过    “/+待查找文本” 来执行查找，通过”:noh”来取消选中标记。</p>
<p>(3) 通过redis.conf文件中的requirepass password配置密码，如下将服务器的密码设置为123456：</p>
<pre><code>requirepass 123456
</code></pre><p>(4)Redis客户端的启动</p>
<pre><code>src/redis-cli -p port -a password
</code></pre><p>通过执行redis-cli并指定所连接的端口号和密码来启动客户端。</p>
<h2 id="五、Redis通用命令介绍"><a href="#五、Redis通用命令介绍" class="headerlink" title="五、Redis通用命令介绍"></a>五、Redis通用命令介绍</h2><pre><code>exists key                         检测指定key是否存在，返回1表示存在，0不存在
del key1 key2 ...... keyN         删除给定 key,返回删除key的数目，0表示给定key都不存在
type key                         返回给定key值的类型。返回none表示key不存在,string——字符类型，list——链表类型，set——无序集合类型......
keys pattern                     返回匹配指定模式的所有key
randomkey                           返回从当前数据库中随机选择的一个key,如果当前数据库是空的，返回空串
rename oldkey newkey             重命名一个key,如果newkey存在，将会被覆盖，返回1表示成功，0失败。返回0时可能是oldkey不存在或者和newkey 相同。
renamenx oldkey newkey             同上，但是如果newkey存在返回失败。
expire key seconds                 为key指定过期时间，单位是秒。返回1成功，0表示key已经设置过过期时间或者不存在。
ttl key                             返回设置过过期时间key的剩余过期秒数。-1表示key不存在或者未设置过期时间。
select db-index                 通过索引选择数据库，默认连接的数据库是0,默认数据库数是16个。返回1表示成功，0失败。
move key db-index                 将key从当前数据库移动到指定数据库。返回1表示成功。0表示key不存在或者已经在指定数据库中
</code></pre><h2 id="六、五种基本数据类型"><a href="#六、五种基本数据类型" class="headerlink" title="六、五种基本数据类型"></a>六、五种基本数据类型</h2><h4 id="1、string类型基本命令"><a href="#1、string类型基本命令" class="headerlink" title="1、string类型基本命令"></a>1、string类型基本命令</h4><p>string是最基本的类型，而且string类型是二进制安全的。意思是redis的string可以包含任何数据。比如 jpg 图片或者序列化的对象。从内部实现来看其实string可以看作byte组，最大上限是 1G 字节。string类型的基本命令如下:</p>
<pre><code>set key value                                 设置key对应string类型的值，返回1表示成功，0表示失败。
setnx key value                             如果key不存在，设置key对应string类型的值。如果key已经存在，返回0。
get key                                     获取key对应的string值,如果key不存在返回nil
getset key value                             先获取key的值，再设置key的值。如果key不存在返回 nil。
mget key1 key2 ......keyN                     一次获取多个key的值，如果对应key不存在，则对应返回nil。
mset key1 value1 ......keyN valueN             一次设置多个key的值，成功返回1，表示所有的值都设置了，失败返回0表示没有任何值被设置。
msetnx key1 value1 ......keyN valueN         一次设置多个 key 的值，但是不会覆盖已经存在的key
incr key                                     对key的值做++操作，并返回新的值。注意incr一个不是int的value会返回错误，incr一个不存在的key，
                                            则设置key值为1。
decr key                                     对key的值做--操作，decr一个不存在的key，则设置key值为-1。
incrby key integer                             对key加上指定值，key不存在时候会设置key，并认为原来的value是0。
decrby key integer                             对key减去指定值。decrby完全是为了可读性，我们完全可以通过incrby一个负值来实现同样效果，反之一样。
</code></pre><h4 id="2、Hash类型基本命令"><a href="#2、Hash类型基本命令" class="headerlink" title="2、Hash类型基本命令"></a>2、Hash类型基本命令</h4><pre><code>hset key field value                             设置 hash field 为指定值，如果 key 不存在，则创建
hget key field                                     获取指定的 hash field。
hmget key filed1....fieldN                         获取全部指定的 hash filed。
hmset key filed1 value1 ......filedN valueN     同时设置 hash 的多个 field。
hincrby key field integer                         将指定的hash filed加上指定值。成功返回hash filed变更后的值。
hexists key field                                 检测指定 field 是否存在。
hdel key field                                     删除指定的hash field。
hlen key                                         返回指定 hash 的 field 数量
hkeys key                                         返回 hash 的所有 field。
hvals key                                         返回 hash 的所有 value。
hgetall key                                     返回 hash 的所有 filed 和 value。
</code></pre><p>内部实现方式:Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，当Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject 的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap。</p>
<h4 id="3、List类型基本命令"><a href="#3、List类型基本命令" class="headerlink" title="3、List类型基本命令"></a>3、List类型基本命令</h4><pre><code>lpush key string                                 在key对应list的头部添加字符串元素，返回1表示成功，0表示key存在且不是list类型。
rpush key string                                 在key对应list的尾部添加字符串元素。
llen key                                         返回key对应list的长度，如果key不存在返回0，如果key对应类型不是list返回错误。
lrange key start end                             返回指定区间内的元素，下标从0开始，负值表示从后面计算，-1表示倒数第一个元素 ，key不存在返回空列表。
ltrim key start end                             截取list指定区间内元素，成功返回 1，key不存在返回错误。
lset key indexvalue                             设置list中指定下标的元素值，成功返回 1，key或者下标不存在返回错误。
lrem key count value                             从List的头部（count 正数）或尾部（count 负数）删除一定数量（count）匹配value的元素，返回删除的元素数量。count为0时候删除全部。
lpop key                                         从list的头部删除并返回删除元素。如果key对应list不存在或者是空返回nil，如果key对应值不是 list 返回错误。
rpop key                                         从list的尾部删除并返回删除元素。
blpop key1 ......keyN timeout                     从左到右扫描，返回对第一个非空list进行lpop 操作并返回，比如 blpop list1 list2 list3 0 ,如果list不存在
                                                   list2,list3 都是非空则对 list2 做 lpop 并返回从 list2 中删除的元素。如果所有的list都是空或不存在，则
                                                会阻塞timeout秒，timeout为0表示一直阻塞。当阻塞时，如果有client对key1...keyN中的任意key进行push操作，则
                                                第一在这个key上被阻塞的client会立即返回。如果超时发生，则返回nil。有点像unix的select或者poll。
brpop                                             同blpop，一个是从头部删除一个是从尾部删除
</code></pre><p>Lists的另一个应用就是队列,可以利用Lists的PUSH操作，将任务存在List中，然后工作线程再用POP操作将任务取出进行执行。</p>
<p>内部实现方式：Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis 内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。</p>
<h4 id="4、Set类型基本命令"><a href="#4、Set类型基本命令" class="headerlink" title="4、Set类型基本命令"></a>4、Set类型基本命令</h4><p>是无序集合，最大可以包含(2的32次方-1)个元素。set的是通过hashtable实现的，所以添加，删除，查找的复杂度都是 O(1)。hash table会随着添加或者删除自动的调整大小。需要注意的是调整hashtable大小时候需要同步（获取写锁）会阻塞其他读写操作。关于 set 集合类型除了基本的添加删除操作，其它有用的操作还包含集合的取并集(union)，交集(intersection)，差集(difference)。通过这些操作可以很容易的实现SNS中的好友推荐和blog的tag功能。set集合的基本命令如下:</p>
<pre><code>sadd key member                         添加一个string元素到key对应set集合中，成功返回1,如果元素以及在集合中则返回0，
                                        key对应的set不存在则返回错误。
srem key member                         从key对应set中移除指定元素，成功返回1，如果member在集合中不存在或者key不存在返回0，
                                        如果key对应的不是set类型的值返回错误。
spop key                                 删除并返回key对应set中随机的一个元素,如果set是空或者key不存在返回nil。
srandmember key                         同spop，随机取set中的一个元素，但是不删除元素。
smove srckey dstkey member                 从srckey对应set中移除member并添加到dstkey对应set中，整个操作是原子的。
                                        成功返回1,如果member在srckey中不存在返回0，如果key不是set类型返回错误。
Scard key                                 返回set的元素个数，如果set是空或者key不存在返回0。
sismember key member                     判断member是否在set中，存在返回1，0表示不存在或者key不存在。
sinter key1 key2 …… keyN                 返回所有给定key的交集。
sinterstore dstkey key1 ....... keyN     返回所有给定key的交集，并保存交集存到dstkey下。
sunion key1 key2 ...... keyN             返回所有给定key的并集。
sunionstore dstkey key1 ......keyN         返回所有给定key的并集，并保存并集到dstkey下。
sdiff key1 key2 ......keyN                 返回所有给定key的差集。
sdiffstore dstkey key1 ......keyN         返回所有给定key的差集，并保存差集到dstkey下。
smembers key                             返回key对应set的所有元素，结果是无序的。
</code></pre><p>set的内部实现是一个value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。</p>
<h4 id="5、Sorted-Set类型基本命令"><a href="#5、Sorted-Set类型基本命令" class="headerlink" title="5、Sorted Set类型基本命令"></a>5、Sorted Set类型基本命令</h4><p>Sorted Set是有序集合，它在set的基础上增加了一个顺序属性，这一属性在添加修改元素的时候可以指定，每次指定后，会自动重新按新的值调整顺序。可以理解了有两列的mysql表，一列存 value，一列存顺序。操作中 key 理解为sorted set的名字，最多包含2^(32-1)个元素。Sorted Set集合的基本，命令如下:</p>
<pre><code>zadd key score member                     添加元素到集合，元素在集合中存在则更新对应score。
zrem key member                         删除指定元素，1表示成功，如果元素不存在返回0。
zincrby key incrmember                     增加对应member的score，然后移动元素并保持skip list保持有序。返回更新后的 score 值。
zrank key member                         返回指定元素在集合中的排名（下标），集合中元素是按score从小到大排序的。
zrevrankkey member                         同上,但是集合中元素是按 score 从大到小排序。
zrange key start end                     类似lrange操作从集合中去指定区间的元素。返回的是有序结果
zrevrange key start end                 同上，返回结果是按score逆序的。
zrangebyscore key min max                 返回集合中score在给定区间的元素。
zcount key min max                         返回集合中score在给定区间的数量。
zcard key                                 返回集合中元素个数。
zscore key element                         返回给定元素对应的 score
</code></pre><h2 id="四、集群环境下Redis实现主备切换和读写分离"><a href="#四、集群环境下Redis实现主备切换和读写分离" class="headerlink" title="四、集群环境下Redis实现主备切换和读写分离"></a>四、集群环境下Redis实现主备切换和读写分离</h2><p>Redis支持主从复用。数据可以从主服务器向任意数量的从服务器上同步，同步使用的是发布/订阅机制。Mater Slave的模式，从Slave向Master发起 SYNC 命令。可以是1 Master 多 Slave，也可以分层，Slave 下可以再接Slave，可扩展成树状结构。这里使用单机来模拟redis主从服务器 ，实现读写分离配置。具体实现步骤如下：</p>
<h4 id="1、Redis实现读写分离"><a href="#1、Redis实现读写分离" class="headerlink" title="1、Redis实现读写分离"></a>1、Redis实现读写分离</h4><p>(1) Redis节点准备</p>
<p>在home目录新建ha文件夹并拷贝三份 redis 服务器文件到该目录下，分别更名为redis-6379，redis-6380和redis-6381，其中redis-6379作为主服务器，redis-6380和redis-6381作为从服务器。通过以下命令执行复制:</p>
<pre><code>cp -r 源目录 目标目录
</code></pre><p>(2) 修改主服务器的配置</p>
<p>进入redis-6379目录，以vi编辑模式进入redis.conf文件，修改slave-read-only属性的值修改为yes,requirepass属性指定具体的密码:</p>
<pre><code>slave-read-only yes 从服务器默认是只读的不允许输入
requirepass 123456    指定主服务器的访问密码
</code></pre><p>(3) 修改从服务器的配置</p>
<p>分别进入redis-6380和redis-6381目录，以vi编辑模式进入redis.conf文件，需要修改的配置如下:</p>
<pre><code>port 6380    指定从服务器的端口
requirepass 123456    指定该从服务器的访问密码
slaveof &lt;masterip&gt; &lt;masterport&gt;        指定该从服务器所隶属的主服务器的ip和端口
masterauth 指定该从服务器的主服务器密码
</code></pre><p>slave of 后填写主服务器的ip和主服务器的端口。</p>
<p>以上两处修改完毕后，查看服务器的具体信息,命令如下:</p>
<pre><code>info replication
</code></pre><h4 id="2、Redis实现主备切换"><a href="#2、Redis实现主备切换" class="headerlink" title="2、Redis实现主备切换"></a>2、Redis实现主备切换</h4><p>(1) Redis节点准备</p>
<p>Redis服务器三台：</p>
<pre><code>redis-6379(master)
redis-6380(slave)
redis-6381(slave)
</code></pre><p>Sentinel 哨兵服务器三台:</p>
<pre><code>redis-26379
redis-26380
redis-26381
</code></pre><p>(2)主从节点redis.conf配置</p>
<p>主节点配置:</p>
<pre><code>设置端口(port),daemonize,密码(requirepass)，主节点密码(masterauth),禁用 bind 等基本配置。
</code></pre><p><strong>注意</strong>，这里必须加入<strong>masterauth</strong>属性，因为如果主节点宕机后，再重新加入集群是作为从服务器的，需要主节点的访问密码。</p>
<p>从节点配置:</p>
<pre><code>设置端口(port),requirepass,daemonize,主节点密码(masterauth),禁用 bind ,slaveof 属性设置等。
</code></pre><p>(3)sentinel.conf 哨兵文件配置</p>
<p>初始化启动配置:</p>
<ul>
<li>默认监听 6379 端口</li>
<li>设置连接服务器密码属性: sentinel auth-pass mymaster</li>
<li>设置同意选举成功的票数为 2 台(通常为:至少为半数票数通过)</li>
</ul>
<p>具体说明如下:</p>
<pre><code>##redis
## 哨兵监听进程端口号设置
port 26379
#master
# 指示 Sentinel 去监视一个名为 master 的主服务器， 这个主服务器的 IP 地址为
# 127.0.0.1 ， 端口号为 6379 ， 而将这个主服务器判断为失效至少需要 1 个
# Sentinel 同意 （只要同意 Sentinel 的数量不达标，自动故障迁移就不会执行）。
sentinel monitor master 192.168.132.8 6379 2
# Sentinel 认为服务器已经断线所需的毫秒数
sentinel down-after-milliseconds master 5000
#若 sentinel 在该配置值内未能完成 failover 操作（即故障时 master/slave 自动切
换），则认为本次 failover 失败。
sentinel failover-timeout master 900000
</code></pre><p>(4)测试主备切换</p>
<ul>
<li>服务器启动顺序:先启动redis服务器，后启动哨兵服务器</li>
<li>关闭主服务器，查看哨兵日志信息-&gt;找到新的主节点 添加redis 数据</li>
</ul>
<h2 id="五、Redis-持久化"><a href="#五、Redis-持久化" class="headerlink" title="五、Redis 持久化"></a>五、Redis 持久化</h2><p>对于 Redis,其提供了不同级别的持久化操作:</p>
<ul>
<li><p>RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照。</p>
</li>
<li><p>AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。</p>
</li>
<li><p>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时,它会优先使用 AOF 文件来还原数据集,因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</p>
</li>
<li><p>持久化功能当然也可以进行关闭操作，让数据仅在服务器运行时存在</p>
</li>
</ul>
<h4 id="1、RDB持久化操作（快照-SnapShot-方式）"><a href="#1、RDB持久化操作（快照-SnapShot-方式）" class="headerlink" title="1、RDB持久化操作（快照 SnapShot 方式）"></a>1、RDB持久化操作（快照 SnapShot 方式）</h4><p>默认情况下，Redis将数据库快照保存在名字为 dump.rdb 的二进制文件中。当然， 这里可以通过修改 redis.conf 配置文件来对数据存储条件进行定义，规定在“ N 秒内数据集至少有 M 个改动”这一条件被满足时,自动保存一次数据集。 也可以通过调用save 或 bgsave ,手动让 Redis 进行数据集保存操作。</p>
<p><img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fzd6umpa2aj30hl0azjrx.jpg" alt=""></p>
<p><strong>Save | Bgsave 手动方式即时保存数据</strong></p>
<p>通过 save 操作 ，当前 io 操作被阻塞，当 save 保存执行完毕才会进行后续 io 操作。而bgsave 操作在背后开启一个新的进程来对数据进行快照处理。保存后的快照存放在 dump.rdb 文件中，快照RDB文件的名称和具体位置在redis.conf如下:</p>
<p><img src="http://wx2.sinaimg.cn/mw690/0060lm7Tly1fzd6zuidurj30fv05uwem.jpg" alt=""></p>
<p><strong>快照运行方式</strong></p>
<p>当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作：</p>
<ul>
<li>Redis调用 fork()，同时拥有父进程和子进程。</li>
<li>子进程将数据集写入到一个临时 RDB 文件中。</li>
<li>当子进程完成对新RDB文件的写入时，Redis用新RDB文件替换原来的RDB文件，并删除旧的RDB文件。</li>
</ul>
<p><strong>RDB 优缺点</strong></p>
<p>优点:</p>
<ul>
<li><p>RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 该文件适合用于进行备份 。 比如说，可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。</p>
</li>
<li><p>RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心。</p>
</li>
<li><p>RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。</p>
</li>
<li><p>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>如果想要做到数据实时备份级别，此时使用 rdb 快照进行备份可能会出现数据无法备份完整情况，比如在数据备份完毕下次备份操作发起前，服务器由于某种原因意外宕机，此时采用 rdb 就无法对当前情况做的实时响应处理。</p>
</li>
<li><p>RDB 需要经常 fork 子进程来保存数据集到硬盘上,当数据集比较大的时候,fork 的过程是非常耗时的,可能会导致 Redis 在一些毫秒级内不能响应客户端的请求.如果数据集巨大并且 CPU 性能不是很好的情况下,这种情况会持续 1 秒,AOF 也需要 fork,但是你可以调节重写日志文件的频率来提高数据集的耐久度。</p>
</li>
</ul>
<h4 id="2、AOF只追加操作的文件"><a href="#2、AOF只追加操作的文件" class="headerlink" title="2、AOF只追加操作的文件"></a>2、AOF只追加操作的文件</h4><p> AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， AOF文件的体积也会变得越来越大。但是，AOF可以在不打断服务客户端的情况下，对 AOF 文件进行重建（rebuild）。 Redis 2.4 则可以自动触发 AOF 重写。AOF 重写文件配置:</p>
<pre><code>############################## APPEND ONLY MODE
###############################
# 是否开启 AOF，默认关闭（no）
appendonly yes

# 指定 AOF 文件名
appendfilename appendonly.aof

# Redis 支持三种不同的刷写模式：
# appendfsync always #每次收到写命令就立即强制写入磁盘，是最有保证的完全的持久化，但速度也是最慢的，一般不推荐使用。
appendfsync everysec #每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，是受推荐的方式。
# appendfsync no #完全依赖 OS 的写入，一般为 30 秒左右一次，性能最好但是持久化最没有保证，不被推荐。

#在日志重写时，不进行命令追加操作，而只是将其放在缓冲区里，避免与命令的追加造成DISK IO 上的冲突。
#设置为 yes 表示 rewrite 期间对新写操作不 fsync,暂时存在内存中,等 rewrite 完成后再写入，默认为 no
no-appendfsync-on-rewrite no

#当前 AOF 文件大小是上次日志重写得到 AOF 文件大小的二倍时，自动启动新的日志重写过程。
auto-aof-rewrite-percentage 100

#当前 AOF 文件启动新的日志重写过程的最小值，避免刚刚启动 Reids 时由于文件尺寸较小导致频繁的重写。
auto-aof-rewrite-min-size 64mb
</code></pre><h2 id="六、使用-Jedis-客户端工具操作-redis"><a href="#六、使用-Jedis-客户端工具操作-redis" class="headerlink" title="六、使用 Jedis 客户端工具操作 redis"></a>六、使用 Jedis 客户端工具操作 redis</h2><h4 id="1、服务端环境准备"><a href="#1、服务端环境准备" class="headerlink" title="1、服务端环境准备"></a>1、服务端环境准备</h4><ul>
<li><p>添加访问认证</p>
<pre><code>  requirepass 123456        指定该从服务器的访问密码
</code></pre></li>
<li><p>ip地址bind属性修改</p>
<p>  <img src="http://wx3.sinaimg.cn/mw690/0060lm7Tly1fzd8fh6orrj30fg044jrf.jpg" alt=""></p>
</li>
</ul>
<p>将 bind 127.0.0.1 属性禁用（如果不禁用，仅限本机ip访问redis服务器）能够让外界客户端进行访问。</p>
<ul>
<li><p>关闭防火墙</p>
<pre><code>  service iptables stop
</code></pre></li>
</ul>
<h4 id="2、pom依赖引入"><a href="#2、pom依赖引入" class="headerlink" title="2、pom依赖引入"></a>2、pom依赖引入</h4><pre><code>&lt;!--Jedis客户端依赖--&gt;
&lt;dependency&gt;
  &lt;groupId&gt;redis.clients&lt;/groupId&gt;
  &lt;artifactId&gt;jedis&lt;/artifactId&gt;
  &lt;version&gt;2.9.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h4 id="3、通过-junit-进行简单测试"><a href="#3、通过-junit-进行简单测试" class="headerlink" title="3、通过 junit 进行简单测试"></a>3、通过 junit 进行简单测试</h4><pre><code>package com.carleviets;

import org.junit.Test;
import redis.clients.jedis.Jedis;

import java.util.HashMap;
import java.util.Map;

public class RedisTest {

    @Test
    public void test01(){
        Jedis jedis=new Jedis(&quot;192.168.107.220&quot;, 6379);
        jedis.auth(&quot;123456&quot;);   //设置连接密码
        jedis.set(&quot;2019&quot;, &quot;hello redis!&quot;);
        System.out.println(jedis.get(&quot;2019&quot;));
        System.out.println(jedis.type(&quot;2019&quot;));
    }

}
</code></pre><h4 id="4、Jedis客户端操作数据的RedisUtil工具类"><a href="#4、Jedis客户端操作数据的RedisUtil工具类" class="headerlink" title="4、Jedis客户端操作数据的RedisUtil工具类"></a>4、Jedis客户端操作数据的RedisUtil工具类</h4><p>以下是用连接池的思想实行封装的RedisUtil工具类:</p>
<pre><code>package com.carleviets.util;

import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPoolConfig;
import redis.clients.jedis.Jedis;

public final class RedisUtil {
    //Redis 服务器 IP
    private static String ADDR = &quot;192.168.107.220&quot;;
    //Redis 的端口号
    private static int PORT = 6379;
    //访问密码
    private static String AUTH = &quot;123456&quot;;
    //可用连接实例的最大数目，默认值为 8；
    //如果赋值为-1，则表示不限制；如果 pool 已经分配了 maxActive 个 jedis 实例，则此时 pool 的状态为 exhausted(耗尽)。
    private static int MAX_ACTIVE = 1024;
    //控制一个 pool 最多有多少个状态为 idle(空闲的)的 jedis 实例，默认值也是 8。
    private static int MAX_IDLE = 200;
    //等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。
    //如果超过等待时间，则直接抛出 JedisConnectionException；
    private static int MAX_WAIT = 10000;
    private static int TIMEOUT = 10000;
    //在 borrow 一个 jedis 实例时，是否提前进行 validate 操作；
    //如果为 true，则得到的 jedis 实例均是可用的；
    private static boolean TEST_ON_BORROW = true;
    private static JedisPool jedisPool = null;
    /**
     * 初始化 Redis 连接池
     */
    static {
        try {
            JedisPoolConfig config = new JedisPoolConfig();
            config.setMaxTotal(MAX_ACTIVE);
            config.setMaxIdle(MAX_IDLE);
            config.setMaxWaitMillis(MAX_WAIT);
            config.setTestOnBorrow(TEST_ON_BORROW);
            jedisPool = new JedisPool(config, ADDR, PORT, TIMEOUT, AUTH);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    /**
     * 获取 Jedis 实例
     * @return
     */
    public synchronized static Jedis getJedis() {
        try {
            if (jedisPool != null) {
                Jedis resource = jedisPool.getResource();
                return resource;
            } else {
                return null;
            }
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
    /**
     * 释放 jedis 资源
     * @param jedis
     */
    public static void returnResource(final Jedis jedis) {
        if (jedis != null) {
            //此处close()方法将连接还给连接池对象，并不是关闭jedis连接
            jedisPool.close();
        }
    }
}
</code></pre><p>如果要想获取一个Redis连接的话，只需要调用RedisUtil.getJedis()方法即可。</p>
<h2 id="七、Spring-Data-Redis-操作-redis-服务器"><a href="#七、Spring-Data-Redis-操作-redis-服务器" class="headerlink" title="七、Spring-Data-Redis 操作 redis 服务器"></a>七、Spring-Data-Redis 操作 redis 服务器</h2><h4 id="1、pom坐标依赖"><a href="#1、pom坐标依赖" class="headerlink" title="1、pom坐标依赖"></a>1、pom坐标依赖</h4><pre><code>&lt;!-- spring-data-redis --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
  &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;
  &lt;version&gt;1.8.1.RELEASE&lt;/version&gt;
&lt;/dependency&gt;

&lt;!--jedis 客户端--&gt;
&lt;dependency&gt;
  &lt;groupId&gt;redis.clients&lt;/groupId&gt;
  &lt;artifactId&gt;jedis&lt;/artifactId&gt;
  &lt;version&gt;2.9.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h4 id="2、spring-xml具体配置"><a href="#2、spring-xml具体配置" class="headerlink" title="2、spring.xml具体配置"></a>2、spring.xml具体配置</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--jedis连接池配置--&gt;
    &lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;
        &lt;!--允许的最大连接数--&gt;
        &lt;property name=&quot;maxTotal&quot; value=&quot;1024&quot;/&gt;
        &lt;!--最大空闲连接数--&gt;
        &lt;property name=&quot;maxIdle&quot; value=&quot;200&quot;/&gt;
        &lt;!--获取连接时最大等待毫秒数--&gt;
        &lt;property name=&quot;maxWaitMillis&quot; value=&quot;10000&quot;/&gt;
        &lt;!--在获取连接时检查有效性--&gt;
        &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--配置客户端连接工厂--&gt;
    &lt;bean id=&quot;jedisConnectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;&gt;
        &lt;property name=&quot;usePool&quot; value=&quot;true&quot;/&gt;
        &lt;property name=&quot;hostName&quot; value=&quot;192.168.107.220&quot;/&gt;
        &lt;property name=&quot;port&quot; value=&quot;6379&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
        &lt;constructor-arg name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--配置RedisTemplate模板--&gt;
    &lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;
        &lt;!--配置redis模板的连接工厂--&gt;
        &lt;property name=&quot;connectionFactory&quot; ref=&quot;jedisConnectionFactory&quot;/&gt;

        &lt;!--配置键序列化以及哈希键序列化方式--&gt;
        &lt;property name=&quot;keySerializer&quot;&gt;
            &lt;bean class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;/&gt;
        &lt;/property&gt;
        &lt;property name=&quot;hashKeySerializer&quot;&gt;
            &lt;bean class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre><h4 id="3、测试代码"><a href="#3、测试代码" class="headerlink" title="3、测试代码"></a>3、测试代码</h4><pre><code>package com.carleviets;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {&quot;classpath:spring.xml&quot;})
public class SpringDataRedisTest {

    @Resource
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    @Test
    public void test01(){
        ValueOperations&lt;String, Object&gt; valueOperations= redisTemplate.opsForValue();
        valueOperations.set(&quot;spring_data_redis&quot;, &quot;redis is not easy!&quot;);
        //System.out.println(valueOperations.get(&quot;spring_data_redis&quot;));
    }

}
</code></pre><h2 id="八、Spring-Data-Redis环境下读写分离配置"><a href="#八、Spring-Data-Redis环境下读写分离配置" class="headerlink" title="八、Spring-Data-Redis环境下读写分离配置"></a>八、Spring-Data-Redis环境下读写分离配置</h2><h4 id="1、pom坐标依赖-1"><a href="#1、pom坐标依赖-1" class="headerlink" title="1、pom坐标依赖"></a>1、pom坐标依赖</h4><p>pom坐标依赖同上述单机环境下的坐标依赖。</p>
<h4 id="2、spring-xml具体配置（spring-sentinel-xml）"><a href="#2、spring-xml具体配置（spring-sentinel-xml）" class="headerlink" title="2、spring.xml具体配置（spring-sentinel.xml）"></a>2、spring.xml具体配置（spring-sentinel.xml）</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--Redis连接池配置--&gt;
    &lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;
        &lt;!--最大连接数--&gt;
        &lt;property name=&quot;maxTotal&quot; value=&quot;1024&quot;/&gt;
        &lt;!--最大空闲连接数--&gt;
        &lt;property name=&quot;maxIdle&quot; value=&quot;200&quot;/&gt;
        &lt;!--获取连接时最大等待毫秒数--&gt;
        &lt;property name=&quot;maxWaitMillis&quot; value=&quot;10000&quot;/&gt;
        &lt;!--在获取连接时检查有效性--&gt;
        &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--哨兵配置，注意哨兵节点只监视主节点--&gt;
    &lt;bean id=&quot;redisSentinelConfiguration&quot; class=&quot;org.springframework.data.redis.connection.RedisSentinelConfiguration&quot;&gt;
        &lt;property name=&quot;master&quot;&gt;
            &lt;bean class=&quot;org.springframework.data.redis.connection.RedisNode&quot;&gt;
                &lt;property name=&quot;name&quot; value=&quot;mymaster&quot;/&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
        &lt;property name=&quot;sentinels&quot;&gt;
            &lt;set&gt;
                &lt;bean class=&quot;org.springframework.data.redis.connection.RedisNode&quot;&gt;
                    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.107.220&quot;/&gt;
                    &lt;constructor-arg name=&quot;port&quot; value=&quot;26379&quot;/&gt;
                &lt;/bean&gt;
                &lt;bean class=&quot;org.springframework.data.redis.connection.RedisNode&quot;&gt;
                    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.107.220&quot;/&gt;
                    &lt;constructor-arg name=&quot;port&quot; value=&quot;26380&quot;/&gt;
                &lt;/bean&gt;
                &lt;bean class=&quot;org.springframework.data.redis.connection.RedisNode&quot;&gt;
                    &lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.107.220&quot;/&gt;
                    &lt;constructor-arg name=&quot;port&quot; value=&quot;26381&quot;/&gt;
                &lt;/bean&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;!--Redis连接工厂配置--&gt;
    &lt;bean id=&quot;jedisConnectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;&gt;
        &lt;!--连接池的引用--&gt;
        &lt;property name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot;/&gt;
        &lt;!--哨兵配置的引用--&gt;
        &lt;constructor-arg name=&quot;sentinelConfig&quot; ref=&quot;redisSentinelConfiguration&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;
    &lt;/bean&gt;

    &lt;!--配置redis模板--&gt;
    &lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;
        &lt;!--配置连接工厂引用--&gt;
        &lt;property name=&quot;connectionFactory&quot; ref=&quot;jedisConnectionFactory&quot;/&gt;
        &lt;!--配置keySerializer和hashKeySerializer--&gt;
        &lt;property name=&quot;keySerializer&quot;&gt;
            &lt;bean class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;&gt;&lt;/bean&gt;
        &lt;/property&gt;
        &lt;property name=&quot;hashKeySerializer&quot;&gt;
            &lt;bean class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot;&gt;&lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre><p><strong>说明:</strong><br>Spring-data-redis 中是先将 key 与 value 进行序列化成变成 byte[] 字节数组进行传输，再调用对应的 redis的java客户端进行存储的。默认情况下，Redis采用JdkSerializationRedisSerializer，该序列化器序列化的是Object对象。而在一般情况下，对于 key 序列化采用字符串进行序列化，对于value序列化采用默认的JdkSerializationRedisSerializer。</p>
<h4 id="3、测试代码-1"><a href="#3、测试代码-1" class="headerlink" title="3、测试代码"></a>3、测试代码</h4><pre><code>package com.carleviets;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {&quot;classpath:spring-sentinel.xml&quot;})
public class SpringDataRedisTest2 {

    @Resource
    private RedisTemplate redisTemplate;

    @Test
    public void test(){
        redisTemplate.opsForValue().set(&quot;spring_redis_sentinel&quot;, &quot;Hello, redis sentinel!&quot;);
    }


}
</code></pre><h2 id="九、采用Spring-Data-Redis的RedisUtil实用工具类的简单封装"><a href="#九、采用Spring-Data-Redis的RedisUtil实用工具类的简单封装" class="headerlink" title="九、采用Spring-Data-Redis的RedisUtil实用工具类的简单封装"></a>九、采用Spring-Data-Redis的RedisUtil实用工具类的简单封装</h2><pre><code>package com.carleviets.util;

import org.springframework.data.redis.core.HashOperations;
import org.springframework.data.redis.core.ListOperations;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

/**
 * Redis操作数据的简单封装
 */
@Component
@SuppressWarnings(&quot;all&quot;)
public class RedisUtils {
    private RedisTemplate&lt;String,Object&gt; redisTemplate;
    private ValueOperations&lt;String, Object&gt; valueOperations;
    private ListOperations&lt;String, Object&gt; listOperations;
    private HashOperations&lt;String, String, Object&gt; hashOperations;

    public RedisUtils(RedisTemplate&lt;String, Object&gt; redisTemplate) {
        this.redisTemplate = redisTemplate;
        valueOperations=this.redisTemplate.opsForValue();
        listOperations=this.redisTemplate.opsForList();
        hashOperations=this.redisTemplate.opsForHash();
    }

    public void setString(String key,Object value){
        valueOperations.set(key, value);
    }

    public void setStringExpires(String key,Object value,Long time){
        valueOperations.set(key, value, time, TimeUnit.MINUTES);
    }

    public Object getString(String key){
        return valueOperations.get(key);
    }

    public void clearKeyByPattern(String pattern){
        Set&lt;String&gt; keys= redisTemplate.keys(pattern);
        if(!CollectionUtils.isEmpty(keys)){
            redisTemplate.delete(keys);
        }
    }

    public void delKey(String key){
        if(redisTemplate.hasKey(key)){
            redisTemplate.delete(key);
        }
    }

    public void setList(String key,List list){
        if(!CollectionUtils.isEmpty(list)){
            for(Object t:list){
                listOperations.rightPush(key, t);
            }
        }
    }

    public List&lt;Object&gt; getList(String key){
        List&lt;Object&gt; list=null;
        if(redisTemplate.hasKey(key)){
            list=listOperations.range(key, 0, -1);
        }
        return list;
    }

    public void setHash(String key,String field,Object t){
        hashOperations.put(key, field, t);
    }

    public void setHashAll(String key,Map&lt;String, Object&gt; map){
        hashOperations.putAll(key, map);
    }

    public Object getHash(String key,String field){
        return hashOperations.get(key, field);
    }

    public List&lt;Object&gt; getMultiHash(String key,List fields){
        return hashOperations.multiGet(key, fields);
    }

    public Map getHashMap(String key){
        return hashOperations.entries(key);
    }
}
</code></pre><h2 id="十、热点问题"><a href="#十、热点问题" class="headerlink" title="十、热点问题"></a>十、热点问题</h2><h4 id="1、缓存穿透现象"><a href="#1、缓存穿透现象" class="headerlink" title="1、缓存穿透现象"></a>1、缓存穿透现象</h4><p>缓存系统，按照 KEY 去查询 VALUE,当 KEY 对应的 VALUE 一定不存在的时候并对 KEY 并发请求量很大的时候，就会造成缓存穿透情况!</p>
<p>缓存穿透场景:</p>
<ul>
<li><p>根据key查询对应value不存在时，到数据库中查询</p>
</li>
<li><p>当key对应value一定不存在，且查询并发量很大时，数据库压力增大!</p>
</li>
</ul>
<p>解决方案:</p>
<ul>
<li><p>对查询结果为空也进行缓存，并设置缓存过期时间</p>
</li>
<li><p>对不存在的 key 进行过滤操作——布隆过滤器</p>
</li>
</ul>
<p>业务代码中添加缓存时，并发量高的情况下下出现缓存穿透问题,这种情况下的解决方案:</p>
<ul>
<li>双重检查锁 类比单例模式下 双重检查锁实现</li>
</ul>
<h4 id="2、缓存雪崩现象"><a href="#2、缓存雪崩现象" class="headerlink" title="2、缓存雪崩现象"></a>2、缓存雪崩现象</h4><p>如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，就有可能造成存雪崩现象。</p>
<p>解决方案:</p>
<ul>
<li><p>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
</li>
<li><p>不同的 key，设置不同的过期时间，让缓存失效的时间点尽量均匀</p>
</li>
<li><p>做二级缓存，或者双缓存策略。比如A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。</p>
</li>
</ul>

            </div>
            <hr>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            <div class="reprint">
                <p>
                    <span class="reprint-tip">转载请注明: </span>
                    <a href="http://www.carleviets.club" class="b-link-green">江火似流萤的个人博客</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/2019/01/20/Redis总结/" class="b-link-green">Redis总结</a>
                </p>
            </div>
        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">本篇</div>
            <div class="card">
                <a href="/2019/01/20/Redis总结/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="Redis总结">
                        
                        <span class="card-title">Redis总结</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">一、关系型数据库和非关系型数据库的对比1、关系型数据库
表与表之间存在约束关系(即所谓的范式)
表设计
SQL编写 
当表数据量很大，进行查询时，效率比较低（多表关联） 
存在IO开销问题

2、非关系型数据库非关系型数据库，基于key-v</div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-01-20
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Redis/" class="post-category" target="_blank">
                                    Redis
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/redis/" target="_blank">
                        <span class="chip bg-color">redis</span>
                    </a>
                    
                    <a href="/tags/jedis/" target="_blank">
                        <span class="chip bg-color">jedis</span>
                    </a>
                    
                    <a href="/tags/spring-data-redis/" target="_blank">
                        <span class="chip bg-color">spring-data-redis</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">下一篇</div>
            <div class="card">
                <a href="/2019/01/19/Git常用命令总结/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/17.jpg" class="responsive-img" alt="Git常用命令总结">
                        
                        <span class="card-title">Git常用命令总结</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">一、git的三个分区

工作区（Working Directory）是直接编辑的地方，肉眼可见，直接操作。

暂存区（Stage 或 Index）数据暂时存放的区域。 

版本库（commit History）存放已经提交的数据，push </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-01-19
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/git/" class="post-category" target="_blank">
                                    git
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/git/" target="_blank">
                        <span class="chip bg-color">git</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


    </div>
    <div class="col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title">目录</div>
            <div id="toc-content">

            </div>
        </div>
    </div>
</div>

<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
			<!--
            本站由&copy;<a href="https://blinkfox.github.io/" target="_blank">Blinkfox</a>基于
            <a href="https://hexo.io/" target="_blank">Hexo</a> 的
            <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">hexo-theme-matery</a>主题搭建.
			-->

            
			
                <br>
                <span id="busuanzi_container_site_pv">
                    本站总访问量 <span id="busuanzi_value_site_pv" style="color: #fff;"></span> 次,&nbsp;
                </span>
				<span id="busuanzi_container_site_uv">
                    访客数 <span id="busuanzi_value_site_uv" style="color: #fff;"></span> 人.
                </span>
			
        </div>
        <div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/carleviets" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
    <i class="fa fa-github"></i>
</a>
<a href="mailto:carleviets0420@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
    <i class="fa fa-envelope-open"></i>
</a>
<a href="#!" class="tooltipped" data-tooltip="QQ联系我: 892324283" data-position="top" data-delay="50">
    <i class="fa fa-qq"></i>
</a>

<a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
    <i class="fa fa-rss"></i>
</a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title">搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input" autofocus>
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/js/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>



    <script src="/libs/others/clicklove.js"></script>


    <script async src="/libs/others/busuanzi.pure.mini.js"></script>


</body>
</html>